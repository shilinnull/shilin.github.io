## 1. 什么是数据结构？
>数据结构(Data Structure)是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。

## 2. 什么是算法？
>算法(Algorithm):就是定义良好的计算过程，他取一个或一组的值为输入，并产生出一个或一组值作为输出。简单来说算法就是一系列的计算步骤，用来将输入数据转化成输出结果。

## 3. 算法效率
- `算法效率`是指算法执行的时间，算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。在现在的计算机硬件环境中，比较少需要考虑这个问题了，特别是pc机的编程，内存空间越来越大，所以被考虑得也越来越少，不过一个`好的程序员`，都应该对自己的程序有要求，每一个for比别人少一次判断1000个for就能够少掉很多的运行时间。所以能够理解，能够大概的去运用"效率度量"还是有很大意义的。

- 算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个`算法的好坏`，一般是从`时间`和`空间`两个维度来衡量的，即`时间复杂度`和`空间复杂度`。` 时间复杂度`主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算 机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了`很高`的程度。所以我们如今已经不需要再特别关注一个`算法的空间复杂度`。

## 4. 时间复杂度
### 4.1 时间复杂度的概念
- 时间复杂度的定义：
	- 在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一 个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个 分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为`算法`的时间复杂度。


>即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。
实际中我们计算时间复杂度的时候其实并不需要计算精确的执行次数，而只需要知道大概执行次数，所以这里我们引入了大O的渐进表示法。其中大O符号是用于描述函数渐进行为的数学符号。

**案例1：**
>请计算一下Func1中++count语句总共执行了多少次？

- 如果用一个函数F(N)来解释的话，怎么解释？【F(N) = N*N + 2N + 10】这是一个`函数式`
这并不方便我们进行比较，能不能简化一下？
>这里的时间复杂度是要取影响最大的项
>大O渐进表示法：`估算`-->`O(N^2)`-->`O(N)`
>我们这里不关心硬件，相同的配置`N`比`N^2`的程序要快
```c
void Func1(int N)
{
	int count = 0;
	for (int i = 0; i < N; ++i)
	{
		for (int j = 0; j < N; ++j)
		{
			++count;
		}
	}

	for (int k = 0; k < 2 * N; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n", count);
}
```

>Func1 执行的基本操作次数 ：
>![在这里插入图片描述](https://img-blog.csdnimg.cn/3a5f961f659b476099b2e50516b8c603.png)
>- N = 10 F(N) = 130
>- N = 100 F(N) = 10210
>- N = 1000 F(N) = 1002010

>实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用大O的渐进表示法。



### 4.2 推导大O阶的方法：
大 O 表示法是一种计算机科学和算法分析中常用的渐进表示法，用于描述算法的时间复杂度和空间复杂度。它帮助我们衡量算法在输入规模增加时，运行时间或内存使用的增长趋势，而不需要精确地测量或比较具体的运行时间。

>大 O 表示法使用 "O(f(n))" 的形式，其中 "f(n)" 表示输入规模 "n" 的函数。这意味着当输入规模足够大时，算法的运行时间或内存使用将以 "f(n)" 函数的方式增长。以下是一些常见的大 O 表示法及其含义：
- O(1)：常数时间复杂度
表示算法的运行时间不受输入规模的影响，无论输入有多大，运行时间都是固定的。
- O(log n)：对数时间复杂度
表示算法的运行时间以对数方式增长，通常见于二分查找等分治算法。
- O(n)：线性时间复杂度
表示算法的运行时间与输入规模线性增长，随着输入规模增加，运行时间也会线性增加。
- O(n log n)：线性对数时间复杂度
表示算法的运行时间随着输入规模的对数线性增加，常见于快速排序和归并排序等算法。
- O(n^2)：二次时间复杂度
表示算法的运行时间与输入规模的平方成正比，通常见于嵌套循环等情况。
- O(n^k)：多项式时间复杂度
表示算法的运行时间与输入规模的 k 次方成正比，其中 k 为常数。
- O(2^n)：指数时间复杂度
表示算法的运行时间随着输入规模的指数级增长，通常表示算法的效率非常低。
- O(n!)：阶乘时间复杂度
表示算法的运行时间随着输入规模的阶乘级增长，通常表示算法的效率非常低。
- 大 O 表示法的目的是为了提供算法效率的一种抽象概念，让人们能够更容易比较不同算法的性能，并估计它们在大规模输入下的行为。通过了解算法的大 O 复杂度，开发者可以选择合适的算法来解决问题，以便在实际应用中获得更好的性能。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c25bd55bbbdd4c63bb5a7b4ba3dda425.png)



>使用大O的渐进表示法以后，Func1的时间复杂度为：![在这里插入图片描述](https://img-blog.csdnimg.cn/658f15b4766e42b5a483c9f0b6f9442d.png)
>- N = 10 F(N) = 100
>- N = 100 F(N) = 10000
>- N = 1000 F(N) = 1000000




### 4.3 常见时间复杂度计算举例：
>接下来就看看下面这几个案例，相信你看完就有一定的了解

**实例2：**
>计算Func2的时间复杂度？
- 我们前期就一点一点的算，`F(N) = 2N + 10`
- 时间复杂度是什么?【O(N)】
- 就是取最大的那一项，当N无限大的时候`N`和`2N`没有区别，所以系数要去掉
- 时间复杂度不是算次数，是算量级

```c
void Func2(int N)
{
	int count = 0;
	for (int k = 0; k < 2 * N; ++k)
	{
		++count;
	}
	int M = 10;
	while (M--)
	{
		++count;
	}
	printf("%d\n", count);
}
```

**实例3：**
>计算Func3的时间复杂度？

- 如果不确定M和N的关系，可能M很大，可能N很大--> `O(M+N)`或者`O(max(M,N))`
- 如果N远大于M-->`O(N)`
- 如果M远大于N-->`O(M)`
- 如果N和M差不多大-->`O(N)` or `O(M)`


```c
void Func3(int N, int M)
{
	int count = 0;
	for (int k = 0; k < M; ++k)
	{
		++count;
	}
	for (int k = 0; k < N; ++k)
	{
		++count;
	}
	printf("%d\n", count);
}
```

**实例4：**
>计算Func4的时间复杂度？

- 这里可以看到k循环了100次，那么他是`O(100)`吗？【不是！】是`O(1)`

**注意：** `O(1)`并不是代表一次，而是常数次！

```c
void Func4(int N)
{
	int count = 0;
	for (int k = 0; k < 100; ++k)
	{
		++count;
	}
	printf("%d\n", count);
}
```
---
**小结一下：**

- 大O阶的方法：
	- 用常数1取代运行时间中的所有加法常数
	- 在修改后的运行次数函数中，只保留最高阶项，取决定性的那一项
	- 如果最高阶项存在且系数是不唯1的常系数，则去除最高项的系数，得到的结果就是大O阶
	- 如果最终结果是O(1)，则表示常数次，并不是代表一次
	- 还有就是没有小o阶~~
---
**实例5：**
>计算strchr的时间复杂度？
```c
const char* strchr(const char* str, int character);
```

```c
while (*str) {
	if (*str == character)
		return str;
	++str;
}
```
- 这个函数有可能有的同学没有见过，这是C语言库里面的一个函数[strchr](https://legacy.cplusplus.com/reference/cstring/strchr/?kw=strchr)，是定位字符串中出现的第一个字符
- 可能在前面的位置找到了（最好），肯在中间的位置找到了（平均），还有肯在最后的位置找到了（最坏）
![在这里插入图片描述](https://img-blog.csdnimg.cn/7f140db3a0b2469480e87d0180ae5903.png)

 **小结一下：**
- **最坏情况：**
	- 任意输入规模的最大运行次数（上界）
- **平均情况：**
	- 任意输入规模的期望运行次数
- **最好情况：**
	- 任意输入规模的最小运行次数（下界）
	- 一般我们比较关心的是一个算法的最坏情况

- 如果有最好，最坏，平均，那么时间复杂度是一个保守的估算，是取`最坏`，这是最好的！！！


**实例6：**
>计算BubbleSort的时间复杂度？
- 很多同学一眼看他是`O(N^2)`，那么他是`O(N^2)`吗？接下来接着看
```c
void BubbleSort(int* a, int n)
{
	assert(a);
	for (size_t end = n; end > 0; --end)
	{
		int exchange = 0;
		for (size_t i = 1; i < end; ++i)
		{
			if (a[i - 1] > a[i])
			{
				Swap(&a[i - 1], &a[i]);
				exchange = 1;
			}
		}
		if (exchange == 0)
			break;
	}
}
```

- 再来看一个，这个相比上一个的时间复杂度是什么？
- 可能有点同学一看这个循环有两层那么他是`O(N^2)`,它是`O(N^2)`吗？-->继续接着往下看！



```c
int PartSort1(int* a, int left, int right) {
	int keyi = left;
	while (left < right) {
		while (left < right && a[right] >= a[keyi]) {
			--right;
		}
		while (left < right && a[left <= a[keyi]]) {
			++left;
		}
		Swap(&a[left], &a[right]);
	}
	Swap(&a[left], &a[right]);
}
```
我们上面都是看的循环，但是我们要看思想，不能只看循环，第一个是-->`O(N^2)`第二个是`O(N)`


你算对了吗？
- 首先我们先看第一个冒泡排序的时间复杂度，如图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/0d11ddc353a346a6a34d78494c2ac2fe.png)

- 再来看第二个 `PartSort1`，当`left`和`right`相遇时，时间复杂度是`O(N)`

![在这里插入图片描述](https://img-blog.csdnimg.cn/6c30c9d280d54a86a41b02a3777ae654.png)
**小结一下：**
- 时间复杂度不能数代码中的循环
- 而是需要根据思想进行灵活计算！！！
----






**实例7：**
计算BinarySearch的时间复杂度？
- 这里一眼看就是一个二分查找~~
- 我们这里的是不是复杂度数`O(N)`?
```c
int BinarySearch(int* a, int n, int x)
{
	assert(a);
	int begin = 0;
	int end = n - 1;
	// [begin, end]：begin和end是左闭右闭区间，因此有=号
	while (begin <= end)
	{
		int mid = begin + ((end - begin) >> 1);
		if (a[mid] < x)
			begin = mid + 1;
		else if (a[mid] > x)
			end = mid - 1;
		else
			return mid;
	}
	return -1;
}
```

- 首先先说结论，这里是`O(logN)`，我们这里看代码是看不出来的，要看思想~~
- 首先二分查找的前提是`有序`

![在这里插入图片描述](https://img-blog.csdnimg.cn/e4715aaaf35b438c8a519d261c70fcac.png)



- 这个数组假设有n个值 
- n/2/2/.../2 = 1（最坏的情况~~）

- 我们这里除了多少个2？`找了多少次就除了多少个2`
- 假设找了x次-->`2^x = N` --> `x = logN`
				![在这里插入图片描述](https://img-blog.csdnimg.cn/f138cd028a6a4a75ba2f6c7724691946.png)
>我们这里的这个以2为底的logN是不是很不好写...我们平时就可以不写了~~，直接写成`O(logN)`
>但是有的书或者博客上面写成`O(lgN)`，我们不建议~~，和我们数学里面是有些混淆的

------

>学了复杂度我们要指定`O(logN)`是一个很腻害的算法我们下面进行对照~~
- 这里对应的有暴力查找（数组过一遍查找）：`O(N)`
- 二分查找：`O(logN)`

**比如：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/d02f75ff85904f23a3e68382a7b1bff2.png)

- 如果我把中国所有人的信息放到一个数组中，我们要找多少次？

>我们就只需要找`31次`，是不是很厉害~~

- 我们这里前提是要有序，有序是要有代价的，需要排序，如果有一个新生儿出生了，就要插入，如果有人离世了，就要删除了，这就很难~~
- 这里有更好的数据结构，有：AVL树，红黑树，哈希表，这些我们后面都会讲解~~

**实例8：**
>计算阶乘递归Fac的时间复杂度？

- 首先来看这是一个阶乘，很多同学肯一看是`O(1)`，又不太敢确认
- 我们先说结论--->`O(N)`

```c
long long Fac(size_t N)
{
	if (0 == N)
		return 1;

	return Fac(N - 1) * N;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/207131df3e4848278b27b5620015319f.png)

- 阶乘是不是有多次函数的调用，每次调用是常数次`O(N)`，有N次调用就是`O(N)`~~

>我们再来变一下形~~，我们来看下面，这个的时间复杂度是多少呢？
- 我们先说结果-->`O(N^2)`，然后我们进行分析~~
- 
```c
long long Fac(size_t N)
{
	if (0 == N)
		return 1;
	for (size_t i = 0; i < N; ++i)
	{
		//....
	}
	return Fac(N - 1) * N;
}
```
- 这里是咋算的？
- 每次递归走了一次循环，递归计算的是多次调用累加，多少次调用？N次调用，每次调用多少趟？这不是N，每次都在变化，当N为10时，循环走10次，当N是9时，循环走9次
- 递归次数累加是一个等差数列 `（0~N）的等差数列`
- 所以就是`O(N^2)`~~



**实例9：**
>计算斐波那契递归Fib的时间复杂度？

- 斐波那契数列类似于细胞分裂，一个分裂成两个，两个分裂成4个....
```c
long long Fib(size_t N)
{
	if (N < 3)
		return 1;

	return Fib(N - 1) + Fib(N - 2);
}
```
- 这里仔细看，这是一个等比数列和~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/6e744764e643473bab7ff14e46663c8a.png)

- 这里可以用到错位相减法，如图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2db06a78650f463bab9654fb67e82559.png)

- 根据大O渐进表示法，时间复杂度也就是`O(2^N)`，这是一个成指数增长的~~

## 5.空间复杂度

- 空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时`额外`占用存储空间大小的量度。空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以`空间复杂度算的是变量的个数`。
- 空间复杂度计算规则基本跟实践复杂度类似，也使用大O渐进表示法。
- **注意：** 函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。

**案例1：**
>计算BubbleSort的空间复杂度？
- 这里的这个空间复杂度是多少？--->>`O(N)`还是`O(1)`
```c
void BubbleSort(int* a, int n)
{
	assert(a);
	for (size_t end = n; end > 0; --end)
	{
		int exchange = 0;
		for (size_t i = 1; i < end; ++i)
		{
			if (a[i - 1] > a[i])
			{
				Swap(&a[i - 1], &a[i]);
				exchange = 1;
			}
		}
		if (exchange == 0)
			break;
	}
}
```

- 我们在上面说过`空间复杂度算的是变量的个数`，对一个算法在运行过程中临时`额外`占用存储空间，有没有开辟临时的空间？有！
- 它们都是常数个，所以就是`O(1)`

>下面这种算法是经典的`O(N)`

**案例2：**
>计算Fibonacci的空间复杂度？

```c
long long* Fibonacci(size_t n)
{
	if (n == 0)
		return NULL;
	long long* fibArray = (long long*)malloc((n + 1) * sizeof(long long));
	fibArray[0] = 0;
	fibArray[1] = 1;
	for (int i = 2; i <= n; ++i)
	{
		fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
	}
	return fibArray;
}
```
- 这里我们`malloc`了·n+1·个空间
- 其他的都忽略掉，所以就是O(N)


**案例3：**

>计算阶乘递归Fac的空间复杂度？
```c
long long Fac(size_t N)
{
	if (N == 0)
		return 1;
	return Fac(N - 1) * N;
}
```
- 这里递归空间复杂度计算，也是空间累加，但是不同的是空间可以重复利用
- 所以这里就是`O(N)`
----

## 6.复杂度的oj练习
### 6.1 消失的数字
[OJ链接](https://leetcode-cn.com/problems/missing-number-lcci/)

- 这里题目要求在时间复杂度上`O(n)`我们介绍三种方法，看看哪种方法适合这道题~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/1bbc824e17154b18b105744b49ff1089.png)

---
**方法一：**
1. 先冒泡排序
2. 遍历，当前值+1，不等于下一个数
>这个时间复杂度是`O(N^2)`
---
**方法二：**
1. 将数组的每个元素异或0
2. 遍历，再将异或出来的结果每个再异或
>这个时间复杂度是`O(N)`
-------
**方法三：**
1. 0到n等差数列公式计算和`((首项 + 尾项) * 项数)/2`
2. 依次减掉数据中的值，剩下的就是消失的数字
>这个时间复杂度是`O(N)`

----

- 可见只有方法二和方法三符合题目要求，下面我们就写一下这个代码

**方法二的代码：**

```c
int missingNumber(int* nums, int numsSize){
    int N = numsSize;
    int sum = ((0+N)*(N+1))/2;
    for(int i= 0;i<numsSize;i++){
        sum-=nums[i];
    }
    return sum;
}
```
**方法三的代码：**

```c
int missingNumber(int* nums, int numsSize){
    int x = 0;
    for(int i = 0;i<numsSize;i++){
        x^=nums[i];
    }
    for(int i = 0;i<=numsSize;i++){
        x^=i;
    }
    return x;
}
```

### 6.2 旋转数组

[OJ链接](https://leetcode-cn.com/problems/rotate-array/)

![在这里插入图片描述](https://img-blog.csdnimg.cn/e6df1bca610d468db15ec9f75e67afd2.png)

- 我们这个题肯有些同学在C语言的时候做过


>我们先来看思路一：

![在这里插入图片描述](https://img-blog.csdnimg.cn/935f9e7392094d3e8b08bbc01b315818.png)

- 思路一的时间复杂度是多少？
	- 可能有的同学算出来的是`O(N*K)`，不完全正确~~
- 最好的情况：k % N = 0，k = 7，旋转0次！！！是`O(1)`。k是N的倍数时，不需要旋转~~
- 最坏的情况：k % N = N - 1时，比如13次旋转的最多，20次最多.....
- 所以这个题的真正复杂度是`O（N*(N-1)）`--->`O(N^2)` 
>那么我们要求时间复杂度是`O(N)`，那么我们怎么优化呢？
------
>我们这里就要看思路二：

![在这里插入图片描述](https://img-blog.csdnimg.cn/800ef510ff554726907bfcfeea2f834d.png)

- 这里很明显是`O(N)`

代码如下：

```c
void reverse(int* nums,int left,int right){
    while(left<right){
        int tmp = nums[left];
        nums[left] = nums[right];
        nums[right] = tmp;
        left++;
        right--;
    }
}
void rotate(int* nums, int numsSize, int k){
    if(k>numsSize){
        k %=numsSize;
    }
    reverse(nums,0,numsSize-1);
    reverse(nums,0,k-1);
    reverse(nums,k,numsSize-1);
}
```
- 注意这里k一定要%numsSize，否则会报错~~

----
**思路三：**

>空间换时间

![在这里插入图片描述](https://img-blog.csdnimg.cn/2568f4ac16a347bfbe34e027f82de9a6.png)


- 这里的时间复杂是`O(N)`，空间复杂度是`O(N)`

代码如下：

```c
void rotate(int* nums, int numsSize, int k) {
	k %= numsSize;
	int tmp[numsSize];
	int j = k;
	//拷贝前n-k个
	for (int i = 0; i < numsSize - k; i++) {
		tmp[j++] = nums[i];
	}
	//拷贝后k个
	j = 0;
	for (int i = numsSize - k; i < numsSize; i++) {
		tmp[j++] = nums[i];
	}
	//拷贝回原数组
	for (int i = 0; i < numsSize; i++) {
		nums[i] = tmp[i];
	}
}
```

