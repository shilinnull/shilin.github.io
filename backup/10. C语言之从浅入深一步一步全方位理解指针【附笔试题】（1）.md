
  - 二楼：201，202，203....


有了房间号，如果你的朋友得到房间号，就可以快速的找房间，找到你。


![在这里插入图片描述](https://img-blog.csdnimg.cn/eb9980f8121d48c68088d64876befc75.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/02799af6ad31469096274b0560943801.png)


- 生活中，每个房间有了房间号，就能提高效率，能快速的找到房间。

如果把上面的例子对照到计算中，又是怎么样呢？


- 我们知道计算上CPU（中央处理器）在处理数据的时候，需要的数据是在内存中读取的，处理后的数据也会放回内存中，那我们买电脑的时候，电脑上内存是8GB/16GB/32GB等，那这些内存空间如何高效的管理呢？

其实也是把内存划分为一个个的内存单元，每个内存单元的大小取1个字节。

- 计算机中常见的单位（补充）：
- 一个比特位可以存储一个2进制的位1或者0

```c
bit - 比特位
byte - 字节
KB
MB
GB
TB
PB
```

```c
1byte = 8bit
1KB = 1024byte
1MB = 1024KB
1GB = 1024MB
1TB = 1024GB
1PB = 1024TB
```
- 其中，每个内存单元，相当于一个学生宿舍，一个人字节空间里面能放8个比特位，就好比同学们住的八人间，每个人是一个比特位。
- 每个内存单元也都有一个编号（这个编号就相当于宿舍房间的门牌号），有了这个内存单元的编号，CPU就可以快速找到一个内存空间。
- 生活中我们把门牌号也叫地址，在计算机中我们把内存单元的编号也称为地址。C语言中给地址起了新的名字叫：**指针**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/cb3be99a936345089c5a5a75f9e02790.png)

- 所以我们可以理解为：内存单元的编号 == 地址 == 指针

### 1.2 究竟该如何理解编址

- CPU访问内存中的某个字节空间，必须知道这个字节空间在内存的什么位置，而因为内存中字节很多，所以需要给内存进行编址(就如同宿舍很多，需要给宿舍编号一样)。
- 计算机中的编址，并不是把每个字节的地址记录下来，而是通过硬件设计完成的。钢琴、吉他面没有写上“都瑞咪发嗦啦”这样的信息，但演奏者照样能够准确找到每一个琴弦的每一个位置，这是为何？因为制造商已经在乐器硬件层面上设计好了，并且所有的演奏者都知道。本质是一种约定出来的共识！硬件编址也是如此~~

----

- 首先，必须理解，计算机内是有很多的硬件单元，而硬件单元是要互相协同工作的。所谓的协同，至少相互之间要能够进行数据传递。但是硬件与硬件之间是互相独立的，那么如何通信呢？答案很简单，用"线"连起来。而CPU和内存之间也是有大量的数据交互的，所以，两者必须也用线连起来。不过，我们今天关心一组线，叫做地址总线。


![在这里插入图片描述](https://img-blog.csdnimg.cn/e6a2396ff44141968d9bb5c339a6e79b.png)

- 我们可以简单理解，32位机器有32根地址总线，每根线只有两态，表示0,1【电脉冲有无】，那么一根线，就能表示2种含义，2根线就能表示4种含义，依次类推。32根地址线，就能表示2^32种含义，每一种含义都代表一个地址。地址信息被下达给内存，在内存上，就可以找到该地址对应的数据，将数据在通过数据总线传入CPU内寄存器。
------



## 二、指针变量和地址

### 2.1 取地址操作符（&）

理解了内存和地址的关系，我们再回到C语言，在C语言中创建变量其实就是向内存申请空间，比如：

- 下面这段代码变量创建的本质是什么？
```c
int main() 
{
	int a = 10;
	return 0;
}
```

- 变量创建的本质是：在内存上开辟空间~~
要向内存申请4个字节的空间，存放数据0

![在这里插入图片描述](https://img-blog.csdnimg.cn/bce88ee63cb64175b58a1c0f67a53c82.png)
- 比如，上述的代码就是创建了整型变量a，内存中申请4个字节，用于存放整数10，其中每个字节都有地址，上图中4个字节的地址分别是：

```c
0x005FFC54  0a  
0x005FFC55  00  
0x005FFC56  00  
0x005FFC57  00  
```
那我们如何能得到a的地址呢？
- 这里就得学习一个操作符(&)-取地址操作符

```c
#include <stdio.h>
int main() {
	int a = 10;
	&a;//取出a的地址
	printf("%p\n", &a);
	return 0;
}
```
- 对于a来说，我们那到的是a所占4个字节的第一个地址（地址较小的那个字节的地址）

按照我画图的例子，会打印处理：`005FFC54`

![在这里插入图片描述](https://img-blog.csdnimg.cn/e23b808866e44ca3a9e1ca5e81e5402a.png)

- 虽然整型变量占用4个字节，我们只要知道了第一个字节地址，顺藤摸瓜访问到4个字节的数据也是可
行的。

## 三、指针变量和解引用操作符（*）
### 3.1 指针变量


- 那我们通过取地址操作符(&)拿到的地址是一个数值，比如：0x006FFD70，这个数值有时候也是需要存储起来，方便后期再使用的，那我们把这样的地址值存放在哪里呢？答案是：`指针变量`中。

- 比如：

```c
int main() {
	int a = 10;
	int* pa = &a;//取出a的地址并存储到指针变量pa中
	return 0;
}
```
- 其中pa叫做指针变量~~，因为是存放指针的变量，所以叫做指针变量
- 指针变量也是一种变量，这种变量就是用来存放地址的，存放在指针变量中的值都会理解为地址。

### 3.2 如何拆解指针类型

- 我们看到pa的类型是`int*` ，我们该如何理解指针的类型呢？


```c
int a = 10;
int* pa = &a;
```
- 这里pa左边写的是`int*`，`*`是在说明pa是指针变量，而前面的`int`是在说明pa指向的是整型(int)类型的对象。


![在这里插入图片描述](https://img-blog.csdnimg.cn/fee29bfed2304ab5b4bd573747e870e5.png)
- 那如果有一个char类型的变量ch，ch的地址，要放在什么类型的指针变量中呢？

```c
char ch = 'w';
pc = &ch;//pc 的类型怎么写呢？
```
- 既然是char类型的变量，那肯定就要放在char类型的指针变量里~~

```c
char ch = 'w';
char* pc = &ch;
```

### 3.3 解引用操作符


- 我们将地址保存起来，未来是要使用的，那怎么使用呢？
在现实生活中，我们使用地址要找到一个房间，在房间里可以拿去或者存放物品。

- C语言中其实也是一样的，我们只要拿到了地址（指针），就可以通过地址（指针）找到地址（指针）指向的对象，这里必须学习一个操作符叫解引用操作符(*)。


```c
#include <stdio.h>

int main()
{
	int a = 100;
	int* pa = &a;
	*pa = 0;
	return 0;
}
```

- 上面代码中第7行就使用了解引用操作符， *pa 的意思就是通过pa中存放的地址，找到指向的空间，*pa其实就是a变量了；所以*pa = 0，这个操作符是把a改成了0.有同学肯定在想，这里如果目的就是把a改成0的话，写成a = 0; 不就完了，为啥非要使用指针呢？
- 其实这里是把a的修改交给了pa来操作，这样对a的修改，就多了一种的途径，写代码就会更加灵活，后期慢慢就能理解了。


## 四、指针变量的大小

- 前面的内容我们了解到，32位机器假设有32根地址总线，每根地址线出来的电信号转换成数字信号后是1或者0，那我们把32根地址线产生的2进制序列当做一个地址，那么一个地址就是32个bit位，需要4个字节才能存储。
- 如果指针变量是用来存放地址的，那么指针变的大小就得是4个字节的空间才可以。
- 同理64位机器，假设有64根地址线，一个地址就是64个二进制位组成的二进制序列，存储起来就需要
- 8个字节的空间，指针变的大小就是8个字节。

----

- 接下来我们再看看下面这个~~

```c
int main()
{
	int num = 10;
	int* p = &num;
	
	char ch = 'w';
	char* pc = &ch;

	printf("%zd\n", sizeof(p));
	printf("%zd\n", sizeof(pc));
	return 0;
}
```
- 我们这里是x86环境下，猜猜这里这个`p`和`pc`的大小是多少？p是4个字节？pc是1个字节？


  ![在这里插入图片描述](https://img-blog.csdnimg.cn/b9ef29047eea40cd9bdf8477402e73e3.png)

- 可以看到，都是4个字节，指针变量的大小是固定的，不要以为`char*`类型的就小，看不起`char*`类型的指针~~
>x86环境下为什么`char*`的指针变量和`int*`的指针变量都是4个字节呢？
- 指针变量是干什么呢?是为了存放地址的
- 那指针变量的大小是取决于存放一个地址需要多大的空间！！！
- 地址都是32个0/1组成的二进制序列的话，那么存放这个地址需要的空间的大小就是4个字节，所以指针变量的大小都是4个字节~~
- 同样x64环境，64根地址线，地址就是64个0/1组成的二进制序列，存放这样的地址，需要8个字节，所以指针变量的大小就是8个字节~~

- 如果不相信，我们在VS中试一下~~

```c
#include <stdio.h>
//指针变量的大小取决于地址的大小
//32位平台下地址是32个bit位（即4个字节）
//64位平台下地址是64个bit位（即8个字节）
int main()
{
	printf("%zd\n", sizeof(char*));
	printf("%zd\n", sizeof(short*));
	printf("%zd\n", sizeof(int*));
	printf("%zd\n", sizeof(double*));
	return 0;
}
```

- **32位下：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/e3576b8e7ef1485a91200e41e9a1b2a8.png)
- **64位下：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/99926bb9965f4c3baa6a6a5722290dd4.png)

- 俗话说，不要在门缝里看人，把人看扁了
- 今天，我要告诉你，不要在门缝里看指针，把`指针`看扁了~~

**结论：**
- 32位平台下地址是32个bit位，指针变量大小是4个字节
- 64位平台下地址是64个bit位，指针变量大小是8个字节
- 注意指针变量的大小和类型是无关的，只要指针类型的变量，在相同的平台下，大小都是相同的。

### 4.1 指针变量类型的意义
- 指针变量的大小和类型无关，只要是指针变量，在同一个平台下，大小都是一样的，为什么还要有各种各样的指针类型呢？

- 其实指针类型是有特殊意义的，我们接下来继续学习~~


### 4.2 指针的解引用
- 我们来看下面的两段代码，通过调试来进行分析，观察内存的变化~~

**代码一：**
```c
#include <stdio.h>
int main()
{
	int n = 0x11223344;
	int* pi = &n;
	*pi = 0;
	return 0;
}
```
**代码二：**

```c
#include <stdio.h>
int main()
{
	int n = 0x11223344;
	char* pc = &n;
	*pc = 0;
	return 0;
}
```

- 我们按键盘上的`F10`，如果有的同学是笔记本，就在笔记本上按`Fn+F10`，开始调试
- 打开调试->窗口->内存->

![在这里插入图片描述](https://img-blog.csdnimg.cn/b8fe25506fa54a339fdca8235e981fe6.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/f7b3924ded0b43deb0baf38ee0cab1f5.png)



![在这里插入图片描述](https://img-blog.csdnimg.cn/651d156a6bdd4dd3bf83b32712fd29eb.png)


- 这个时候我们发现，怎么是倒着存的？不应该是正的存吗，这里就要涉及到一个概念，`大小端存储`

我们回归正题：

- 我们把这个n的地址取出来放到pi变量里，然后解引用，把n的值改为0，我们可以看一下~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/18cf0e2399d743e68f54080a26af91cc.png)

- 可以看到，4个字节全部改为了0~~

----

>现在再来看第二个代码~~

- 我们可以看到我将n的地址放到`char*`类型的变量里，那能不能放的下？
- 答案是能！！！刚刚就说过，指针变量都是4个字节，为什么放不下~~
- 然后我们继续看，`*pc = 0`，我们这个是修改的几个字节?

![在这里插入图片描述](https://img-blog.csdnimg.cn/a0243ea409c1469bb1eaa5d63edc6c8b.png)

- 我们可以看到，它只修改了一个字节，因为是`char*`的指针变量


**结论：**

1. 指针类型是有意义的
2. 指针类型是决定了指针在解引用操作时的权限，也就是一次解引用访问几个字节，`char*`类型的指针解引用访问1个字节，`int*`类型的指针一次访问4个字节

----

### 4.3 指针+-整数

- 我们先来看下面这一段代码~~

```c
#include <stdio.h>
int main()
{
	int n = 0x11223344;
	int* p = &n;
	char* pc = &n;

	printf("p = %p\n", p);
	printf("p + 1 = %p\n", p + 1);

	printf("pc = %p\n", pc);
	printf("pc + 1 = %p\n", pc + 1);
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/7c09a70c2f7243048ed9bfc75f5cc4f6.png)

- 我们可以看出， `char*` 类型的指针变量`+1`跳过1个字节， `int*` 类型的指针变量`+1`跳过了4个字节。
- 这就是指针变量的类型差异带来的变化。

**结论：**

1. 指针类型是有意义的
2. 指针类型决定了指针进行+1/-1操作的时候一次跳过几个字节
3. 指针的类型决定了指针向前或者向后走一步有多大（距离）。

----
那有的同学会问，指针类型这些特点，怎么是使用呢？

- 我们之前一个数组是用数组的下标来访问的，今天我们就用指针的方式访问~~

>我们先来回忆一下数组的方式~~

```c
int main() {
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	//下标的方式
	int sz = sizeof(arr) / sizeof(arr[0]);
	int i = 0;
	for (i = 0; i < sz; i++) {
		printf("%d ", arr[i]);
	}
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/baa8802f84304771bac052f9d64f155b.png)
- 可以看到，我们已经将数组中的元素已经打印出来了~~
>我们再用指针的方式来访问~~

- 我们将arr[0]的地址放入了指针p中，然后再通过`for`循环中`*p`找到arr每个的元素，那找到一个元素，还想找下一个元素怎么办？那就要加1，因为p是整形指针，`+1`跳过4个字节，正好找到下一个元素
```c
int main() {
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	//下标的方式
	int sz = sizeof(arr) / sizeof(arr[0]);
	//int i = 0;
	//for (i = 0; i < sz; i++) {
	//	printf("%d ", arr[i]);
	//}

	//指针的方式
	int i = 0;
	int* p = &arr[0];
	for (i = 0; i < sz; i++) {
		printf("%d ", *p);
		p = p + 1;
	}
	return 0;
}
```

- 我们可以看到，也全部访问到了~~

![](https://img-blog.csdnimg.cn/4bd670d0971745f781d8efac754dc0cb.png)
- 那有的同学回说，我不想另外让`p+1`，我直接`*(p+i)`，这样可以吗？当然可以！！！

```c
int main() {
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	//指针的方式
	int i = 0;
	int* p = &arr[0];
	for (i = 0; i < sz; i++) {
		printf("%d ", *(p + i));
	}
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/1a5199f674d74fe7ba36cebf51134f77.png)
- 如果不懂的话，我们进行画图理解
![在这里插入图片描述](https://img-blog.csdnimg.cn/a4530b9e01e543e28839e8e4cf319505.png)

>相信看完了上面，你对指针类型有一个对应理解~~

## 五、const修饰指针

- 变量是可以修改的，如果把变量的地址交给一个指针变量，通过指针变量的也可以修改这个变量。

```c
#include<stdio.h>
int main() {
	int n = 100;
	n = 200;

	printf("%d\n", n);
	return 0;
}
```

- 但是如果我们希望一个变量加上一些限制，不能被修改，怎么做呢？这就是const的作用。


```c
int main() {
	const int n = 100;
	n = 200;//err

	printf("%d\n", n);
	return 0;
}
```



![在这里插入图片描述](https://img-blog.csdnimg.cn/9aae2e2234504a6c8e186beea96d24d6.png)
- 上述代码中n是不能被修改的，其实n本质是变量，只不过被const修饰后，在语法上加了限制，只要我们在代码中对n就行修改，就不符合语法规则，就报错，致使没法直接修改n。
- 但是如果我们绕过n，使用n的地址，去修改n就能做到了，虽然这样做是在打破语法规则。
- 那有人这样想，这样不能修改，那我绕个弯，把n的地址取出来，交给一个指针变量p，然后进行修改~~

```c
int main() {
	const int n = 100;
	int* p = &n;
	*p = 200;

	printf("%d\n", n);
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/9fae31bcd2094354b4414ec02a706cac.png)


- 哎！它怎么修改了？就比如说有个门，门锁上了，看见有个窗户，我从窗户进去了，这个行为就是钻窗户行为~~
- 这里一个确实修改了，但是我们还是要思考一下，为什么`n`要被`const`修饰呢？就是为了不能被修改，如果`p`拿到`n`的地址就能修改`n`，这样就打破了`const`的限制，这是不合理的，所以应该让p拿到n的地址也不能修改n，那接下来怎么做呢？


###  5.1 const修饰指针变量

**const修饰指针有两种情况：**
1. const放在`*`的左边
2. const放在`*`的右边

- 首先我们先将`const`放在`*`的左边~~
```c
int main() {
	int m = 100;
	int n = 10;

	const int* p = &n;
	*p = 0;

	p = &m;

	printf("%d\n", n);
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/6bb7b7e93be740dab0807deeb4d05841.png)
- 这里可以看到`p`指向的值不能被修改
- p变量还是可以被修改的~~
----
- 然后我们先将`const`放在`*`的左边~~

```c
int main() {
	int m = 100;
	int n = 10;

	int* const p = &n;
	*p = 0;

	p = &m;

	printf("%d\n", n);
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/626753f675f5450185e1c08c09b16634.png)
- 可以看到p指向的对象可以被修改~~

**结论：**
1. `cons`t如果放在`*`的左边，修饰的是指针指向的内容，保证指针指向的内容不能通过指针来改变。但是指针变量本身的内容可变。
2. `const`如果放在`*`的右边，修饰的是指针变量本身，保证了指针变量的内容不能修改，但是指针指向的内容，可以通过指针改变。


----

- 那有的同学说我这样放，可不可以？可以！！！

```c
int const *  p = &n;
```

```c
int *const  p = &n;
```
- 这两种方法都是可以的，我们只是关注的是`const`放在`*`左边还是右边

## 六、指针运算

### 6.1 指针+- 整数

- 因为数组在内存中是连续存放的，只要知道第一个元素的地址，顺藤摸瓜就能找到后面的所有元素。

```c
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/da78d0276c5e41f7ac4bb41c8febc253.png)


```c
#include <stdio.h>
//指针+- 整数
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = &arr[0];
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	for (i = 0; i < sz; i++)
	{
		printf("%d ", *(p + i));//p+i 这里就是指针+整数
	}
	return 0;
}
```
- 接下来我们就调试起来看一看

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/45d620581cf0497b98370e41f42b4092.png)


- 可以看到已经放进去了


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f000eeb774e040d68924a6d37eb73d9e.png)


- 这里`p+i`就访问到每一个元素了~~

### 6.2 指针-指针

- 指针-指针是有前提的，指针和指针两个指针的指向同一块空间
- 我们先来看下面的这个一个代码，输出的结果是多少？

```c
int main() {
	int arr[10] = { 0 };
	int ret = &arr[9] - &arr[0];

	printf("%d", ret);

	return 0;
 }
```
- 答案是9~~，我们来分析一下：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/79979b1657ce442ab966c985491fdd6b.png)


- 也可以这样理解，`&arr[0]+9`--->>>`&arr[9]`

- **结论：** 指针-指针得到的绝对值，是指针和指针之间元素的个数

----

那这个有什么用呢？还记得有一个函数`strlen`吗？

- `strlen`的功能是求字符串长度，如果有同学不了解这个函数的话可以去[cplusplus](https://legacy.cplusplus.com/reference/cstring/strlen/?kw=strlen)网站上看一下
- 我们来看一下怎么使用

```c
int main() 
{
	char arr[] = "abcdef";
	int len = strlen(arr);

	printf("%d\n", len);
	return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bd74d2f7287a4f04b2f12acee49d0131.png)


- 可以看到它已经求出字符串长度了~~
- 我们知道字符串的结束标志是`\0`，让我求长度，我就统计`\0`之前出现字符的个数
------
- 那我们现在自己模拟实现一下这个函数~~
- 我们这里写成`my_strlen`，我们把数组传参，然后形参以指针接收，指针指向了数组首元素的地址，然后我们定义个计数器count，如果`p!=\0`,`count++`，`p++`，最后返回count的个数~~


```c
int my_strlen(char* p)
{
	int count = 0;
	while (*p != '\0')
	{
		count++;
		p++;
	}
	return count;
}


int main() 
{
	char arr[] = "abcdef";
	int len = my_strlen(arr);

	printf("%d\n", len);
	return 0;
}
```
- 可以看到也统计出来个数了~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/00e27f16206f4ef6ba1808528c28b980.png)


-----
- 我们再写出另一个版本，接下来继续看~~
- 我们知道指针减去指针得到的是元素之间的个数
- 首先我记录一下起始位置，让`p++`，一直找到`\0`为止，最后返回p-s就得到了元素的个数~~
- 我们来看一下代码和结果~~

```c
#include <stdio.h>
int my_strlen(char* s)
{
	char* p = s;
	while (*p != '\0')
		p++;
	return p - s;
}
int main()
{
	printf("%d\n", my_strlen("abc"));
	return 0;
}
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7796bae9ee55483e9de62f0788acbb69.png)




>明白了上面的内容，我们再来将一个指针的关系运算~~

----

### 6.3 指针的关系运算

- 所谓的关系运算，就是比较大小
- 我们来看一下例子~~

```c
#include <stdio.h>
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = &arr[0];
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	while (p < arr + sz) //指针的大小比较
	{
		printf("%d ", *p);
		p++;
	}
	return 0;
}
```
- 这里我们比较的是两个地址的大小关系~~
- 我们可以看到，也是可以打印出来的~~


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/229a97aecdde460e85d83fed68713d0a.png)

## 七、野指针

- **概念：**  野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

### 7.1 野指针成因
**指针未初始化：**

```c
#include <stdio.h>
int main()
{
	int* p;//局部变量指针未初始化，默认为随机值
	*p = 20;
	return 0;
}
```




![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f2129fd524c0461480f722a78500d014.png)


- 可以看到这里报了错，局部变量不初始化默认里面放的是`cccccccc`
- 所以一个局部变量不初始化的话，会得到一个随机值~~
- 而随便的一个地址，能解引用吗？`不能！！！`
- 一块空间你要想使用，你需要先申请拿到这块空间

------
**指针越界访问：**

- 我们先来看代码

```c
#include <stdio.h>
int main()
{
	int arr[10] = { 0 };
	int* p = &arr[0];
	int i = 0;
	for (i = 0; i <= 11; i++)
	{
		//当指针指向的范围超出数组arr的范围时，p就是野指针
		*(p++) = i;
	}
	return 0;
}
```
- 我们这里的`p++`是先执行的，而`p++`是先使用后`++`
- 我们这里可以看到，我把`arr[0]`的地址放入了`*p`指针变量，然后我们进行遍历赋值，那我们这里判断条件是不是就越界访问了，超出了数组的范围，当指针指向的范围超出数组`arr`的范围时，p就是野指针，这是很危险的


- 我们这里还可以调试一下看看


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fec45f1686bd45249730606193306680.png)


- 可以看到，数组`arr`造到了破坏，而越界访问的内容也修改了，如此可见，这多么的危险！！！


-----


### 7.2 指针指向的空间释放

- 我们先来看一下下面的代码~~

```c
#include <stdio.h>
int* test()
{
	int n = 100;
	return &n;
}
int main()
{
	int* p = test();
	printf("%d\n", *p);
	return 0;
}
```

- 这里创建了一个函数`test()`，返回一个地址，既然这个函数返回的是一个地址，那我用一个指针来接收，然后`*p`这个地址
- 这个`n`在出这个函数的时候被销毁了，这就会造成指针指向的空间释放~~


## 八、如何规避野指针

### 8.1 指针初始化
- 如果明确知道指针指向哪里就直接赋值地址
- 如果不知道指针应该指向哪里，可以给指针赋值`NULL`


>什么意思呢，我们用代码来说~~	

- 这里的p非常明确的指向了a，直接赋值~~
```c
int main() 
{
	int a = 10;
	int* p = &a;
	return 0;
}
```

- 我们这里假设在这里创建了个`ptr`，我现在不用，但我可以在后面才会用，但是这个指针变量不能空着，这个时候我们要给他初始化`NULL`

```c
int main() 
{
	int a = 10;
	int* p = &a;
	int* ptr = NULL;
	return 0;
}
```

- NULL是什么呢？本质上就是空指针，我们这个时候可以右键，转到定义里看一下

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4d58cc2aff5744fca5f4191c22c7657d.png)



- 那有的同学会说，那我直接给他赋值为0，可不可以呢？本质上是可以的，但是，当我们赋值为0了，有的时候会以为是一个整数，而我们赋值为`NULL`的时候，那就很明显了，一看就是空
- `NULL` 是C语言中定义的一个标识符常量，值是0，0也是地址，这个地址是无法使用的，读写该地址会报错。

- 这里我们也可以看到~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d7a4d635e4df4957bd4c115bb4e1ef6e.png)



### 8.2 小心指针越界

- 一个程序向内存申请了哪些空间，通过指针也就只能访问哪些空间，不能超出范围访问，超出了就是越界访问
- 这个谁都帮不了你，只能自己小心，不要越界~~
- 一个程序员想写bug，谁都拦不住~~
### 8.3 指针变量不再使用时，及时置NULL，指针使用之前检查有效性


- 当指针变量指向一块区域的时候，我们可以通过指针访问该区域，后期不再使用这个指针访问空间的时候，我们可以把该指针置为NULL。因为约定俗成的一个规则就是：只要是NULL指针就不去访问，同时使用指针之前可以判断指针是否为NULL。
- 我们可以把野指针想象成野狗，野狗放任不管是非常危险的，所以我们可以找一棵树把野狗拴起来，就相对安全了，给指针变量及时赋值为NULL，其实就类似把野狗栓前来，就是把野指针暂时管理起来。
- 不过野狗即使拴起来我们也要绕着走，不能去挑逗野狗，有点危险；对于指针也是，在使用之前，我们也要判断是否为NULL，看看是不是被拴起来起来的野狗，如果是不能直接使用，如果不是我们再去使用。


---
- 下面我们来看一段代码~~
- 这里我们创建了一个数组，然后用指针遍历这个数组，当遍历完后，指针已经指向了10的后面，指向了不属于我们的空间
- 假设暂时不再使用p了，为了安全，我们可以把p赋值为`NULL`
- 如果后面还会用到这个指针，我们再把这个p赋值，我们还可以再进行判断是否为`NULL`
```c
int main()
{
	int arr[10] = { 1,2,3,4,5,67,7,8,9,10 };
	int* p = &arr[0];
	for (int i = 0; i < 10; i++)
	{
		*(p++) = i;
	}
	//此时p已经越界了，可以把p置为NULL
	p = NULL;
	//下次使用的时候，判断p不为NULL的时候再使用
	//...
	p = &arr[0];//重新让p获得地址
	if (p != NULL) //判断
	{
		//...
	}
	return 0;
}
```

### 8.4 避免返回局部变量的地址

- 我们来看下面这一段代码
- 首先我们先调用了一下`test`函数，函数里创建了个数组，数组是局部变量，而我们返回了这个数组的地址，我们使用了一个指针变量`p`来接收，当`test`函数返回的时候局部变量已经被操作系统回收了，这就会造成野指针，如果有看过函数的栈帧的创建与销毁的话就明白了
- 返回栈空间地址的问题，很容易造成野指针的问题~~

```c
int* test()
{
	//局部变量
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//.....
	return arr;
}

int main()
{
	int* p = test();//p就是野指针
	return 0;
}
```

## 九、assert断言
- assert.h 头文件定义了宏assert() ，用于在运行时确保程序符合指定条件，如果不符合，就报错终止运行。这个宏常常被称为“断言”。

```c
assert(p != NULL);
```
---
- 上面代码在程序运行到这一行语句时，验证变量`p`是否等于`NULL` 。如果确实不等于NULL ，程序继续运行，否则就会终止运行，并且给出报错信息提示。
- 我们可以看到，什么都不会发生~~

```c
#include <assert.h>

int main()
{
	int a = 10;
	int* p = &a;
	assert(p != NULL);
	return 0;
}
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c1858bca9e0b4e00b9b03eb1b95697aa.png)

- 当我们赋值为了一个空指针时，可以看到会报错误
- 通过这样一个方式就可以拦住他~~


```c
#include <assert.h>

int main()
{
	int a = 10;
	int* p = NULL;
	assert(p != NULL);
	return 0;
}
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/460740e0fff04e54af730e6df46f3898.png)




- `assert()` 宏接受一个表达式作为参数。如果该表达式为真（返回值非零）， `assert()`不会产生任何作用，程序继续运行。如果该表达式为假（返回值为零）， `assert()` 就会报错，在标准错误流`stderr` 中写入一条错误信息，显示没有通过的表达式，以及包含这个表达式的文件名和行号。
- `assert()` 的使用对程序员是非常友好的，使用`assert()` 有几个好处：它不仅能自动标识文件和出问题的行号，还有一种无需更改代码就能开启或关闭assert() 的机制。如果已经确认程序没有问题，不需要再做断言，就在`#include <assert.h>` 语句的前面，定义一个宏`NDEBUG` 。

```c
#define NDEBUG
#include <assert.h>
```
- 然后，重新编译程序，编译器就会禁用文件中所有的`assert()` 语句。如果程序又出现问题，可以移除这条`#define NDBUG` 指令（或者把它注释掉），再次编译，这样就重新启用了`assert()` 语句。

- `assert()` 的缺点是，因为引入了额外的检查，增加了程序的运行时间。
- 一般我们可以在`debug`中使用，在`release`版本中选择禁用`assert`就行，在VS这样的集成开发环境中，在`release`版本中，直接就是优化掉了。这样在`debug`版本写有利于程序员排查问题，在`release`版本不影响用户使用时程序的效率。

## 十、指针的使用和传址调用
>一直叫传值调用，一种叫传址调用，接下来我们继续看~~
### 10.1 传址调用


- 学习指针的目的是使用指针解决问题，那什么问题，非指针不可呢？
例如：**写一个函数**，交换两个整型变量的值
- 一番思考后，我们可能写出这样的代码：

```c
#include <stdio.h>
void Swap1(int x, int y)
{
	int tmp = x;
	x = y;
	y = tmp;
}
int main()
{
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, &b);
	printf("交换前：a=%d b=%d\n", a, b);
	Swap1(a, b);
	printf("交换后：a=%d b=%d\n", a, b);
	return 0;
}
```

**当我们运行代码，结果如下：**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/af27aa3acff6424baae517a749fb4fa1.png)


- 这里怎么没有达到交换的效果？我们来调试看一下
- 我们可以看到只有x和y交换了，而a和b没有交换

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2737e43c434340d2814f9f5fb6ee82ee.png)


- 我们发现在main函数内部，创建了a和b，a的地址是`0x0039f9f0`，b的地址是`0x0039f9e4`，在调用`Swap1`函数时，将a和b传递给了`Swap1`函数，在`Swap1`函数内部创建了形参x和y接收a和b的值，但是x的地址是`0x0039f90c`，y的地址是`0x0039f910`，x和y确实接收到了a和b的值，不过x的地址和a的地址不一样，y的地址和b的地址不一样，相当于x和y是独立的空间，那么在`Swap1`函数内部交换x和y的值，自然不会影响a和b，当`Swap1`函数调用结束后回到`main`函数，a和b的没法交换。`Swap1`函数在使用的时候，是把变量本身直接传递给了函数，这种调用函数的方式我们之前在函数的时候就知道了，这种叫**传值调用**。

**结论：** 实参传递给形参的时候，形参会单独创建一份临时空间来接收实参，对形参的修改不影响实参。所以Swap是失败的了。

----

### 10.2 传址调用
- 那怎么办呢？
- 我们现在要解决的就是当调用Swap函数的时候，Swap函数内部操作的就是main函数中的a和b，直接将a和b的值交换了。那么就可以使用指针了，在main函数中将a和b的地址传递给Swap函数，Swap函数里边通过地址间接的操作main函数中的a和b就好了。

```c
#include <stdio.h>
void Swap2(int* px, int* py)
{
	int tmp = 0;
	tmp = *px;
	*px = *py;
	*py = tmp;
}
int main()
{
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, &b);
	printf("交换前：a=%d b=%d\n", a, b);
	Swap2(&a, &b);
	printf("交换后：a=%d b=%d\n", a, b);
	return 0;
}
```
**首先看输出结果：**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/88fa0905643b42c0b20a6be3c88b47b8.png)


- 我们可以看到实现成Swap2的方式，顺利完成了任务，这里调用Swap2函数的时候是将变量的地址传递给了函数，这种函数调用方式叫：**传址调用**。

## 十一、strlen的模拟实现

- 这个我们上面的指针的关系运算已经实现过了，这次我们再写的全一些~~
- 我们创建了一个字符数组，要求出这个字符串的长度，我们写一个`my_strlen()`
- 它传参传的是数组首元素的地址，我们用一个`*str`的指针来接收，我们这个函数期望这个字符串来修改吗？不期望，这里我们再加上一个`const`
- 这里我们需要断言`str`，确保指针的有效性
- 现在`str`指向`a`的，当`str!='\0'`，`str++`,计数器也++，最后返回计数器~~
- 求字符串的时候没有负数吧，我们就可以设置成`size_t`
- 现在软件更加健壮了，也叫鲁棒性~~

----
> 计数器方式
```c
size_t my_strlen(const char* str)
{
	size_t count = 0;
	assert(str);
	while (*str)
	{
		count++;
		str++;
	}
	return count;
}
int main()
{
	char arr[] = "abcdef";
	size_t len = my_strlen(arr);
	printf("%zd\n", len);
	return 0;
}
```
------
# 从浅入深理解指针《第二阶段》
-----
## 一、数组名的理解

- 在上面的内容我们在使用指针访问数组的内容时，有这样的代码：

```c
int arr[10] = {1,2,3,4,5,6,7,8,9,10};
int *p = &arr[0];
```
- 这里我们使用 `&arr[0] `的方式拿到了数组第一个元素的地址，但是其实数组名本来就是地址，而且是数组首元素的地址，我们来做个测试。

```c
#include <stdio.h>
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("&arr[0] = %p\n", &arr[0]);
	printf("arr = %p\n", arr);
	return 0;
}
```

- 我们发现数组名和数组首元素的地址打印出的结果一模一样
- 初步得出一个结论：**数组名就是数组首元素(第一个元素)的地址。**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9c09647f0a004250894143745fa72d3e.png)


- 这时候有同学会有疑问？数组名如果是数组首元素的地址，那下面的代码怎么理解呢？
- 这里的arr是不是首元素的地址？是的，如果这里的数组名代表首元素的地址的话，结果应该是`4`，那是不是呢？
- 当我真正的运行起来就可以发现，不是！！！
```c
#include <stdio.h>
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("%d\n", sizeof(arr));
	return 0;
}
```
- 输出的结果是：40，如果arr是数组首元素的地址，那输出应该的应该是4/8才对。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/64d078227f754b5086dfd11dfc38ab20.png)



- 其实数组名就是数组首元素(第一个元素)的地址是对的，但是有两个例外：


**sizeof(数组名)**，sizeof中单独放数组名，这里的数组名表示整个数组，计算的是整个数组的大小，单位是字节

**&数组名，** 这里的数组名表示整个数组，取出的是整个数组的地址（整个数组的地址和数组首元素的地址是有区别的）
- 除此之外，任何地方使用数组名，数组名都表示首元素的地址。

----

这时有好奇的同学，再试一下这个代码：

```c
#include <stdio.h>
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("&arr[0] = %p\n", &arr[0]);
	printf("arr     = %p\n", arr);
	printf("&arr    = %p\n", &arr);
	return 0;
}
```
- 可以看到arr和&arr的地址也是一样的，数组的地址是首元素的地址？

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/695e48bf00e54f25a9ff3df6f03bde1e.png)


- 数组的地址和数组首元素的地址的值是一模一样的，那它们有什么区别呢，接下来继续看~~

- 我们再来看下面这段代码~~

```c
#include <stdio.h>
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("&arr[0]   = %p\n", &arr[0]);
	printf("&arr[0]+1 = %p\n", &arr[0] + 1);
	printf("arr       = %p\n", arr);
	printf("arr+1     = %p\n", arr + 1);
	printf("&arr      = %p\n", &arr);
	printf("&arr+1    = %p\n", &arr + 1);
	return 0;
}
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6891a56f071741b581897e7389a66902.png)


- 但是`&arr` 和 `&arr+1`相差40个字节，这就是因为`&arr`是数组的地址，`+1`操作是跳过整个数组的。
- 我们再来回忆一下，什么决定了指针加一加了多少，是不是指针类型，指针类型决定了指针加一加了几，我们这个地方`&arr[0]`它的类型是`int*`，而&arr加一加了40个字节，它的类型是什么呢？我们这里留个悬念，后面都会将~~


## 二、使用指针访问数组

>有了前面知识的支持，再结合数组的特点，我们就可以很方便的使用指针访问数组了。

- 我们再来看这一段代码~~

```c
#include <stdio.h>
int main()
{
	int arr[10] = { 0 };
	//输入
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	//输入
	int* p = arr;
	for (i = 0; i < sz; i++)
	{
		scanf("%d", p + i);
		//scanf("%d", arr+i);//也可以这样写
	}
	//输出
	for (i = 0; i < sz; i++)
	{
		printf("%d ", *(p + i));
	}
	return 0;
}
```

- 我们定义了一个整型数组 arr 和一个指向该数组的指针 p，其中，表示数组元素的方法有两种，一种是 *(p + i)，另一种是 arr[i]。



- 这个代码搞明白后，我们再试一下，如果我们再分析一下，数组名arr是数组首元素的地址，可以赋值给p，其实数组名arr和p在这里是等价的。那我们可以使用arr[i]可以访问数组的元素，那p[i]是否也可以访问数组呢？

```c
#include <stdio.h>
int main()
{
	int arr[10] = { 0 };
	//输入
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	//输入
	int* p = arr;
	for (i = 0; i < sz; i++)
	{
		scanf("%d", p + i);
		//scanf("%d", arr+i);//也可以这样写
	}
	//输出
	for (i = 0; i < sz; i++)
	{
		printf("%d ", p[i]);
	}
	return 0;
}
```
- 在第18行的地方，将`(p+i)`换成`p[i]`也是能够正常打印的，所以本质上`p[i] `是等价于 `*(p+i)`。
- 同理`arr[i]`应该等价于`*(arr+i)`，数组元素的访问在编译器处理的时候，也是转换成首元素的地址+偏移量求出元素的地址，然后解引用来访问的。
- 这里的`arr[i]` == `*(arr+i)` == `*(i+arr)` == `i[arr]`是不是也可以这样，照样也能访问~~
- 不推荐上面的那种写法，比较难理解~~


-----

- 大家也可以验证一下p+i和&arr[i]的地址是不是一样~~

```c
int main() {
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;
	int i = 0;
	int sz = sizeof(arr) / sizeof(arr[0]);
	for (i = 0; i < sz; i++) {
		printf("%p ======== %p\n", p + i, &arr[i]);
	}
	return 0;
}
```

- 我们可以看到是一样的~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/58245aa8dd46441e8750f26724037199.png)


---


## 三、一维数组传参的本质

- 数组我们学过了，之前也讲了，数组是可以传递给函数的，这个小节我们讨论一下数组传参的本质。
- 首先从一个问题开始，我们之前都是在函数外部计算数组的元素个数，那我们可以把函数传给一个函数后，函数内部求数组的元素个数吗？
- 我们来看下面的代码~~
- 这里的sz1是多少，是10吗？sz2呢？也是10吗？

```c
#include <stdio.h>
void test(int arr[])
{
	int sz2 = sizeof(arr) / sizeof(arr[0]);
	printf("sz2 = %d\n", sz2);
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int sz1 = sizeof(arr) / sizeof(arr[0]);
	printf("sz1 = %d\n", sz1);
	test(arr);
	return 0;
}
```

- 我们来看一下结果
- 可以看到，sz1是10，而sz2是1，为什么是1呢？


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/790a595044214f3ea731f6d76fc8a286.png)

- 我们发现在函数内部是没有正确获得数组的元素个数。
- 这就要学习数组传参的本质了，上个小节我们学习了：数组名是数组首元素的地址；那么在数组传参的时候，传递的是数组名，也就是说**本质上数组传参本质上传递的是数组首元素的地址。**
- 所以函数形参的部分理论上应该使用指针变量来接收首元素的地址。那么在函数内部我们写sizeof(arr) 计算的是一个地址的大小（单位字节）而不是数组的大小（单位字节）。正是因为函数的参数部分是本质是指针，所以在**函数内部是没办法求的数组元素个数的**
------

- 当我把参数写成数组形式，本质上还是指针
- 当我将参数写成指针形式，它计算一个指针变量的大小

```c
void test1(int arr[])//参数写成数组形式，本质上还是指针
{
	printf("%d\n", sizeof(arr));
}
void test2(int* arr)//参数写成指针形式
{
	printf("%d\n", sizeof(arr));//计算一个指针变量的大小
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	test1(arr);
	test2(arr);
	return 0;
}
```
- 我们来看一下结果~~


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bd6dd2e9dec34da49538e6762d4fa105.png)


**总结：** 一维数组传参，形参的部分可以写成数组的形式，也可以写成指针的形式。


## 四、冒泡排序
>接下来我们就学习一下这个冒泡排序，主要学习两个内容~~
>1. 学习冒泡排序
>2. 学习数组传参

- 我们给了这样的一个降序数组，我们需要将这个数组排序，排为升序

```c
int main() {
	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
	//进行排序
	return 0;
}
```
- 我们创建一个函数，要排的是谁呢？是arr

```c
int main() {
	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
	//进行排序
	int sz = sizeof(arr) / sizeof(arr[0]);

	sort(arr,sz);

	return 0;
}
```
- 我们这里要讲一种排序，是冒泡排序
- 冒泡排序的核心思想就是：**两两相邻的元素进行比较。**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0c88569fa69c427b897a778c9e173d2a.png)



**代码如下：**

```c
void sort(int arr[], int sz) {
	//确定冒泡排序的趟数~~
	int i = 0;
	for (i = 0; i < sz - 1; i++) {
		//一趟冒泡排序
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++) {
			if (arr[j] > arr[j + 1]) {
				//交换
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
	}
}

void print(int arr[], int sz) {
	int i = 0;
	for (i = 0; i < sz; i++) {
		printf("%d ", arr[i]);
	}
}

int main() {
	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
	//进行排序
	int sz = sizeof(arr) / sizeof(arr[0]);

	sort(arr,sz);
	print(arr, sz);
	return 0;
}
```
- 上面的代码也可以指针的形式，还是一样的道理~~
- 上面的代码还是有优化的空间的，假设我的数组是这样的：

```c
int arr[] = { 9,0,1,2,3,4,5,6,7,8 };
```
- 这里我们经过一趟冒泡排序后就已经排好了，但是我们上面的代码一定要进行9趟，我们不进行交换，但还是要执行，效率是比较低的
- 如果已经排成有序的了，那后面就不用排了，那怎么做呢？

```c
void sort(int arr[], int sz) {
	//确定冒泡排序的趟数~~
	int i = 0;
	for (i = 0; i < sz - 1; i++) {
		//一趟冒泡排序
		int j = 0;
		int flag = 1;//假设数组是有序的
		for (j = 0; j < sz - 1 - i; j++) {
			if (arr[j] > arr[j + 1]) {
				//交换
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				flag = 0;//不是有序
			}
		}
		if (flag = 1) {
			break;
		}
	}
}
```
- 这样的写法是不是更好~~


---



## 五、二级指针
- 指针变量也是变量，是变量就有地址，那指针变量的地址存放在哪里？
- 我们来看下面的这一段代码~~

```c
#include<stdio.h>
int main() {
	int a = 10;
	int* pa = &a;
	int** ppa = &pa;
	return 0;
}
```

- a是整形变量，占用4个字节空间，a是自己的地址，&a拿到的就是a所占4个字节的第一个字节的地址
- pa是指针变量，占用4/8个字节的空间，p也是有自己的地址，&p就拿到了p的地址，pa是一级指针
- ppa也是指针变量，ppa是二级指针变量
- 那么我们能不能&ppa呢？可以啊，ppa也是有自己的地址,&ppa就拿到了ppa的地址，放到一个三级指针-->`int*** pppa = &ppa`
- 这些变量都是普通的变量，不要看的很厉害~~


-------

- 我们可以调试起来画图了解一下~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/64bd319cfd7a4735997b85a57bd264a7.png)


对于二级指针的运算有：
`*ppa` 通过对`ppa`中的地址进行解引用，这样找到的是`pa `， `*ppa` 其实访问的就是

```c
int b = 20;
*ppa = &b;//等价于 pa = &b;
```

`**ppa` 先通过`*ppa` 找到`pa` ,然后对`pa` 进行解引用操作： `*pa` ，那找到的是`a` .

```c
**ppa = 30;
//等价于*pa = 30;
//等价于a = 30;
```


## 六、指针数组
- 什么是指针数组？

我们类比一下：
1. 整形数组：存放整形的数组 int arr[10];
2. 字符数组：存放字符的数组 char ch[5];
3. 指针数组：存放指针的数组 


整形数组和字符数组：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dfcbcaeb165c443abd8e34d0fc6c157c.png)


- 指针数组的每个元素都是用来存放地址（指针）的。

如下图：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8af9c0646f664dfeb2ea389cbe3e3df5.png)


- 指针数组的每个元素是地址，又可以指向一块区域。

**比如：**

```c
int main() {
	int a = 1;
	int b = 2;
	int c = 3;
	int d = 4;
	int e = 5;
	int* parr[5] = { &a,&b,&c,&d,&e };

	return 0;
}
```
- 那我们也是可以打印出来的


```c
int main() {
	int a = 1;
	int b = 2;
	int c = 3;
	int d = 4;
	int e = 5;
	int* parr[5] = { &a,&b,&c,&d,&e };

	int i = 0;
	for (i = 0; i < 5; i++) {
		printf("%d ", *(parr[i]));
	}
	return 0;
}
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a510745e97e741029cac906a35729d0e.png)


- `parr[i]`找到了每个元素的地址，然后解引用，就找到了，便可以打印出来~~


## 七、指针数组模拟二维数组


```c
#include <stdio.h>
int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[] = { 2,3,4,5,6 };
	int arr3[] = { 3,4,5,6,7 };
	//数组名是数组首元素的地址，类型是int*的，就可以存放在parr数组中
	int* parr[3] = { arr1, arr2, arr3 };
	int i = 0;
	int j = 0;
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 5; j++)
		{
			printf("%d ", parr[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

- `parr[i]`是访问parr数组的元素，`parr[i]`找到的数组元素指向了整型一维数组，`parr[i][j]`就是整型一维数组中的元素。
上述的代码模拟出二维数组的效果，实际上并非完全是二维数组，因为每一行并非是连续的。
- 如果不懂还可以看下图：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7bc4dc28790946cfb3c88b85c4df1f01.png)




------
# 从浅入深理解指针《第三阶段》
-----


## 一、字符指针变量

- 在指针的类型中我们知道有一种指针类型为字符指针`char*` ;

- 我们这里定义了ch变量，里面存了个字符	`w`
- 然后我将这个变量的地址取出来放到pc里，它的类型是`char*`，pc就是字符指针变量
```c
int main()
{
	char ch = 'w';
	char* pc = &ch;
	return 0;
}
```

- 还有一种写法：
- 这里的指针变量p是要将字符"abcdefghi"放进去吗？
	- 字符指针变量是用来存放地址的
- 这个代码的意思不是将"abcdefghi\0"字符串放到p中
```c
char* p = "abcdefghi";
```

- 这里的表达式都有两个属性：值属性和类型属性
- 这里的字符串就是一串连续的，和数组一样
- 这个字符串就是首字符a的地址，也就是说只是把a的地址赋值给了p

-----
我们可以这样验证：

```c
char* p = "abcdefghi";
printf("%c", *p);
```

- 可以看到拿出了a

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e05b42ffd3da4f5c894e0f224b542d24.png)


- 这里的"abcdefghi"是常量字符串，是不能被修改的~~


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a419b5b49f0447699944177bf13b0f36.png)


- 我们可以给这个指针变量p加上`const`来修饰

```c
const char* p = "abcdefghi";
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3b9692980306434da5aeac3ee6512cde.png)


- 那我想要打印一下这个字符串，怎么办？

- 我们就以`%s`的方式来打印

```c
const char* p = "abcdefghi";
printf("%s", p);
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/590a7382d1bf46b7b991e0fabf4291c1.png)


-  通过调试我们也可以发现是连续存放的~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3f6e23c68c29497199c7fb2eac289f45.png)


-----

《剑指offer》中收录了一道和字符串相关的笔试题，我们一起来学习一下：

- 这道题打印的是什么呢？

```c
#include <stdio.h>
int main()
{
	char str1[] = "hello bit.";
	char str2[] = "hello bit.";
	const char* str3 = "hello bit.";
	const char* str4 = "hello bit.";
	if (str1 == str2)
		printf("str1 and str2 are same\n");
	else
		printf("str1 and str2 are not same\n");
	if (str3 == str4)
		printf("str3 and str4 are same\n");
	else
		printf("str3 and str4 are not same\n");
	return 0;
}
```

- 我们先来看一下结果

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fa4be278de0e4e2490fa82e1ad701e44.png)


- 那为什么是这样的结果呢，我们来分析一下~~
- 这里str3和str4指向的是一个同一个常量字符串。C/C++会把常量字符串存储到单独的一个内存区域，当几个指针指向同一个字符串的时候，他们实际会指向同一块内存。
- 但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。所以str1和str2不同，str3和str4相同。

-----

## 二、数组指针变量

### 2.1 数组指针变量是什么？
>之前我们学习了指针数组，指针数组是一种数组，数组中存放的是地址（指针）。
>数组指针变量是指针变量？还是数组？

答案是：**指针变量**

我们已经熟悉：

- **整形指针变量：** `int * pint;` 存放的是整形变量的地址，能够指向整形数据的指针。

- **浮点型指针变量：**  `float * pf;` 存放浮点型变量的地址，能够指向浮点型数据的指针。

**数组指针变量应该是：存放的应该是数组的地址，能够指向数组的指针变量。**

- 那么我们的数组指针怎么写呢？

```c
int *p1[10];
int (*p2)[10];
```
- 这两个是哪个呢？

	- 答案是第二个~~，第一个是指针数组，


**数组指针变量**


```c
int (*p)[10];
```

- **解释：** p先和*结合，说明p是一个指针变量变量，然后指着指向的是一个大小为10个整型的数组。所以p是一个指针，指向一个数组，叫 数组指针。

- 这里要注意：`[]`的优先级要高于`*`号的，所以必须加上`（）`来保证p先和*结合。


### 2.2 数组指针变量怎么初始化

- 数组指针变量是用来存放数组地址的，那怎么获得数组的地址呢？就是我们之前学习的`&数组名`。

```c
int arr[10] = { 0 };
&arr;//得到的就是数组的地址
```
- 如果要存放个数组的地址，就得存放在数组指针变量中，如下：


```c
int(*p)[10] = &arr;
```

- 我们调试也能看到&arr 和p 的类型是完全一致的。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/51f1ff26cfa3416b97ebb7129b7cae90.png)


- 数组指针类型的解析：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a0f13856f66644a8959132b650cd44cd.png)


- 去掉名字就是这个指针的类型

- 这就是为什么arr和&arr是不一样的

```c
int arr[10] = { 0 };
arr; //数组首元素的地址 -- int*
&arr;//数组的地址      -- int(*)[10]
```

- 指针类型决定了+1加了多少个字节~~


------

## 三、二维数组传参的本质

- 有了数组指针的理解，我们就能够讲一下二维数组传参的本质了。
- 过去我们有一个二维数组的需要传参给一个函数的时候，我们是这样写的：


```c
#include <stdio.h>
void test(int a[3][5], int r, int c)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			printf("%d ", a[i][j]);
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { {1,2,3,4,5}, {2,3,4,5,6},{3,4,5,6,7} };
	test(arr, 3, 5);
	return 0;
}
```

- 这里实参是二维数组，形参也写成二维数组的形式，那还有什么其他的写法吗？

- 首先我们再次理解一下二维数组，二维数组起始可以看做是每个元素是一维数组的数组，也就是二维数组的每个元素是一个一维数组。那么二维数组的首元素就是第一行，是个一维数组.

如下图：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ce99b4a9ec0c4138b5a4282e4eb987da.png)


- 也可以这样理解：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a802f0cb98574aeb816a4da56a2d1f98.png)




- 二维数组的每一行是一个一维数组，这个一维数组可以看做是二维数组的第一个元素，所以二维数组也可以认为是一维数组的数组
- 那么二维数组的数组名表示数组首元素的地址，就是第一行的地址，也就是一个一维数组的地址
-----
- 根据上面的例子，第一行的一维数组的类型就是`int [5]` ，所以第一行的地址的类型就是数组指针类型`int(*)[5]` 。那就意味着二维数组传参本质上也是传递了地址，传递的是第一行这个一维数组的地址，那么形参也是可以写成指针形式的。如下：

```c
#include <stdio.h>
void test(int(*p)[5], int r, int c)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			printf("%d ", *(*(p + i) + j));
		}
		printf("\n");
	}
}
int main()
{
	int arr[3][5] = { {1,2,3,4,5}, {2,3,4,5,6},{3,4,5,6,7} };
	test(arr, 3, 5);
	return 0;
}
```

**总结：** 二维数组传参，形参的部分可以写成数组，也可以写成指针形式。

## 四、函数指针变量


### 4.4 函数指针变量的创建

- 什么是函数指针变量呢？
	- 数组指针，是指针，指向数组的指针，是存放数组的指针
	- 函数指针，是指针，是指向函数的指针，是存放函数地址的指针~~


- 那么函数是否有地址呢？


```c
#include <stdio.h>
void test()
{
	printf("hehe\n");
}
int main()
{
	printf("test:  %p\n", test);
	printf("&test: %p\n", &test);
	return 0;
}
```
- 我们可以看到是一样的
- 对于函数来说，&函数名和函数名都是函数的地址~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8d6117feda0b4ae09a4fdbb5cb2a5288.png)


- 我们还可以通过调试来看一下

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aec179db81da4cb1af29512ae1e60e4e.png)



- 确实打印出来了地址，所以函数是有地址的，函数名就是函数的地址，当然也可以通过&函数名的方式获得函数的地址。
- 如果我们要将函数的地址存放起来，就得创建函数指针变量咯，函数指针变量的写法其实和数组指针非常类似。如下：

```c
void test()
{
	printf("hehe\n");
}
void (*pf1)() = &test;
void (*pf2)() = test;
int Add(int x, int y)
{
	return x + y;
}
int(*pf3)(int, int) = Add;
int(*pf3)(int x, int y) = &Add;//x和y写上或者省略都是可以的
```
- 那这个函数指针有什么用呢？

### 4,5 函数指针变量的使用

>那我们是不是要进行使用，怎么使用呢？

- 调用函数指针传参，可以看到是能打印出来的~~
- 那有的同学会说，我直接调用这个函数不就好了，为什么要多此一举呢？别着急，格局要打开，如果没用的话就不讲了~~

```c
int Add(int x, int y)
{
	return x + y;
}
int main()
{
	int (*pf)(int, int) = &Add;

	int r = (*pf)(3, 5);//调用函数指针

	printf("r = %d\n", r);

	return 0;
}
```


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c07b7fd6e91641719456ce05bd2953c7.png)



-----

- 我们继续来看，那有的同学会说，我pf不加解引用操作符可以吗？答案是可以的~
- 就算你写多个`*`也行，但是写上就更容易理解，可读性更高一些~~

```c
int r = pf(3, 5);
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/73e1d743e33d4e14af7170c5efb6a302.png)


**函数指针类型解析：**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5399d01764c3475095c09bebec048c81.png)


### 4.6 两段有趣的代码

代码1：

```c
(*(void (*)())0)();
```

- 调用0地址处的函数，调用的函数，参数是无参，返回类型是void

代码2：

```c
void (*signal(int , void(*)(int)))(int);
```

- `signal`是一个函数的函数名，上面的代码是一次函数声明，声明的`signal`函数有两个参数，第一个参数是int类型的，第二个参数是函数指针类型的，该函数指针指向的函数参数是int类型，返回类型是`void`
- `signal`函数的返回类型也是一个函数指针，该函数指针指向的函数，参数是int，返回类型也是void

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7bced4dad1074dda93ee8fc12c6f7bf9.png)






>两段代码均出自：《C陷阱和缺陷》这本书




![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/49531124be244d1495a69c94a35db352.png)



-----


### 4.7 typedef关键字


- typedef 是用来类型重命名的，可以将复杂的类型，简单化。

- 比如，你觉得`unsigned int`写起来不方便，如果能写成`uint` 就方便多了，那么我们可以使用：


```c
typedef unsigned int uint;
//将unsigned int 重命名为uint
```
- 如果是指针类型，能否重命名呢？其实也是可以的，比如，将`int*`重命名为`ptr_t`，这样写：


```c
typedef int* ptr_t;
```

- 但是对于数组指针和函数指针稍微有点区别：
- 比如我们有数组指针类型`int(*)[5]` ,需要重命名为`parr_t `，那可以这样写：

```c
typedef int(*parr_t)[5]; //新的类型名必须在*的右边
```


- 函数指针类型的重命名也是一样的，比如，将`void(*)(int)` 类型重命名为`pf_t` ,就可以这样写：

```c
typedef void(*pfun_t)(int);//新的类型名必须在*的右边
```

- 那么要简化代码2，可以这样写：

```c
typedef void(*pfun_t)(int);
pfun_t signal(int, pfun_t);
```

## 五、函数指针数组


- 根据前面学的，我们再来类比一下：

	- 字符指针数组：数组，数组中存放的都是字符指针
	- 整形指针数组：数组，数组中存放的都是整形指针

那么我们是不是也可以将这个函数放到数组里？接下来我们来学习函数指针数组


- 函数指针数组：数组，数组中存放的都是函数指针

比如：

```c
int *arr[10];
//数组的每个元素是int*
```
- 那要把函数的地址存到一个数组中，那这个数组就叫函数指针数组，那函数指针的数组如何定义呢？

```c
int (*parr1[3])();
```

- `parr1` 先和`[]` 结合，说明 `parr1`是数组，数组的内容是什么呢？
是`int (*)()` 类型的函数指针。
- 函数指针数组就是存放函数指针的数组~~

-------

那么有用吗，有的！！，接下来就来到我们的转移表模块~~

## 六、转移表

>函数指针数组的用途：**转移表**

- 举例：计算器的一般实现：

**初阶版本：**

```c
#include <stdio.h>

void menu()
{
	printf("*************************\n");
	printf("********1:add 2:sub****** \n");
	printf("********3:mul 4:div******\n");
	printf("********0:exit     ******\n");
	printf("*************************\n");
}

int add(int a, int b)
{
	return a + b;
}
int sub(int a, int b)
{
	return a - b;
}
int mul(int a, int b)
{
	return a * b;
}
int div(int a, int b)
{
	return a / b;
}
int main()
{
	int x, y;
	int input = 1;
	int ret = 0;
	do
	{
		menu();
		printf("请选择：");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			printf("输入操作数：");
			scanf("%d %d", &x, &y);
			ret = add(x, y);
			printf("ret = %d\n", ret);
			break;
		case 2:
			printf("输入操作数：");
			scanf("%d %d", &x, &y);
			ret = sub(x, y);
			printf("ret = %d\n", ret);
			break;
		case 3:
			printf("输入操作数：");
			scanf("%d %d", &x, &y);
			ret = mul(x, y);
			printf("ret = %d\n", ret);
			break;
		case 4:
			printf("输入操作数：");
			scanf("%d %d", &x, &y);
			ret = div(x, y);
			printf("ret = %d\n", ret);
			break;
		case 0:
			printf("退出程序\n");
			break;
		default:
			printf("选择错误\n");
			break;
		}
	} while (input);
	return 0;
}
```

- 这个计算器的实现，有一些不好的地方，假设我这个计算器后面要算的功能更多了，随着函数的功能不断的增长，菜单要跟着变，swich里面的也是需要跟着变，代码会越来越长
- 这个时候有另外一种解决办法，解下来改造我们的版本~~

**改进版本：**
```c
#include <stdio.h>

void menu()
{
	printf("*************************\n");
	printf("********1:add 2:sub****** \n");
	printf("********3:mul 4:div******\n");
	printf("********0:exit     ******\n");
	printf("*************************\n");
}

int add(int a, int b)
{
	return a + b;
}
int sub(int a, int b)
{
	return a - b;
}
int mul(int a, int b)
{
	return a * b;
}
int div(int a, int b)
{
	return a / b;
}
int main()
{
	int x, y;
	int input = 1;
	int ret = 0;
	int(*pfArr[5])(int x, int y) = { 0, add, sub, mul, div }; //转移表
	do
	{
		menu();
		printf("请选择：");
		scanf("%d", &input);
		if ((input <= 4 && input >= 1))
		{
			printf("输入操作数：");
			scanf("%d %d", &x, &y);
			ret = (*pfArr[input])(x, y);
			printf("ret = %d\n", ret);
		}
		else if (input == 0)
		{
			printf("退出计算器\n");
		}
		else
		{
			printf("输入有误,请重新选择\n");
		}
	} while (input);
	return 0;
}
```
- 这样改造我们的代码，代码量大幅度的缩短~~


## 七、 指向函数指针数组的指针

- 指向函数指针数组的指针是一个 指针
- 指针指向一个 数组 ，数组的元素都是 函数指针 ;

**如何定义？**	

```c
void test(const char* str)
{
	printf("%s\n", str);
}
int main()
{
	//函数指针pfun
	void (*pfun)(const char*) = test;
	//函数指针的数组pfunArr
	void (*pfunArr[5])(const char* str);
	pfunArr[0] = test;
	//指向函数指针数组pfunArr的指针ppfunArr
	void (*(*ppfunArr)[5])(const char*) = &pfunArr;
	return 0;
}
```

- 这个指向`函数指针数组`的指针也不怎么重要，这里就不细讲了，让大家知道有这个概念，有兴趣的同学可以自行查阅~~
