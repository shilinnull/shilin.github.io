


## 一、回调函数是什么？
- 回调函数就是一个`通过函数指针调用的函数`。
- 如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，被调用的函数就是回调函数。
  - 回调函数`不是`由该函数的实现方直接调用，而是在`特定的事件或条件发生时由另外的一方调用的`，用于对该事件或条件进行响应。


我们首先对上面的计算器来进行举例：
- 首先我们看到最一开始的计算器是不是很冗余，我们可以使用这个回调函数进行简化

```c
#include <stdio.h>

menu()
{
	printf("*************************\n");
	printf("********1:add 2:sub****** \n");
	printf("********3:mul 4:div******\n");
	printf("********0:exit     ******\n");
	printf("*************************\n");
}

int add(int a, int b)
{
	return a + b;
}
int sub(int a, int b)
{
	return a - b;
}
int mul(int a, int b)
{
	return a * b;
}
int div(int a, int b)
{
	return a / b;
}

void calc(int (*pf)(int, int))
{
	int ret, x, y;
	printf("输入操作数：");
	scanf("%d %d", &x, &y);
	ret = (*pf)(x, y);
	printf("ret = %d\n", ret);
}

int main()
{
	int input = 1;
	do
	{
		menu();
		printf("请选择：");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			calc(add);
			break;
		case 2:
			calc(sub);
			break;
		case 3:
			calc(mul);
			break;
		case 4:
			calc(div);
			break;
		case 0:
			printf("退出程序\n");
			break;
		default:
			printf("选择错误\n");
			break;
		}
	} while (input);
	return 0;
}
```

- 我们都是通过这个函数指针来调用函数

**图解：**
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/50684d3fb1444dc081c011aa0751a50d.png)

>就好像是老板把任务分配给组长，组长再分配给组员实现内容~~


## 二、qsort使用举例
- qsort是一个库函数，用来对数据进行排序，可以排任意类型的数据

- 我们打开[cplusplus](https://legacy.cplusplus.com/)网站搜索[qsort](https://legacy.cplusplus.com/reference/cstdlib/qsort/?kw=qsort)


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9351e9d8046a4f598363db81c3b1c83d.png)





这个qsort函数有4个参数：

```c
void qsort(void* base, 
			   size_t num, 
			   size_t size,
		   	   int (*compar)(const void*, const void*));
```
- 第一个参数是指向待排序的第一个元素
- 第二个参数是待排序的元素个数
- 第三个参数是待排序的数组元素的大小（单位是字节）
- 第四个参数是比较两个元素

-----

- 这里有个void*的指针类型，这个指针类型是`通用指针类型`,这个指针类型可以接收任意类型数据的地址，就可以理解成指针垃圾桶，谁的地址都可以往里扔~~

- 是一个无具体类型的指针，所以就不能+1，也不能解引用

-------

我们也介绍完了这个函数，我们来使用排序一下整形数组

**写出我们的主函数：**

```c
int main()
{
	int arr[] = { 3,2,5,6,8,7,9,1,4 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	
	qsort(arr, sz, sizeof(arr[0]), cmp_int);
	
	for (size_t i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
```

- 下面这里就剩下一个比较函数了，怎么写呢？我们再来看一个网站上面的介绍~~
- 这个函数能够比较e1和e2指向的两个元素，并给出返回值~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8aacbc160ca94a0dbd0b4e505baec504.png)


- 我们也就按照上面的案例来写~~

```c
int cmp_int(const void* e1, const void* e2)
{
	return *(int*)e1 - *(int*)e2;
}
```

- 现在我们来看已经完美排序了~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/63b2f54c11c1431fb5421e186784b24d.png)


- 那么对于整形数据也可以排序了，是不是也可以对字符/字符串类型排序，对结构体也可以进行排序

- 首先我们对于名字进行排序，对于名字排序，名字是个字符串，不能使用大小于号来进行比较，我们需要用到strcmp函数来进行比较，打开cplusplus网站搜索[stcmp](https://legacy.cplusplus.com/reference/cstring/strcmp/?kw=strcmp)，发现这个函数的返回值也是整形，和qsort基本一样，我们使用的时候可以直接`return`

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9bb3b07914ee41f69e8c416e1dfa890e.png)

- 首先写出我们的结构体和主函数

```c
struct Stu
{
	char name[20];
	int age;
};

int main()
{
	struct Stu s[] = { {"zhangsan",20 },{"lisi",18},{"wangwu",30} };

	qsort(s, sizeof(s) / sizeof(s[0]), sizeof(s[0]), stu_cmp_by_name);

	for (int i = 0; i < sizeof(s) / sizeof(s[0]); i++)
	{
		printf("%s %d\n", s[i].name, s[i].age);
	}

	return 0;
}
```

- 然后对于比较函数我们可以这样写

```c
int stu_cmp_by_name(const void* e1, const void* e2)
{
	return strcmp(((struct Stu*)e1)->name,((struct Stu*)e2)->name);
}
```

- 排序的时候是按照字典里的字符顺序排的
- 可以看到，已经排序完成了~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b002556bad62455e90f922d61422fd38.png)


-----

- 那么回到上面，我们也可以对结构体的整形数据进行排序，也就是年龄
- 我们直接写出来

```c
struct Stu
{
	char name[20];
	int age;
};

int stu_cmp_by_age(const void* e1, const void* e2)
{
	return ((struct Stu*)e1)->age - ((struct Stu*)e2)->age;
}

int main()
{
	struct Stu s[] = { {"zhangsan",20 },{"lisi",18},{"wangwu",30} };

	qsort(s, sizeof(s) / sizeof(s[0]), sizeof(s[0]), stu_cmp_by_age);

	for (int i = 0; i < sizeof(s) / sizeof(s[0]); i++)
	{
		printf("%s %d\n", s[i].name, s[i].age);
	}

	return 0;
}
```


- 可以看到，对于年龄的排序也是可以排序成功的

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/96989cfc52ca478b96af5a0a5b7d4f49.png)




## 三、qsort函数的模拟实现

>qsort可以排序整形数据/字符数据/结构体数据...
>可以使用qsort函数对数据进行排序	


使用回调函数，模拟实现qsort（采用冒泡的方式）。
- 今天我们使用冒泡排序，来实现一个对任意类型能够排序的函数

- 我们先来实现一个整形的冒泡排序，然后再进行改造~~

```c
void bubble_sort(int arr[], int sz)
{
	int i = 0;
	for ( i = 0; i < sz - 1; i++)
	{
		int j = 0;
		for (j = 0; j < sz - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}

		}
	}
}

int main()
{
	int arr[] = { 3,2,5,6,8,7,9,1,4 };
	int sz = sizeof(arr) / sizeof(arr[0]);

	bubble_sort(arr, sz);

	for (size_t i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
```

接下来我们开始**改造**~~
1. 改造参数  -- 让这个函数能够接受任意类型的数据
2. 改造比较方法 -- 让函数能够在排序时，比较不同类型的数据
3. 交换的代码也需要修改


--------


- e1是一个指针，存放了要比较元素的地址
e2是一个指针，存放了要比较元素的地址
e1指向的元素大于e2指向的元素，返回>0的数字
e1指向的元素等于e2指向的元素，返回0
e1指向的元素小于e2指向的元素，返回<0的数字



- 我们来看完整代码


```c
void print_arr(int arr[], int sz)	
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
}

void Swap(char* buf1, char* buf2, size_t size)
{
	for (int i = 0; i < size; i++)
	{
		char tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		++buf1;
		++buf2;
	}
}

int cmp_int(const void* e1, const void* e2)
{
	return *(int*)e1 - *(int*)e2;
}

void my_bubble_qsort(void* base, size_t num, size_t size, int(*cmp)(const void* e1, const void* e2))
{
	int i = 0;
	int j = 0;
	for (i = 0; i < num - 1; i++)
	{
		for (j = 0; j < num - i - 1; j++)
		{
			// 返回了大于0的数就交换
			if (cmp((char*)base + j * size, (char*)base + (j + 1) * size) > 0)
			{
				Swap((char*)base + j * size, (char*)base + (j + 1) * size, size);
			}
		}
	}
}


int main()
{
	int arr[] = { 3,2,5,6,8,7,9,1,4,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	my_bubble_qsort(arr, sz, sizeof(arr[0]), cmp_int);
	print_arr(arr, sz);
	return 0;
}
```
------


下面图解可以看一下~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c581b0d100f94027864b0315293582fd.png)


- 可以看到，我们对整形的排序也成功了

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/69aa1092205849c68a0e71727ad33907.png)


------
# 从浅入深理解指针《第五阶段》
-----

- 在我们学习最后部分的笔试题的时候，我们需要先了解这些概念`sizeof`和`strlen`

## 一、sizeof和strlen的对比

### 1.1 sizeof

- 在学习操作符的时候，我们学习了`sizeof` ， `sizeof` 计算变量所占内存内存空间大小的，单位是字节，如果操作数是类型的话，计算的是使用类型创建的变量所占内存空间的大小。

- 我们就来开始学习了解sizeof~~

-----

- 其中`size_t`其实专门是设计给`sizeof`的，表示`sizeof`的返回值类型
- `sizeof`计算的不可能是负数吧，所以`size_t`是为`sizeof`来设计的~~

列如：

```c
int main()
{
	int a = 10;
	printf("%d\n", sizeof(a));
	printf("%d\n", sizeof(int));
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/98979e478391416595b6c99a6f5c87ad.png)

- 如果这里是变量，括号是可以省略的
- 如果是类型就是，就不能省略

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a2c22c868e914f06862b5ae0cf078168.png)



- 这里算出的4就是占用4个字节

----

- `sizeof` 只关注占用内存空间的大小，不在乎内存中存放什么数据，我们一会来详细看~~


### 1.2 strlen

[strlen](https://legacy.cplusplus.com/reference/cstring/strlen/?kw=strlen) 是C语言库函数，功能是求字符串长度。函数原型如下：

```c
size_t strlen ( const char * str );
```
- 它统计的是从`strlen`函数的参数`str`中这个地址开始向后，`\0`之前字符串中字符的个数。
- `strlen` 函数会一直向后找`\0` 字符，直到找到为止，所以可能存在越界查找。


我们来看下面的代码：

```c
int main()
{
	char arr2[] = "abc";
	printf("%d\n", strlen(arr2));
	return 0;
}
```
- 这里的strlen算出的是`3`
- 我们还可以通过调试窗口看一下是怎么存放的~~


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/00cb38660cf847c98299ea890a7f9ceb.png)



- 可以看到这里内存监视窗口的61就是97，0就是`\0`，`strlen`是统计`\0`之前的字符串的个数，结果是`3`

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9f06c524d46345b89934a89584f0c89a.png)




- 那我在字符串的中间手动加一个`\0`会算出几呢？

```c
char arr2[] = "ab\0c";
printf("%d\n", strlen(arr2));
```

- 可以看到结果是`2`

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b09894870762490b9c5bc1adeb905126.png)


 - 那字符串没有`\0`它的结果是什么呢？

```c
char arr1[] = { 'a', 'b', 'c' };
printf("%d\n", strlen(arr1));
```

- 我们可以看到结果是15，其实是随机值，我也不知道多会会遇到`\0`。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c77dc6bfe9514a1daa938dd38878f44d.png)



![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/48ba1f5f51124795b1f88f3f58592897.png)


- 下面我们来对比一下`strlen`和`sizeof`

**strlen：**

- sizeof是操作符
- sizeof计算操作数所占内存的大小，单位是字节
- 不关注内存中存放什么数据

**sizeof：**
- strlen是库函数，使用需要包含头文件`string.h`
- srtlen是求字符串长度的，统计的是`\0`之前字符的个数
- 关注内存中是否有`\0`，如果没有`\0`，就会持续往后找，可能会越界

-----

- sizeof在计算大小的时候，其实是根据类型推算的
- 那么下面打印的是什么呢？

```c
short s = 10;
int i = 2;
int n = sizeof(s = i + 4);
printf("%d\n", n);
printf("%d\n", s);
```

- 我们来看结果~~


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/05c97fe028b5447796133148d338c6eb.png)


- 为什么是2和10呢？我们来分析一下~~

- 创建了一个短整型s，占两个字节，i是整形，占四个字节
- 这里的i+4得出的结果我要放到s类型，我一个4个整形的放到两个整形的空间，这要发生截断，截断之后就是s说了算，所以就是2个字节。
- 那么第二个，表达式放到sizeof内部不会真实计算的，不参与计算！！！所以原来的值就会打印什么值~~

----


- 那么有同学会问，表达式不参与计算，那上面那个为什么会是2呢？其实是sizeof是根据类型推断出来的，s = i + 4不会执行，其中 i + 4算出的就是整形类型的，整形类型的结果要放到shot类型的，所以就是short类型，就是2个字节，你懂了吗~~


----
>如果还没有理解的话，我们来看一些笔试题，来加深一下印象~~
## 二、数组和指针笔试题解析
### 2.1 一维数组

- 我们先来看这里，下面打印的是什么呢？可以先自己分析一下，然后我们来挨个分析~~


```c
int main()
{
	int a[] = { 1,2,3,4 };
	printf("%d\n", sizeof(a));
	printf("%d\n", sizeof(a + 0));
	printf("%d\n", sizeof(*a));
	printf("%d\n", sizeof(a + 1));
	printf("%d\n", sizeof(a[1]));
	printf("%d\n", sizeof(&a));
	printf("%d\n", sizeof(*&a));
	printf("%d\n", sizeof(&a + 1));
	printf("%d\n", sizeof(&a[0]));
	printf("%d\n", sizeof(&a[0] + 1));
	return 0;
}
```
- 你要知道的就是数组名即为首元素地址，不过有两个例外：
	- sizeof(数组名) —— 数组名表示整个数组，计算的是整个数组的大小，单位是字节
	- &数组名 —— 数组名表示数组名表示整个数组，取出的是整个数组的地址。

----

- `sizeof`内部单独放了一个数组名，数组名表示整个数组的大小，数组内有4个元素，每个**元素**4个字节，所以就是`16`
```c
printf("%d\n", sizeof(a));
```
---

- 这个地方的数组名的a并没有放到sizeof内部，也没有`&`，所以a就是首元素的地址，是**地址**，大小就是`4/8`个字节

```c
printf("%d\n", sizeof(a + 0));
```
---

- a就是数组首元素的地址,`*a == *(a+0) == a[0]`，*a 其实就是第一个**元素**，也就是`a[0]`，大小就是`4`个字节

```c
printf("%d\n", sizeof(*a));
```
---

- a就是数组首元素的地址(&a[0] -->int*)， a+1--> &a[1]，a+1就是第二个元素的**地址**，所以结果就是`4/8`

```c
printf("%d\n", sizeof(a + 1));
```

---
- 计算第2个**元素**的大小，单位是字节 结果就是`4`
```c
printf("%zd\n", sizeof(a[1]));
```
---
- `&a` 取出的是数组的地址，但是数组的地址也是**地址**，是地址大小就是`4 / 8` 个字节
```c
printf("%zd\n", sizeof(&a));
```
---
- 这里&a是取出数组的地址，然后再解引用，也就是相当于抵消了，&a是一个数组指针，也就是`int(*p)[4] = &a`，*p访问一个数组的大小，p+1就是跳过一个**数组的大小**，结果是`16`

```c
printf("%d\n", sizeof(*&a));
```
---

- &a+1是跳过整个数组后的**地址**，是地址大小就是4/8个字节，结果就是`4/8`
```c
printf("%zd\n", sizeof(&a + 1));
```
---
- 这里就是首元素的**地址**，结果是`4/8`

```c
printf("%zd\n", sizeof(&a[0]));
```

---
- 这里就是第二个元素的**地址**，结果是`4/8`
```c
printf("%zd\n", sizeof(&a[0] + 1));
```
---

- 我们在vs上验证一下，这个是32位平台下打印的~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4975b9dfe33e4db38ceb076bb357537e.png)


- 这个是在64位下运行的~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6a9c8db912e74782abcc8406081235e3.png)


-------

### 2.2 字符数组

- 接下来我们来看字符数组

```c
int main()
{
	char arr[] = { 'a','b','c','d','e','f' };
	printf("%d\n", sizeof(arr));
	printf("%d\n", sizeof(arr + 0));
	printf("%d\n", sizeof(*arr));
	printf("%d\n", sizeof(arr[1]));
	printf("%d\n", sizeof(&arr));
	printf("%d\n", sizeof(&arr + 1));
	printf("%d\n", sizeof(&arr[0] + 1));
	return 0;
}
```
---
- 数组名单独放在了sizeof内部，计算的是整个**数组的大小**，字符有6个，所以结果就是`6`
```c
printf("%d\n", sizeof(arr));
```
----
- arr是数组首元素的地址，arr+0 还是首元素的**地址** ，是地址大小就是`4/8`个字节

```c
printf("%d\n", sizeof(arr + 0));
```
----
- arr是数组首元素的地址,*arr就是**首元素**,就占一个字符大小就是`1`个字节
```c
printf("%d\n", sizeof(*arr));
```
----
- arr[1]就是数组的第二个**元素**，大小是`1`个字节

```c
printf("%d\n", sizeof(arr[1]));
```
----
- &arr 是数组的地址，数组的地址也是**地址**，大小就是`4/8`
```c
printf("%d\n", sizeof(&arr));
```
----
- &arr+1 是跳过**整个数组**，指向f的后面`4/8`

```c
printf("%d\n", sizeof(&arr + 1));
```
---
- &arr[0]是首元素的地址，&arr[0]+1就是第二个元素的**地址** `4/8`
```c
printf("%d\n", sizeof(&arr[0] + 1));
```
---

- 我们来看32平台下

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/92935c15e7004b0fbcb035c423afe219.png)




- 再来看64位平台下的


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/70df6abaa01f4efca601d8441b1b9cfa.png)



-------


- 我们继续来看第二个


```c
char arr[] = { 'a','b','c','d','e','f' };
printf("%d\n", strlen(arr));
printf("%d\n", strlen(arr+0));
printf("%d\n", strlen(*arr));
printf("%d\n", strlen(arr[1]));
printf("%d\n", strlen(&arr));
printf("%d\n", strlen(&arr+1));
printf("%d\n", strlen(&arr[0]+1));
```

- 这个数组是没有\0的，strlen是计算`\0`之前的元素个数所以就是`随机值`
```c
printf("%d\n", strlen(arr));
```
---
- 这个数组名也是首元素的地址，+0也就相当于没有加，结果是`随机值`~~

```c
printf("%d\n", strlen(arr+0));
```
----
- 这里arr是首元素的地址，然后*arr解引用就是字符`a`，ASCLL码值是97，97传给strlen，**会把97当成个地址**，会**非法访问**，结果会`报错`


```c
printf("%d\n", strlen(*arr));
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8b9f777753044e77b54a880675bccbe6.png)


---
- 这个代码与上个代码相似，访问的是**第二个元素的ASCLL码值，会当地**址传过去，也会`报错`
```c
printf("%d\n", strlen(arr[1]));
```

----
- &arr就是取出这个数组的地址，也就是**起始位置向后数**，结果也是`随机值`
```c
printf("%d\n", strlen(&arr));
```
---
- 这个&arr就是首元素的地址，然后+1，**跳过整个数组的地址，内存放的什么也不知道**，结果也就是`随机值`
```c
printf("%d\n", strlen(&arr+1));
```
---
- &arr[0]是首元素的地址，+1就是**第二个元素的地址，然后向后数**，结果也是`随机值`
```c
printf("%d\n", strlen(&arr[0]+1));
```
---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d703c8b20ff648f59f098633ed7a4940.png)


-------

- 这里我们初始化`abcdef\0`，这里面有\0~~
```c
char arr[] = "abcdef";
printf("%d\n", sizeof(arr));
printf("%d\n", sizeof(arr+0));
printf("%d\n", sizeof(*arr));
printf("%d\n", sizeof(arr[1]));
printf("%d\n", sizeof(&arr));
printf("%d\n", sizeof(&arr+1));
printf("%d\n", sizeof(&arr[0]+1));
```


- 这里算的是**arr元素的大小**，结果是`7`

```c
printf("%d\n", sizeof(arr));
```
- arr表示数组首元素的地址，`arr + 0`还是**首元素的地址**，大小就是`4/8`个字节

```c
printf("%d\n", sizeof(arr+0));
```
- arr表示数组首元素的地址,*arr就是**首元素**，大小就是`1`字节

```c
printf("%d\n", sizeof(*arr));
```
- arr[1]是**第二个元素**，大小也是`1`字节

```c
printf("%d\n", sizeof(arr[1]));
```
- &arr是数组的地址，但是也是地址，是**地址**大小就是`4/8`个字节
```c
printf("%d\n", sizeof(&arr));
```
- &arr是数组的地址,&arr+1就是跳过整个数组的那个**地址**，结果是`4/8`个字节

```c
printf("%d\n", sizeof(&arr+1));
```
- 第二个元素的**地址**，大小`4/8`个字节
```c
printf("%d\n", sizeof(&arr[0]+1));
```


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3af242c2f4334cab807d084363c9cf7b.png)



-------

 - 我们再把`sizeof`换成`strlen`~~

```c
char arr[] = "abcdef";
printf("%d\n", strlen(arr));
printf("%d\n", strlen(arr+0));
printf("%d\n", strlen(*arr));
printf("%d\n", strlen(arr[1]));
printf("%d\n", strlen(&arr));
printf("%d\n", strlen(&arr+1));
printf("%d\n", strlen(&arr[0]+1));
```


- arr是首元素的地址，计算的是strlen遇到\0之前**元素的个数**，结果是`6`
```c
printf("%d\n", strlen(arr));
```
- arr+1 也是**首元素的地址**，结果就是`6`
```c
printf("%d\n", strlen(arr+0));
```
- 这里结果是`报错`,会非法访问
```c
printf("%d\n", strlen(*arr));
```
- 这里也会形成`非法访问`~~
```c
printf("%d\n", strlen(arr[1]));
```
- &arr是数组的地址，但是这个地址也是指向**数组的起始位置**的，strlen就从起始位置开始向后找\0，结果是`6`
```c
printf("%d\n", strlen(&arr));
```
- &arr+1是**跳过整个数组后的地址**，从这里开始向后找\0，就是`随机值`
```c
printf("%d\n", strlen(&arr+1));
```
- arr[0] + 1 是第**二个元素的地址**，长度是`5`
```c
printf("%d\n", strlen(&arr[0]+1));
```

- 我们来看一下结果~~


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/64b41e6bc4ce4142810bf676a97dfb43.png)



-----
- 我们这里指针变量`p`存放的是这个字符串a的地址
```c
char *p = "abcdef";
printf("%d\n", sizeof(p));
printf("%d\n", sizeof(p+1));
printf("%d\n", sizeof(*p));
printf("%d\n", sizeof(p[0]));
printf("%d\n", sizeof(&p));
printf("%d\n", sizeof(&p+1));
printf("%d\n", sizeof(&p[0]+1));
```


- p是一个指针变量，**地址**大小是`4/8`个字节
```c
printf("%d\n", sizeof(p));
```
- p+1是‘b’的地址，是**地址**就是`4/8`个字节
```c
printf("%d\n", sizeof(p+1));
```
- `*p` 是**首字符**，大小是`1`字节
```c
printf("%d\n", sizeof(*p));
```
- p[0] === *(p+0)，其实就是字符串中的**首字符**，大小是`1`字节
```c
printf("%d\n", sizeof(p[0]));
```
- &p是p的地址，也是地址，**地址**大小就是`4/8`个字节
```c
printf("%d\n", sizeof(&p));
```
- &p + 1也是**地址**，&p1+1是跳过p变量后的地址，是地址就是`4/8`个字节
```c
printf("%d\n", sizeof(&p+1));
```
- &p[0] + 1是b的**地址**，是地址就是`4/8`个字节
```c
printf("%d\n", sizeof(&p[0]+1));
```

**32位下：**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a0b65aac515c4f319bcefae0b331b517.png)



**64位下：**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/de0062b94d744398837882c1561be43b.png)



**我们再来换成strlen：**

```c
char *p = "abcdef";
printf("%d\n", strlen(p));
printf("%d\n", strlen(p+1));
printf("%d\n", strlen(*p));
printf("%d\n", strlen(p[0]));
printf("%d\n", strlen(&p));
printf("%d\n", strlen(&p+1));
printf("%d\n", strlen(&p[0]+1));
```



- p指向这个字符串的首元素地址，字符串中有\0，从a的**地址开始向后访问**，结果就是`6`

```c
printf("%d\n", strlen(p));
```

- p的类型是`char*`，`+1`跳过的就是一个char类型的数据，所以就来到了**字符`'b'`的地址处**，向后找\0的话就最后的结果即为 `5`
```c
printf("%d\n", strlen(p+1));
```
- `*p`取到的就是字符`'a'`，strlen就会把字符**a的ascll码值当地址传过去了**，会产生非法访问，结果是`err`
```c
printf("%d\n", strlen(*p));	
```
- 这个和上一个一样，也是会产生**非法访问**，就相当于 ` *p == *(p+0) == p[0]`
```c
printf("%d\n", strlen(p[0]));
```
- 这个结果就是随机值，&p是p的地址，类型是`char*`从**p所占空间的起始位置开始查找的**，它不知道什么时候会遇到`\0`，所以就会是`随机值`
```c
printf("%d\n", strlen(&p));
```
- 这个代码在`&`取地址后它的类型就变成了`char**`，`+1`会跳过一个`char*`类型的数据，它指向了**字符串末尾的这个位置**，从这里向后去进行找`\0`,也是不知道什么时候会遇到，所以最后的结果还是`随机值`
```c
printf("%d\n", strlen(&p+1));
```
- 这里和第二个很相似，&和[]就相当于抵消了，**+1就指向了`'b'`**，结果也就是`5`
```c
printf("%d\n", strlen(&p[0]+1));
```

- 最后我们来看一下结果~~
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7663a7e2892e4c90a1b508c666210c1f.png)


------


>最后我们再来看二维数组，也是比较难的一部分，这里一定要认真看~~
### 2.3 二维数组

```c
int a[3][4] = {0};
printf("%d\n",sizeof(a));
printf("%d\n",sizeof(a[0][0]));
printf("%d\n",sizeof(a[0]));
printf("%d\n",sizeof(a[0]+1));
printf("%d\n",sizeof(*(a[0]+1)));
printf("%d\n",sizeof(a+1));
printf("%d\n",sizeof(*(a+1)));
printf("%d\n",sizeof(&a[0]+1));
printf("%d\n",sizeof(*(&a[0]+1)));
printf("%d\n",sizeof(*a));
printf("%d\n",sizeof(a[3]));
```

- sizeof(数组名)，计算的就是整个数组的大小，这是一个二维数组，数组**是三行四列**的，总共十二个元素，每个元素的类型是int，为4个字节，那么总的大小就是 `48`

```c
printf("%d\n", sizeof(a));
```
- a[0][0]代表的是数组**第一行第一列**的元素,所以每个元素都是`4`个字节

```c
printf("%d\n", sizeof(a[0][0]));
```
- `a[0]`为第一行的数组名，而且它是单独放在sizeof()内部的，计算的是**第一行这一整行**的大小，里面有4个元素，每个元素都是4个字节，那么结果即为`16`

```c
printf("%d\n", sizeof(a[0]));
```
- a[0]是第一行这个数组的数组名，但是数组名并非单独放在sizeof内部，所以数组名表示数组首元素的地址，也就是`a[0][0]`的地址，`a[0]+1`是第一行第二个元素`a[0][1]`的**地址**，是地址的大小是`4/8`个字节

```c
printf("%d\n", sizeof(a[0] + 1));
```
 - `a[0] + 1`是第一行第二个元素`a[0][1]`的地址，`*(a[0] + 1)`就是**第一行第二个元素**，大小是`4`个字节

```c
printf("%d\n", sizeof(*(a[0] + 1)));
```
- `a`没有单独放在sizeof内部，没有&，数组名a就是数组首元素的地址，也就是第一行的地址，`a+1`，就是第二行的**地址**，也就是等价于`a -- int(*)[4]` ---->`a+1 -- int(*)[4]`，是地址就是`4/8`
```c
printf("%d\n", sizeof(a + 1));
```

- 下面这个也就是对这一行解引用，那么也就得到了**第二行这一整行**，此时计算是这一整行的大小，结果为`16`

```c
printf("%d\n", sizeof(*(a + 1)));
```
- 这个和上一个一样，只是换了一种写法，等价于`*(a + 1) `，计算的是**第二行的元素大小**，结果是`16`

```c
printf("%d\n", sizeof(a[1]));
```
- a[0]为第一行的数组名，对它进行取地址就取到了这一整行的地址，它的类型也为一个数组指针int (*)[4]，那 `+1`的话也会跳过整个数组，此时也就来到了第二行，那么取到的便是第二行的**地址**，地址的大小即为 `4/8`个字节

```c
printf("%d\n", sizeof(&a[0] + 1));
```
---
- 这里和上面那个相似，**第二行解引用，算的是第二行元素的大小**，结果是`16`

```c
printf("%d\n", sizeof(*(&a[0] + 1)));
```
---
- 数组名a就是数组首元素的地址，也就是第一行的地址,`*a`就是一行的 等价于`*(a+0) == a[0]`，取到的就是第一行的**元素**，结果是`16`


```c
printf("%d\n", sizeof(*a));
```
-----

- 这个二维数组不是只有三行吗，第三行的数组名为a[2]，那a[3]不是**越界**了吗？

- 下面这个a[3]来说，虽然看上去存在越界，`sizeof()`并不关心你有没有越界，不会真实的访问，而是知道你的类型即可，a[3]便是二维数组的第四行，虽然没有第四行，但是类型是确定的，那么大小就是确定的，计算sizeof(数组名)计算的是**整个数组**的大小，结果便是`16`

```c
printf("%d\n", sizeof(a[3]));
```

----
- 我们来看一下运行结果~~

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/37df7c9cc640478885d4b5239dca4448.png)


**总结：**
数组名的意义：
1. sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小。
2. &数组名，这里的数组名表示整个数组，取出的是整个数组的地址。
3. 除此之外所有的数组名都表示首元素的地址。

## 指针笔试题

### 第一道：

```c
int main()
{
	int a[5] = { 1, 2, 3, 4, 5 };
	int *ptr = (int *)(&a + 1);
	printf( "%d,%d", *(a + 1), *(ptr - 1));
	return 0;
}
//程序的结果是什么？
```
- 首先a是在数组的首元素，然后&+1是跳过整个数组，到了5的后面，然后赋值给了ptr
- `*(a+1)`首先a是在数组的第一个元素，因为没有&，然后加1是跳过一个元素的大小，就来到了元素`2`的位置
- `*(ptr - 1) `ptr刚刚是到了5的后面，然后-1就指向了5，然后解引用就打印出`5`

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2c665bc4ce0b4a36a1c94f272e37ec15.png)

- 我们再来看一下结果

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7830d032aac0481e8e23e9d4b86218eb.png)




### 第二道：

```c
//由于还没学习结构体，这里告知结构体的大小是20个字节
//x86环境下
struct Test
{
	int Num;
	char *pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*p;
//假设p 的值为0x100000。 如下表表达式的值分别为多少？
//已知，结构体Test类型的变量大小是20个字节
int main()
{
	p = (struct Test*)0x100000;
	printf("%p\n", p + 0x1);
	printf("%p\n", (unsigned long)p + 0x1);
	printf("%p\n", (unsigned int*)p + 0x1);
	return 0;
}
```

- 首先我们要知道0x开头的数字是16进制的数字
-  `p + 0x1` 结构体指针+1是跳过一个结构体的大小`20`，是`0x100020`吗？不是，而是`0x100014`，因为这个是16进制的
- `(unsigned long)p + 0x1 `指针p强制类型转换成(unsigned long)，整形+1是加1结果是`0x100001`	
- `(unsigned int*)p + 0x1 `指针p强制类型转换成(unsigned int*)，整形指针+1跳过4个字节，结果是`0x100004`

- 最后我们需要以`%p`的形式打印出来，那么打印的是8个16进制打印出来
	- 第一个结果应该是`00100014`
	- 第二个结果应该是`00100001`
	- 第二个结果应该是`00100004`

- 我们开看一下结果：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4105ecd02cc0426986a45c1deb0a17a1.png)




### 第三道：

```c
int main()
{
	int a[4] = { 1, 2, 3, 4 };
	int *ptr1 = (int *)(&a + 1);
	int *ptr2 = (int *)((int)a + 1);
	printf( "%x,%x", ptr1[-1], *ptr2);
	return 0;
}
```

- 第一个`(int *)(&a + 1)` ，`&a+1`是取出整个地址+1,因为这个是数组类型，然后强制类型转换成了(int*)，赋值给了`ptr1`
- 然后我们看打印选项`ptr1[-1]`，这个就相当于`*(ptr1 - 1)`，然后就指向了`4`
- 那么我们第二个就要进行画图进行分析了，这里需要画出内存布局图，机器是小端存储

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f2c84a1973824286908847374963e632.png)

- 首先将a数组的地址强制类型转换成了`int`类型，然后加1，加的是内存中一个字节的位置，然后赋给了ptr2，ptr2是整形指针，向后访问4个字节，又因为是小端存储，打印是以`%x`打印的，所以结果是`2000000`


我们来看一下结果：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9714ec7f61614e5aac0b68073e18bcd1.png)


### 第四道：

```c
#include <stdio.h>
int main()
{
	int a[3][2] = { (0, 1), (2, 3), (4, 5) };
	int *p;
	p = a[0];
	printf( "%d", p[0]);
	return 0;
}
```

- 首先我我们要注意这个二维数组的初始化里面的扩话，是小括号，而不是大括号，里面是逗号表达式
- 然后a[0] == &a[0][0]，也就是第一行的地址 
- 打印的时候是`p[0]`也就是`*(p+0)`，+0就相当于没加，结果打印的就是1

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e4cf9386403e4d679119f57f79d83f10.png)

**我们来看一下结果：**



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2c30fed119f54c4795e4d205ca8d5090.png)

### 第五道：

```c
int main()
{
	int a[5][5];
	int(*p)[4];
	p = a;
	printf( "%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	return 0;
}
```

- 首先定义了一个五行五列的二维数组，还定义了一个数组指针，这个数组指针指向了有4个元素，每个元素是int类型，然后将a赋值给了p
- p+1是跳过4个元素，p+4就来到了第三行
- 我们这里是小地址减去了大地址，得到的是元素与元素之间的个数，得到的是负数`-4`


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6029ff1f846b44ce87237f63a0255728.png)

- `-4`以%p的方式打印，认为内存中存储的补码就是地址 ，结果是`FFFFFFFC`


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/aad9e68b15704392a4790a295fbd0dd8.png)


我们来验证一下结果：
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/83518e61ca4249aeb4b79ea1cddc2ea2.png)




### 第六道：

```c
int main()
{
	int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int *ptr1 = (int *)(&aa + 1);
	int *ptr2 = (int *)(*(aa + 1));
	printf( "%d,%d", *(ptr1 - 1), *(ptr2 - 1));
	return 0;
}
```
- 首先我们定义了一个二维数组
- 取地址aa数组是取出了整个二维数组的地址，然后+1，是跳过整个数组，强制类型转换成了整形赋值给了`ptr1`，然后我们看ptr1-1，就是减去了一个整形，然后解引用就找到了`10`

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4c8cee1a75054f87b9394da8db66cc37.png)


- 我们再来看第二个，aa+1是加到了第二行，再解引用就找到了，也就等价于`a[1]`，指向了6，这里的强制类型转换是迷惑，不会发生什么作用的，赋值给了ptr2
- 然后ptr2-1就减去一个整形，就得到了5

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c4fb835d3b014c459bfb4fc67a424f40.png)


我们来验证一下结果：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/dc7a59a199d040359fc46211ab141380.png)




### 第七道：

```c
#include <stdio.h>
int main()
{
	char *a[] = {"work","at","alibaba"};
	char**pa = a;
	pa++;
	printf("%s\n", *pa);
	return 0;
}
```
- 首先定义了一个指针数组，里面放了三个字符串，每个元素是char*，每个元素都保存着字符串的首字母
- 然后还有一个二级指针，然后pa++，原来的pa是指向了数组的首地址，++就加了一个char类型，就访问到了`at`

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c93e8fc4eba1420b854845aa3925d00a.png)

我们来验证一下结果：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8946694b0be8413facf950045aec0e96.png)



### 第八道【压轴题】：

```c
int main()
{
	char *c[] = {"ENTER","NEW","POINT","FIRST"};
	char**cp[] = {c+3,c+2,c+1,c};
	char***cpp = cp;
	printf("%s\n", **++cpp);
	printf("%s\n", *--*++cpp+3);
	printf("%s\n", *cpp[-2]+3);
	printf("%s\n", cpp[-1][-1]+1);
	return 0;
}
```




- 首先有一个**指针数组**分别存放了四个字符串的首字符地址
- 有一个**二级指针数组**存放了这个指针数组每一行的地址，仔细观察是倒着存放的
- 又有一个**三级字符指针**指向了**二级指针数组cp的首元素地址**，即**第一行**的地址

**我们来看一下下面的图片：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4adb750a97464a50ab5ce7c36dea203c.png)

-------


- 我们来看到第一个打印语句~~

```c
printf("%s\n", **++cpp);
```

- 首先 **++cpp**，cpp就会访问一个**char*类型**的元素，也就是这个cp数组的第二行，解引用就拿到了c+2这个地址，那么我们就可以顺着这个地址找到了c数组所在的这行地址，解引用就是拿到了c数组存放的内容，以%s打印结果就是`POINT`


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/75e89cb1a44341e0aeacbfd8c5d43ae9.png)

-----
**再来看第二句：**

```c
printf("%s\n", *--*++cpp+3);
```

- 首先执行++cpp，因为它的优先级最高，它就来到了cp数组的**第三个位置**，然后解引用，到了c+1的位置，接下来进行`--`，也就是c + 1 - 1 = c，这个时候里面就不再是`c + 1`这块地址，而是c这块地址，再对其进行**解引用，到了E所在的地址**，最后再 + 3即向后偏移3个字节也就是3个字符，就是E所在的位置，使用%s进行打印，便打印出了后面的`ER`

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7144aa918dfe455dae8940a33b8525a8.png)

----

**再来看第三句：**

```c
printf("%s\n", *cpp[-2]+3);
```
- 上面的表达式可以写成`* *(cpp - 2) + 3`，也就是cpp向前偏移2个`char**`的位置，就找到了cp这行地址中所存放的值为c + 3，这个地址保存着c这一行所在的地址，再**解引用**，就取到了F的地址，然后+3，打印出`ST`

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cbea333fb6484a0fa65b07c9022aad0f.png)

----

**最后来看最后一句：**
```c
printf("%s\n", cpp[-1][-1]+1);
```

- 上面的表达式可以写成`*(*(cpp - 1) - 1) + 1`，首先就是将cpp向前偏移一个`char**`的位置，然后解引用取到了**第二行**的内容c+2，然后再-1，为c+1，再**解引用**，就拿到了c+1中存放的内容，找到了N，然后最后面还有个+1，就找到了E，最后打印，结果位`EW`

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/61b69ba77b7a4bb184044e610a9727fc.png)


-----


- 最后，我们来验证一下结果！

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fce848171ba1462790d735e462613ba7.png)



