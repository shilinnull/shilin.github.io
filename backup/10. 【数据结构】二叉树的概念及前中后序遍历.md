## 一、树概念及结构

 下面内容来自[百度百科](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879?fr=ge_ala)


>- 二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个节点最多只能有两棵子树，且有左右之分 。
>- 二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个节点 。
>- 常见的树结构包括二叉树（Binary Tree）、二叉搜索树（Binary Search Tree）、AVL树、红黑树等。树的应用非常广泛，例如在数据库中的索引结构、文件系统的组织、图形算法中的优先队列等。



![在这里插入图片描述](https://img-blog.csdnimg.cn/3d99850f21c14570846c05454b01d2f5.png)

**注意：** 树形结构中，子树之间不能有交集，否则就不是树形结构


![在这里插入图片描述](https://img-blog.csdnimg.cn/5672f3d25fd1442caf7fb29e9c1150f3.png)


### 1.1 树的相关概念

>树（Tree）是一种重要的数据结构，它在计算机科学中被广泛应用。树是由节点（Node）和边（Edge）组成的集合，节点之间通过边相连。树的一个特点是它是一个层次结构，顶部的节点称为根节（Root），最底部的节点称为叶节点（Leaf），中间的节点称为内部节点（Internal Node）。


![在这里插入图片描述](https://img-blog.csdnimg.cn/2b54095329434e3fb493e7a11b364801.png)


>**节点的度：** 一个节点含有的子树的个数称为该节点的度； 如上图：A的为6
**叶节点或终端节点：** 度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点
**非终端节点或分支节点：** 度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
**双亲节点或父节点：** 若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点
**孩子节点或子节点：** 一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节点
**兄弟节点：** 具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点
**树的度：** 一棵树中，最大的节点的度称为树的度； 如上图：树的度为6
**节点的层次：** 从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
**树的高度或深度：** 树中节点的最大层次； 如上图：树的高度为4
**堂兄弟节点：** 双亲在同一层的节点互为堂兄弟；如上图：H、I互为兄弟节点
**节点的祖先：** 从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先
**子孙：** 以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
**森林：** 由m（m>0）棵互不相交的树的集合称为森林；


## 二、树的表示


- 有多种方法可以表示树，其中两种主要的表示方法是：儿子表示法（Child Representation）和父母表示法（Parent Representation）。此外，对于二叉树，还有更特定的表示方法，如数组表示法和链接表示法。

**儿子表示法（Child Representation）：**

- 在儿子表示法中，每个节点包含一个指向其所有子节点的指针。这种表示方法通常用于多叉树，其中一个节点可以有多个子节点。

```c
    A
   / \
  B   C
 / \
D   E
```


**父母表示法（Parent Representation）：**
- 在父母表示法中，每个节点包含一个指向其父节点的指针。这种表示方法通常用于树的深度优先遍历。

```cs
codeA -> NULL
B -> A
C -> A
D -> B
E -> B
```


### 2.2 树在实际中的运用（表示文件系统的目录树结构）


- 树结构在实际中广泛应用，而表示文件系统的目录树结构是树结构的一个典型应用之一。文件系统的目录结构可以很自然地用树来表示
- 比如学过`Linux`的同学就知道这个linux是一个树状结构，**根**就是`/`



![在这里插入图片描述](https://img-blog.csdnimg.cn/a50554a084e3422aa858c637ddaec4ad.png)

## 三、二叉树概念及结构

- 二叉树（Binary Tree）是一种特殊的树结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树的结构和性质使得它在计算机科学中有着广泛的应用。

### 3.1 二叉树的基本概念

- **节点（Node）：** 二叉树的基本单元，每个节点包含一个数据元素和指向左右两个子节点的指针。
- **根节点（Root）：** 二叉树的顶端节点，是树的起始点，没有父节点。
- **叶节点（Leaf）：** 没有子节点的节点称为叶节点，位于树的末端。
- **内部节点（Internal Node）：** 除了根和叶节点之外的节点，有至少一个子节点的节点称为内部节点。
- **子节点（Child）：** 一个节点的直接下层节点称为其子节点。
- **父节点（Parent）：** 一个节点的直接上层节点称为其父节点。
- **兄弟节点（Sibling）：** 具有相同父节点的节点称为兄弟节点。
- **深度（Depth）：** 一个节点到根节点的路径长度称为节点的深度，根节点的深度为0。
- **高度（Height）：** 一个节点到其最远叶节点的路径长度称为节点的高度，树的高度是根节点的高度。

### 3.2 二叉树的结构：

#### a. 满二叉树（Full Binary Tree）：

- 在满二叉树中，除了叶节点，每个节点都有两个子节点。所有叶节点都在同一层上。

```c
        1
      /   \
     2     3
    / \   / \
   4   5 6   7
```

#### b. 完全二叉树（Complete Binary Tree）：

- 在完全二叉树中，除了最后一层的叶节点外，其他层都是满的，且最后一层的叶节点都靠左排列。

```c
		1
      /   \
     2     3
    / \   /
   4   5 6
```

#### c. 二叉搜索树（Binary Search Tree，BST）：

- 在二叉搜索树中，每个节点的左子树都比该节点小，右子树都比该节点大，这使得查找、插入和删除等操作非常高效。

```c
	    4
      /   \
     2     6
    / \   / \
   1   3 5   7
```

## 四、二叉树的应用

1. **搜索和排序：** 二叉搜索树用于实现快速的搜索和排序操作。
2. **表达式树：** 用于表示数学表达式，方便进行求值。
3. **文件系统：** 用于表示文件目录的层次结构。
4. **编译器：** 在语法分析阶段，使用语法树（通常是二叉树）表示程序的语法结构。
5. **哈夫曼树：** 用于数据压缩算法中构建最优的编码树。
6. **游戏树：** 在博弈论中，用于表示游戏的决策树。


## 五、二叉树的性质


1. **每个节点最多有两个子节点：** 每个节点最多有两个子节点，左子节点和右子节点。
2. **每个节点有零个、一个或两个子节点：** 这意味着一个节点可以是叶节点（没有子节点）、有一个子节点，或者有两个子节点。
3. **左子树和右子树是有序的：** 对于二叉搜索树（BST），左子树中的每个节点的值都小于该节点的值，右子树中的每个节点的值都大于该节点的值。
4. **树的高度：** 树的高度是从根节点到最深叶节点的最长路径。一棵有n个节点的二叉树的高度最多为n，最少为log₂(n+1)。
5. **最后一层节点集中在左侧：** 在完全二叉树中，最后一层的节点从左到右排列，缺失的位置只会出现在最右边。
6. **满二叉树：** 一棵高度为h且有2^h - 1个节点的二叉树被称为满二叉树。
7. **完全二叉树：** 一棵有n个节点的二叉树，如果从根节点到倒数第二层是一棵满二叉树，最后一层的节点都集中在左侧，那么它就是一棵完全二叉树。
8. **节点的编号：** 对于一棵二叉树，可以给每个节点按照从上到下、从左到右的顺序进行编号，编号从1开始。如果一个节点的编号为i，则它的左子节点的编号为2i，右子节点的编号为2i+1。


## 六、二叉树的存储结构


### 6.1 顺序存储结构

- 在顺序存储结构中，使用数组来表示二叉树。具体的方式是按照从上到下、从左到右的顺序将二叉树的节点依次存储在数组中。如果一个节点的编号为i，则其左子节点的编号为2i，右子节点的编号为2i+1。


**例如：**

```c
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

- 对应的顺序存储结构为：

```c	
[1, 2, 3, 4, 5, 6, 7]
```

- 这里数组的索引从1开始，根节点对应索引1，而左子节点和右子节点的关系则按照 2i 和 2i+1 的规则排列。


![在这里插入图片描述](https://img-blog.csdnimg.cn/ea203dd2dc674aa3bee6e84f9f445cf2.png)



### 6.2 链式存储结构

- 在链式存储结构中，每个节点通过指针或引用指向其左子节点和右子节点。这样的存储结构更加直观，也更容易实现。节点的定义如下：


```c
struct TreeNode {
    int data; // 节点的数据
    TreeNode* left; // 指向左子节点的指针
    TreeNode* right; // 指向右子节点的指针
};
```

```c
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

每个节点的 `left` 和 `right` 指针分别指向其左子节点和右子节点。这种存储结构更直观，但相对于顺序存储结构，可能会占用更多的内存空间。

![在这里插入图片描述](https://img-blog.csdnimg.cn/1a3896a594df499ab7eea230d8cdfee0.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/9812fa64aebf4248bd6c0a4d0249d155.png)

```c
typedef int BTDataType;
// 二叉链
struct BinaryTreeNode
{
	struct BinTreeNode* _pLeft; // 指向当前节点左孩子
	struct BinTreeNode* _pRight; // 指向当前节点右孩子
	BTDataType _data; // 当前节点值域
}
// 三叉链
struct BinaryTreeNode
{
	struct BinTreeNode* _pParent; // 指向当前节点的双亲
	struct BinTreeNode* _pLeft; // 指向当前节点左孩子
	struct BinTreeNode* _pRight; // 指向当前节点右孩子
	BTDataType _data; // 当前节点值域
}；
```



### 6.3 二叉树的顺序结构及实现


- 普通的二叉树是不适合用数组来存储的，因为可能会存在大量的空间浪费。而完全二叉树更适合使用顺序结构存储。现实中我们通常把堆(一种二叉树)使用顺序结构的数组来存储，需要注意的是这里的堆和操作系统虚拟进程地址空间中的堆是两回事，一个是数据结构，一个是操作系统中管理内存的一块区域分段。


![在这里插入图片描述](https://img-blog.csdnimg.cn/bda577f260e345c8ad39e2b27a7a38ee.png)



## 七、二叉树链式结构的实现
- 在学习二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。由于现在大家对二叉树结构掌握还不够深入，为了降低大家学习成本，此处手动快速创建一棵简单的二叉树，快速进入二叉树操作学习，等二叉树结构了解的差不多时，我们反过头再来研究二叉树真正的创建方式。


- 我们先回顾一下二叉树的概念：
>1. 空树
>2. 非空：根节点，根节点的左子树、根节点的右子树组成的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/60c277334c814db9b5c6c67541a71855.png)

>从概念中可以看出，二叉树定义是递归式的，因此后序基本操作中基本都是按照该概念实现的。



## 八、二叉树的遍历【重点】

### 8.1 前序、中序以及后序遍历

1. 前序遍历(Preorder Traversal 亦称先序遍历)——访问根结点的操作发生在遍历其左右子树之前。简单来说就是**访问顺序就是`根` `左子树` `右子树`**
3. 中序遍历(Inorder Traversal)——访问根结点的操作发生在遍历其左右子树之中（间）。简单来说就是**访问顺序就是 `左子树` `根` `右子树`**
4. 后序遍历(Postorder Traversal)——访问根结点的操作发生在遍历其左右子树之后。简单来说就是**访问顺序就是 `左子树`  `右子树` `根`**



>构建一棵树

```c
BTNode* BuyTreeNode(int x)
{
	BTNode*node = (BTNode*)malloc(sizeof(BTNode));
	assert(node);

	node->data = x;
	node->left = NULL;
	node->right = NULL;

	return node;
}

BTNode* CreateTree()
{
	BTNode* node1 = BuyTreeNode(1);
	BTNode* node2 = BuyTreeNode(2);
	BTNode* node3 = BuyTreeNode(3);
	BTNode* node4 = BuyTreeNode(4);
	BTNode* node5 = BuyTreeNode(5);
	BTNode* node6 = BuyTreeNode(6);

	node1->left = node2;
	node1->right = node4;
	node2->left = node3;
	node4->left = node5;
	node4->right = node6;

	return node1;
}
```
>二叉树的前序遍历

```c
void BinaryTreePrevOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("NULL ");
		return;
	}
	printf("%d ", root->data);
	BinaryTreePrevOrder(root->left);
	BinaryTreePrevOrder(root->right);
}
```

>二叉树中序遍历

```c
void BinaryTreeInOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("NULL ");
		return;
	}
	BinaryTreeInOrder(root->left);
	printf("%d ", root->data);
	BinaryTreeInOrder(root->right);
}
```
>二叉树后序遍历

```c
void BinaryTreePostOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("NULL ");
		return;
	}
	BinaryTreePostOrder(root->left);
	BinaryTreePostOrder(root->right);
	printf("%d ", root->data);
}
```

>测试

```c
int main()
{
	BTNode* root = CreateTree();

	printf("二叉树前序遍历:\n");
	BinaryTreePrevOrder(root);
	printf("\n");

	printf("二叉树中序遍历:\n");
	BinaryTreeInOrder(root);
	printf("\n");

	printf("二叉树后序遍历:\n");
	BinaryTreePostOrder(root);
	printf("\n");

	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/516bdb2b34134cbeb4977c7013f0314c.png)

