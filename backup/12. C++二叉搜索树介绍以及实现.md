## 二叉搜索树

### 二叉搜索树概念


- 二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:

	- 若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
	- 若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
	- 它的左右子树也分别为二叉搜索树




![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a9d67fd3c3914e179128d2004c1f734d.png)


### 二叉搜索树操作




![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3fc378ecb75e4ee5a940c98d1c1ee369.png)


```c
int a[] = {8, 3, 1, 10, 6, 4, 7, 14, 13};
```



1. 二叉搜索树的**查找**
a、从根开始比较，查找，比**根大则往右边走查找，比根小则往左边走查找**。
b、最多**查找高度次**，走到到空，还没找到，这个值不存在。

2. 二叉搜索树的**插入**
插入的具体过程如下：
a. 树为空，则直接新增节点，赋值给`root`指针
b. 树不空，按二叉搜索树性质查找插入位置，插入新节点



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/02727ff59e7f4ffcaea63750b0b2a111.png)


1. 二叉搜索树的删除

首先查找元素是否在二叉搜索树中，如果不存在，则返回, 否则要删除的结点可能分下面四种情况：

a. 要删除的结点无孩子结点
b. 要删除的结点只有左孩子结点
c. 要删除的结点只有右孩子结点
d. 要删除的结点有左、右孩子结点


看起来有待删除节点有4中情况，实际情况a可以与情况b或者c合并起来，因此真正的删除过程
如下：

- 情况b：删除该结点且使被删除节点的双亲结点指向被删除节点的左孩子结点--直接删除
- 情况c：删除该结点且使被删除节点的双亲结点指向被删除结点的右孩子结点--直接删除
- 情况d：在它的右子树中寻找中序下的第一个结点(关键码最小)，用它的值填补到被删除节点中，再来处理该结点的删除问题--替换法删除


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ae6a18f221204b438056eafe7d7fb20d.png)


## 二叉搜索树的实现


### 定义树节点
- 首先这个很简单，左右

```cpp
template<class K>
struct BSTreeNode
{
	BSTreeNode<K>* _left;
	BSTreeNode<K>* _right;
	K _val;

	BSTreeNode(const K& val)
		:_left(nullptr)
		, _right(nullptr)
		, _val(val)
	{}
};
template<class K>
class BSTree
{
	typedef BSTreeNode<K> Node;
public:

	Node* _root = nullptr;
};
```

### 插入

- 首先判断根节点是否为空，为空直接插入
- 然后定义一个前驱节点，再定义当前节点，然后找要插入的位置
- 如果`cur`比当前位置大往右走，比当前位置小往左走
- 最后还要判断要插入到左叶子还是右叶子，如果当前位置的值小于`val`，就当在左面（要满足搜索二叉树的性质），否则就右面

```cpp
bool Insert(const K& val)
{
	if (_root == nullptr) {
		_root = new Node(val);
		return true;
	}

	Node* parent = nullptr;
	Node* cur = _root;
	while (cur) 
	{
		// 提前保存cur的位置
		parent = cur;
		// 比当前位置大往右走，比当前位置小往左走
		if (cur->_val < val)
			cur = cur->_left;
		else if (cur->_val > val)
			cur = cur->_right;
		else
			return false;
	}
	// 走到这里说明找到合适的位置了
	cur = new Node(val);
	if (parent->_val < val)
		parent->_left = cur;
	else
		parent->_right = cur;

	return true;
}
```

### 删除一个节点


- 首先找值，如果当前位置比val小就往左走，如果当前位置比val大就往右走，没有找到返回`false`	
- 找到了后就删除，但是需要考虑几个问题
	- 左为空
	- 右为空
	- 左右都不为空

1. 左为空

- 情况一：左为空，那么就让parent的左连接到cur的右
- 情况二：cur等于根，那么直接让我的根成为根的右子树


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ac6e99c16cc5415d9ec013dc3892d8a8.png)


2. 右为空

和左为空原理一样
- 情况一：右为空，那么就让parent的左连接到cur的左
- 情况二：cur等于根，那么直接让我的根成为根的左	子树

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4d17568b3f564ea99811a6575fee4a88.png)


3. 左右都不为空

- 我们这里使用**替换法**
	- 找**左树的最大节点**或者**右子树的最小节点**


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d340db54b2304044926c680d5cfb2bae.png)


```cpp
bool Erase(const K& key)
{
	Node* parent = nullptr;
	Node* cur = _root;
	while (cur)
	{
		// 找val
		if (cur->_val < key)
		{
			parent = cur;
			cur = cur->_right;
		}
		else if (cur->_val > key)
		{
			parent = cur;
			cur = cur->_left;
		}
		else // 删除情况
		{
			// 准备删除
			if (cur->_left == nullptr)
			{//左为空
				if (cur == _root)
					_root = cur->_right;
				else
				{
					if (cur == parent->_left)
						parent->_left = cur->_right;
					else
						parent->_right = cur->_right;
				}

				delete cur;
			}
			else if (cur->_right == nullptr)
			{//右为空
				if (cur == _root)
					_root = cur->_left;
				else
				{
					if (cur == parent->_left)
						parent->_left = cur->_left;
					else
						parent->_right = cur->_left;
				}

				delete cur;
			}
			else
			{//左右都不为空
				// 右树的最小节点(最左节点)
				Node* parent = cur;
				Node* subLeft = cur->_right;
				while (subLeft->_left)
				{
					parent = subLeft;
					subLeft = subLeft->_left;
				}

				std::swap(cur->_val, subLeft->_val);

				if (subLeft == parent->_left)
					parent->_left = subLeft->_right;
				else
					parent->_right = subLeft->_right;

				delete subLeft;
			}
			return true;
		}
	}// (cur)end...
	return false;
}
```


### 查找
-  大于当前值往右走，小于往左走

```cpp
bool Find(const K& val)
{
	Node* cur = _root;
	while (cur){
		if (cur->_val < val)
			cur = cur->_left;
		else if (cur->_val > val)
			cur = cur->_right;
		else if(cur->_val == val)
			return true;
	}
	return false;
}
```


### 遍历节点


```cpp
void InOrder(Node* root)
{
	if (root == nullptr)
		return;
	_InOrder(root->_right);
	cout << root->_val << " ";
	_InOrder(root->_left);
}
```


## 递归版本&&全部代码


- 递归版本实现要注意的是要**引用传参**


```cpp
// 树的节点
template<class K>
struct BSTreeNode
{
	BSTreeNode<K>* _left;
	BSTreeNode<K>* _right;
	K _val;

	BSTreeNode(const K& val)
		:_left(nullptr)
		, _right(nullptr)
		, _val(val)
	{}
};

template<class K>
class BSTree
{
	typedef BSTreeNode<K> Node;
public:
	bool Insert(const K& val)
	{
		if (_root == nullptr) {
			_root = new Node(val);
			return true;
		}

		Node* parent = nullptr;
		Node* cur = _root;
		while (cur) 
		{
			// 提前保存cur的位置
			parent = cur;
			// 比当前位置大往右走，比当前位置小往左走
			if (cur->_val < val)
				cur = cur->_left;
			else if (cur->_val > val)
				cur = cur->_right;
			else
				return false;
		}
		// 走到这里说明找到合适的位置了
		cur = new Node(val);
		if (parent->_val < val)
			parent->_left = cur;
		else
			parent->_right = cur;

		return true;
	}

	bool Find(const K& val)
	{
		Node* cur = _root;
		while (cur){
			if (cur->_val < val)
				cur = cur->_left;
			else if (cur->_val > val)
				cur = cur->_right;
			else if(cur->_val == val)
				return true;
		}
		return false;
	}

	bool Erase(const K& key)
	{
		Node* parent = nullptr;
		Node* cur = _root;
		while (cur)
		{
			// 找val
			if (cur->_val < key)
			{
				parent = cur;
				cur = cur->_right;
			}
			else if (cur->_val > key)
			{
				parent = cur;
				cur = cur->_left;
			}
			else
			{
				// 准备删除
				if (cur->_left == nullptr)
				{//左为空
					if (cur == _root)
						_root = cur->_right;
					else
					{
						if (cur == parent->_left)
							parent->_left = cur->_right;
						else
							parent->_right = cur->_right;
					}

					delete cur;
				}
				else if (cur->_right == nullptr)
				{//右为空
					if (cur == _root)
						_root = cur->_left;
					else
					{
						if (cur == parent->_left)
							parent->_left = cur->_left;
						else
							parent->_right = cur->_left;
					}

					delete cur;
				}
				else
				{//左右都不为空
					// 右树的最小节点(最左节点)
					Node* parent = cur;
					Node* subLeft = cur->_right;
					while (subLeft->_left)
					{
						parent = subLeft;
						subLeft = subLeft->_left;
					}

					std::swap(cur->_val, subLeft->_val);

					if (subLeft == parent->_left)
						parent->_left = subLeft->_right;
					else
						parent->_right = subLeft->_right;

					delete subLeft;
				}
				return true;
			}
		}// (cur)end...
		return false;
	}

	void InOrder()
	{
		_InOrder(_root);
		std::cout << std::endl;
	}

	// ------------递归版本--------------

	void FindR(const K& val)
	{
		return _FindR(_root, val);
	}

	bool InsertR(const K& val)
	{
		return _InsertR(_root, val);
	}

	bool EraseR(const K& val)
	{
		return _EraseR(_root, val);
	}

private:
	// 这里也要注意是用引用
	bool _EraseR(Node*& root, const K& val)
	{
		if (root == nullptr)
			return false;

		if (root->_val < val)
			return _EraseR(root->_right, val);
		else if (root->_val > val)
			return _EraseR(root->_left, val);
		else
		{
			// 删除
			if (root->_left == nullptr)
			{
				Node* del = root;
				root = root->_right;
				delete del;

				return true;
			}
			else if (root->_right == nullptr)
			{
				Node* del = root;
				root = root->_left;
				delete del;

				return true;
			}
			else
			{
				// 找替代节点
				Node* subLeft = root->_right;
				while (subLeft->_left)
				{
					subLeft = subLeft->_left;
				}

				std::swap(root->_val, subLeft->_val);

				// 转换成在子树去递归删除
				return _EraseR(root->_right, val);
			}
		}
		return false;
	}

	bool _FindR(Node* root, const K& val)
	{
		if (root == nullptr)
			return false;
		if (root->_val < val)
			return _FindR(root->_right, val);
		else if (root->_val > val)
			return _FindR(root->_left, val);
		else
			return true;
	}
	// 这里注意是使用的引用
	bool _InsertR(Node*& root, const K& val)
	{
		if (root == nullptr)
		{
			root = new Node(val);
			return true;
		}

		if (root->_val < val)
			return _InsertR(root->_right, val);
		else if (root->_val > val)
			return _InsertR(root->_left, val);
		else
			return false;
	}

	void _InOrder(Node* root)
	{
		if (root == nullptr)
			return;

		_InOrder(root->_right);
		cout << root->_val << " ";
		_InOrder(root->_left);
	}
	
	Node* _root = nullptr;
};
```


## 二叉搜索树的性能分析


- 插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能。

- 对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二 叉搜索树的深度的函数，即结点越深，则比较次数越多。

- 但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树：


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/256428f34f0046d09fa07e244c6d92f1.png)

- 最优情况下，二叉搜索树为完全二叉树(或者接近完全二叉树)，其平均比较次数为：$log_2 N$
- 最差情况下，二叉搜索树退化为单支树(或者类似单支)，其平均比较次数为：$\frac{N}{2}$
- 问题：如果退化成单支树，二叉搜索树的性能就失去了。那能否进行改进，不论按照什么次序插入关键码，二叉搜索树的性能都能达到最优？ **AVL树**和**红黑树**就可以上场了。



## 完善二叉搜索树

### 释放节点
- 一样需要使用引用传参

```cpp
void Destory(Node*& root)
{
	if (root == nullptr)
		return;
	Destory(root->_left);
	Destory(root->_right);
	delete root;
	root = nullptr;
}
```

### 拷贝

- 递归拷贝左树和右树

```cpp
Node* Copy(Node* root)
{
	if (root == nullptr)
		return nullptr;

	Node* newRoot = new Node(_root->_val);
	newRoot->_left = Copy(root->_left);
	newRoot->_right = Copy(root->_right);

	return newRoot;
}
```

- 写完这个拷贝构造后我们需要写一个默认构造

```cpp
BSTree() = default;
```


### 赋值

```cpp
BSTree<K>& operator=(BSTree<K> t)
{
	swap(_root, t._root);
	return *this;
}
```


## 二叉搜索树的应用

1. **K模型**：K模型即只有key作为关键码，结构中只需要存储Key即可，关键码即为需要搜索到的值。
- 比如：给一个单词`word`，判断该单词是否拼写正确，具体方式如下：
	- 以词库中所有单词集合中的每个单词作为key，构建一棵二叉搜索树
	- 在二叉搜索树中检索该单词是否存在，存在则拼写正确，不存在则拼写错误。
2. **KV模型**：每一个关键码`key`，都有与之对应的值`Value`，即`<Key, Value>`的键值对。该种方式在现实生活中非常常见：
	- 比如英汉词典就是英文与中文的对应关系，通过英文可以快速找到与其对应的中文，英文单词与其对应的中文`<word, chinese>`就构成一种键值对；
	- 再比如统计单词次数，统计成功后，给定单词就可快速找到其出现的次数，单词与其出现次数就是`<word, count>`就构成一种键值对。


## 全部源码以及KV模型的实现

>BinarySearchTree.h

```cpp
#pragma once
#include<iostream>
namespace key
{
	// 树的节点
	template<class K>
	struct BSTreeNode
	{
		BSTreeNode<K>* _left;
		BSTreeNode<K>* _right;
		K _val;

		BSTreeNode(const K& val)
			:_left(nullptr)
			, _right(nullptr)
			, _val(val)
		{}
	};

	template<class K>
	class BSTree
	{
		typedef BSTreeNode<K> Node;
	public:
		bool Insert(const K& val)
		{
			if (_root == nullptr) {
				_root = new Node(val);
				return true;
			}

			Node* parent = nullptr;
			Node* cur = _root;
			while (cur)
			{
				// 提前保存cur的位置
				parent = cur;
				// 比当前位置大往右走，比当前位置小往左走
				if (cur->_val < val)
					cur = cur->_left;
				else if (cur->_val > val)
					cur = cur->_right;
				else
					return false;
			}
			// 走到这里说明找到合适的位置了
			cur = new Node(val);
			if (parent->_val < val)
				parent->_left = cur;
			else
				parent->_right = cur;

			return true;
		}

		bool Find(const K& val)
		{
			Node* cur = _root;
			while (cur) {
				if (cur->_val < val)
					cur = cur->_left;
				else if (cur->_val > val)
					cur = cur->_right;
				else if (cur->_val == val)
					return true;
			}
			return false;
		}

		bool Erase(const K& key)
		{
			Node* parent = nullptr;
			Node* cur = _root;
			while (cur)
			{
				// 找val
				if (cur->_val < key)
				{
					parent = cur;
					cur = cur->_right;
				}
				else if (cur->_val > key)
				{
					parent = cur;
					cur = cur->_left;
				}
				else
				{
					// 准备删除
					if (cur->_left == nullptr)
					{//左为空
						if (cur == _root)
							_root = cur->_right;
						else
						{
							if (cur == parent->_left)
								parent->_left = cur->_right;
							else
								parent->_right = cur->_right;
						}

						delete cur;
					}
					else if (cur->_right == nullptr)
					{//右为空
						if (cur == _root)
							_root = cur->_left;
						else
						{
							if (cur == parent->_left)
								parent->_left = cur->_left;
							else
								parent->_right = cur->_left;
						}

						delete cur;
					}
					else
					{//左右都不为空
						// 右树的最小节点(最左节点)
						Node* parent = cur;
						Node* subLeft = cur->_right;
						while (subLeft->_left)
						{
							parent = subLeft;
							subLeft = subLeft->_left;
						}

						std::swap(cur->_val, subLeft->_val);

						if (subLeft == parent->_left)
							parent->_left = subLeft->_right;
						else
							parent->_right = subLeft->_right;

						delete subLeft;
					}
					return true;
				}
			}// (cur)end...
			return false;
		}

		void InOrder()
		{
			_InOrder(_root);
			std::cout << std::endl;
		}

		// ------------递归版本--------------

		void FindR(const K& val)
		{
			return _FindR(_root, val);
		}

		bool InsertR(const K& val)
		{
			return _InsertR(_root, val);
		}

		bool EraseR(const K& val)
		{
			return _EraseR(_root, val);
		}

		~BSTree()
		{
			Destory(_root);
		}

		BSTree() = default;

		BSTree(const BSTree<K>& t)
		{
			_root = Copy(t._root);
		}

		BSTree<K>& operator=(BSTree<K> t)
		{
			swap(_root, t._root);

			return *this;
		}

	private:

		Node* Copy(Node* root)
		{
			if (root == nullptr)
				return nullptr;

			Node* newRoot = new Node(_root->_val);
			newRoot->_left = Copy(root->_left);
			newRoot->_right = Copy(root->_right);

			return newRoot;
		}


		void Destory(Node*& root)
		{
			if (root == nullptr)
				return;
			Destory(root->_left);
			Destory(root->_right);
			delete root;
			root = nullptr;
		}

		// 这里也要注意是用引用
		bool _EraseR(Node*& root, const K& val)
		{
			if (root == nullptr)
				return false;

			if (root->_val < val)
				return _EraseR(root->_right, val);
			else if (root->_val > val)
				return _EraseR(root->_left, val);
			else
			{
				// 删除
				if (root->_left == nullptr)
				{
					Node* del = root;
					root = root->_right;
					delete del;

					return true;
				}
				else if (root->_right == nullptr)
				{
					Node* del = root;
					root = root->_left;
					delete del;

					return true;
				}
				else
				{
					// 找替代节点
					Node* subLeft = root->_right;
					while (subLeft->_left)
					{
						subLeft = subLeft->_left;
					}

					std::swap(root->_val, subLeft->_val);

					// 转换成在子树去递归删除
					return _EraseR(root->_right, val);
				}
			}
			return false;
		}

		bool _FindR(Node* root, const K& val)
		{
			if (root == nullptr)
				return false;
			if (root->_val < val)
				return _FindR(root->_right, val);
			else if (root->_val > val)
				return _FindR(root->_left, val);
			else
				return true;
		}
		// 这里注意是使用的引用
		bool _InsertR(Node*& root, const K& val)
		{
			if (root == nullptr)
			{
				root = new Node(val);
				return true;
			}

			if (root->_val < val)
				return _InsertR(root->_right, val);
			else if (root->_val > val)
				return _InsertR(root->_left, val);
			else
				return false;
		}

		void _InOrder(Node* root)
		{
			if (root == nullptr)
				return;

			_InOrder(root->_right);
			std::cout << root->_val << " ";
			_InOrder(root->_left);
		}

		Node* _root = nullptr;
	};
}


namespace key_value
{
	// 树的节点
	template<class K, class V>
	struct BSTreeNode
	{
		BSTreeNode<K, V>* _left;
		BSTreeNode<K, V>* _right;
		K _val;
		V _value;

		BSTreeNode(const K& val, const V& value)
			:_left(nullptr)
			, _right(nullptr)
			, _val(val)
			, _value(value)
		{}
	};

	template<class K, class V>
	class BSTree
	{
		typedef BSTreeNode<K, V> Node;
	public:
		bool Insert(const K& val, const V& value)
		{
			if (_root == nullptr) {
				_root = new Node(val, value);
				return true;
			}

			Node* parent = nullptr;
			Node* cur = _root;
			while (cur)
			{
				// 提前保存cur的位置
				parent = cur;
				// 比当前位置大往右走，比当前位置小往左走
				if (cur->_val < val)
					cur = cur->_left;
				else if (cur->_val > val)
					cur = cur->_right;
				else
					return false;
			}
			// 走到这里说明找到合适的位置了
			cur = new Node(val, value);
			if (parent->_val < val)
				parent->_left = cur;
			else
				parent->_right = cur;

			return true;
		}

		Node* Find(const K& val)
		{
			Node* cur = _root;
			while (cur) {
				if (cur->_val < val)
					cur = cur->_left;
				else if (cur->_val > val)
					cur = cur->_right;
				else if (cur->_val == val)
					return cur;
			}
			return nullptr;
		}

		bool Erase(const K& key)
		{
			Node* parent = nullptr;
			Node* cur = _root;
			while (cur)
			{
				// 找val
				if (cur->_val < key)
				{
					parent = cur;
					cur = cur->_right;
				}
				else if (cur->_val > key)
				{
					parent = cur;
					cur = cur->_left;
				}
				else
				{
					// 准备删除
					if (cur->_left == nullptr)
					{//左为空
						if (cur == _root)
							_root = cur->_right;
						else
						{
							if (cur == parent->_left)
								parent->_left = cur->_right;
							else
								parent->_right = cur->_right;
						}

						delete cur;
					}
					else if (cur->_right == nullptr)
					{//右为空
						if (cur == _root)
							_root = cur->_left;
						else
						{
							if (cur == parent->_left)
								parent->_left = cur->_left;
							else
								parent->_right = cur->_left;
						}

						delete cur;
					}
					else
					{//左右都不为空
						// 右树的最小节点(最左节点)
						Node* parent = cur;
						Node* subLeft = cur->_right;
						while (subLeft->_left)
						{
							parent = subLeft;
							subLeft = subLeft->_left;
						}

						std::swap(cur->_val, subLeft->_val);

						if (subLeft == parent->_left)
							parent->_left = subLeft->_right;
						else
							parent->_right = subLeft->_right;

						delete subLeft;
					}
					return true;
				}
			}// (cur)end...
			return false;
		}

		void InOrder()
		{
			_InOrder(_root);
			std::cout << std::endl;
		}
	private:
		void _InOrder(Node* root)
		{
			if (root == nullptr)
				return;

			_InOrder(root->_right);
			std::cout << root->_val << ":" << root->_value << std::endl;
			_InOrder(root->_left);
		}

		Node* _root = nullptr;
	};
}
```

>BinarySearchTree.cpp

```cpp
#include"BinarySearchTree.h"

//int main()
//{
//	int a[] = { 8, 3, 1, 10, 6, 4, 7, 14, 13 };
//	key::BSTree<int> b;
//	for (auto e : a)
//	{
//		b.InsertR(e);
//	}
//	b.InOrder();
//	// 删除
//	b.EraseR(14);
//	b.InOrder();
//
//	b.EraseR(3);
//	b.InOrder();
//
//	b.EraseR(8);
//	b.InOrder();
//
//	for (auto e : a)
//	{
//		b.EraseR(e);
//		b.InOrder();
//	}
//
//	return 0;
//}


#include<string>

void TestBSTree1()
{
	// 输入单词，查找单词对应的中文翻译
	key_value::BSTree<std::string, std::string> dict;
	dict.Insert("string", "字符串");
	dict.Insert("tree", "树");
	dict.Insert("left", "左边、剩余");
	dict.Insert("right", "右边");
	dict.Insert("sort", "排序");
	// 插入词库中所有单词
	std::string str;
	while (std::cin >> str)
	{
		key_value::BSTreeNode<std::string, std::string>* ret = dict.Find(str);
		if (ret == nullptr)
		{
			std::cout << "单词拼写错误，词库中没有这个单词:" << str << std::endl;
		}
		else
		{
			std::cout << str << "中文翻译:" << ret->_value << std::endl;
		}
	}
}
void TestBSTree2()
{
	// 统计水果出现的次数
	std::string arr[] = { "苹果", "西瓜", "苹果", "西瓜", "苹果", "苹果", "西瓜","苹果", "香蕉", "苹果", "香蕉" };
	key_value::BSTree<std::string, int> countTree;
	for (const auto& str : arr)
	{
		// 先查找水果在不在搜索树中
		// 1、不在，说明水果第一次出现，则插入<水果, 1>
		// 2、在，则查找到的节点中水果对应的次数++
		//BSTreeNode<string, int>* ret = countTree.Find(str);
		auto ret = countTree.Find(str);
		if (ret == NULL)
		{
			countTree.Insert(str, 1);
		}
		else
		{
			ret->_value++;
		}
	}
	countTree.InOrder();
}


int main()
{
	TestBSTree1();
	TestBSTree2();

	return 0;
}
```
