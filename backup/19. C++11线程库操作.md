
## 线程库


###  thread类的简单介绍


- 在C++11之前，涉及到多线程问题，都是和平台相关的，比如windows和linux下各有自己的接 口，这使得代码的可移植性比较差。C++11中最重要的特性就是对线程进行支持了，使得C++在并行编程时不需要依赖第三方库，而且在原子操作中还引入了原子类的概念。要使用标准库中的线程，必须包含`<thread>`头文件。[C++11中线程类](https://legacy.cplusplus.com/reference/thread/thread/)


| 函数名                        | 功能                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| thread()                      | 构造一个线程对象，没有关联任何线程函数，即没有启动任何线程   |
| thread(fn, args1, args2, ...) | 构造一个线程对象，并关联线程函数fn，args1，args2，...为线程函数的 参数 |
| get_id()                      | 获取线程id                                                   |
| joinable()                    | 线程是否还在执行，joinable代表的是一个正在执行中的线程。     |
| join()                        | 该函数调用后会阻塞住线程，当该线程结束后，主线程继续执行     |
| detach()                      | 在创建线程对象后马上调用，用于把被创建线程与线程对象分离开，分离 的线程变为后台线程，创建的线程的"死活"就与主线程无关 |


1. 线程是操作系统中的一个概念，线程对象可以关联一个线程，用来控制线程以及获取线程的状态。 

2. 当创建一个线程对象后，没有提供线程函数，该对象实际没有对应任何线程。

	- `get_id()`的返回值类型为id类型，id类型实际为`std::thread`命名空间下封装的一个类，该类中包含了一个结构体：


```cpp
#include <thread>

using namespace std;
int main()
{
	std::thread t1;
	cout << t1.get_id() << endl;
	return 0;
}
```

3. 当创建一个线程对象后，并且给线程关联线程函数，该线程就被启动，与主线程一起运行。 线程函数一般情况下可按照`函数指针` `lambda表达式` `函数对象`

```cpp
void ThreadFunc(int a)
{
	cout << "Thread1" << a << endl;
}
class TF
{
public:
	void operator()()
	{
		cout << "Thread3" << endl;
	}
};
int main()
{
	// 线程函数为函数指针
	thread t1(ThreadFunc, 10);
	// 线程函数为lambda表达式
	thread t2([] {cout << "Thread2" << endl; });
	// 线程函数为函数对象
	TF tf;
	thread t3(tf);
	t1.join();
	t2.join();
	t3.join();
	cout << "Main thread!" << endl;
	return 0;
}
```

4. thread类是防拷贝的，不允许拷贝构造以及赋值，但是可以移动构造和移动赋值，即将一个线程对象关联线程的状态转移给其他线程对象，转移期间不意向线程的执行。

```cpp
void ThreadFunc(int a)
{
	cout << "Thread" << a << endl;
}

int main()
{
	thread t1(ThreadFunc,1);
	//thread t2(t1); // 报错
	thread t2(std::move(t1));
	t2.join();// 交给t2join

	return 0;
}
```




![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/289cf316fdf14074b7e6702496cca018.png)



5. 可以通过`jionable()`函数判断线程是否是有效的，如果是以下任意情况，则线程无效


- 采用无参构造函数构造的线程对象 
- 线程对象的状态已经转移给其他线程对象 
- 线程已经调用`jion`或者`detach`结束


### 并发与并行的区别？

## 线程函数参数


- 线程函数的参数是以值拷贝的方式拷贝到线程栈空间中的，因此：即使线程参数为引用类型，在线程中修改后也不能修改外部实参，因为其实际引用的是线程栈中的拷贝，而不是外部实参。


```cpp
void ThreadFunc1(int& x)
{
	x += 10;
}
void ThreadFunc2(int* x)
{
	*x += 10;
}
int main()
{
	int a = 10;
	// 在线程函数中对a修改，不会影响外部实参，因为：线程函数参数虽然是引用方式，但其实际引用的是线程栈中的拷贝
	thread t1(ThreadFunc1, a);
	t1.join();
	cout << a << endl;

	// 如果想要通过形参改变外部实参时，必须借助std::ref()函数
	thread t2(ThreadFunc1, std::ref(a));
	t2.join();
	cout << a << endl;

	// 地址的拷贝
	thread t3(ThreadFunc2, &a);
	t3.join();
	cout << a << endl;
	return 0;
}
```


- 也还可以创建多个线程

```cpp
#include <vector>
#include <string>

void Print(size_t n, const string& s)
{
	for (size_t i = 0; i < n; i++)
	{
		cout << this_thread::get_id() << s << ":" << i << endl;
	}
}

int main()
{
	size_t n;
	cin >> n;

	//创建n个线程执行Print
	vector<thread> vthd(n);
	size_t j = 0;
	for (auto& thd : vthd)
	{
		// 移动赋值
		thd = thread(Print, 10,  "线程" + to_string(j++));
	}

	for (auto& thd : vthd)
	{
		thd.join();
	}

	return 0;
}
```


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/476c3470a5bc45dab697d228e8a27477.png)




```cpp
#include <mutex>

int main()
{
	int n1 = 0;
	int n2 = 0;
	cin >> n1 >> n2;
	mutex mtx;

	int x = 0;
	thread t1([n1, &x,&mtx]()
		{
			for (size_t i = 0; i < n1; i++)
			{
				mtx.lock();
				++x;
				mtx.unlock();
			}
		});

	thread t2([n2, &x, &mtx]()
		{
			for (size_t i = 0; i < n2; i++)
			{
				mtx.lock();
				++x;
				mtx.unlock();
			}
		});

	t1.join();
	t2.join();
	cout << x << endl;

	return 0;
}
```


- 必须访问临界资源的地方全部加锁，才能保证数字的不错乱


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ba64271b08dc4e42917fe67337269726.png)




- 如果其中一个不加锁就会导致数据的错乱

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3e0f0747220d45c2a642c12c1546ca69.png)

---


- 在传参的时候需要加`ref()`


```cpp
void Print1(size_t n, const string& s, mutex& m, int& rx)
{
	for (size_t i = 0; i < n; i++)
	{
		m.lock();

		cout << this_thread::get_id() << s << ":" << i << endl;
		++rx;

		m.unlock();

		this_thread::sleep_for(chrono::milliseconds(300));
	}
}

int main()
{
	mutex mtx;
	int x = 0;
	// 这里的参数首先是传给构造，然后再传给Print1，所以要加ref()
	thread t1(Print1, 100, "Thread 1", ref(mtx), ref(x));
	thread t2(Print1, 200, "thread 2", ref(mtx), ref(x));

	cout << "线程1：" << t1.get_id() << endl;
	cout << "线程2：" << t2.get_id() << endl;

	t1.join();
	t2.join();

	cout << x << endl;

	return 0;
}
```


## 原子性操作库(atomic)

- 多线程最主要的问题是共享数据带来的问题(即线程安全)。如果共享数据都是只读的，那么没问题，因为只读操作不会影响到数据，更不会涉及对数据的修改，所以所有线程都会获得同样的数据。但是，当一个或多个线程要修改共享数据时，就会产生很多潜在的麻烦。

- 在C++11中，程序员不需要对原子类型变量进行加锁解锁操作，线程能够对原子类型变量互斥的访问

- 更为普遍的，程序员可以使用atomic类模板，定义出需要的任意原子类型。


```cpp
atmoic<T> t; // 声明一个类型为T的原子类型变量t
```

- 注意：原子类型通常属于"资源型"数据，多个线程只能访问单个原子类型的拷贝，因此在C++11 中，原子类型只能从其模板参数中进行构造，不允许原子类型进行拷贝构造、移动构造以及 operator=等，为了防止意外，标准库已经将atmoic模板类中的拷贝构造、移动构造、赋值运算符重载默认删除掉了。

```cpp
#include <atomic>
int main()
{
	size_t n1 = 10000000;
	size_t n2 = 10000000;
	mutex mtx;

	// size_t x = 0;	  // 不是原子的
	atomic<size_t> x = 0; // 使用atomic是原子的
	thread t1([&]() {
			for (size_t i = 0; i < n1; i++)
			{
				++x;
			}
		});

	thread t2([&]() {
			for (size_t i = 0; i < n2; i++)
			{
				++x;
			}
		});

	t1.join();
	t2.join();

	cout << x << endl;
	// printf("%d\n", x);		// 无法打印
	printf("%d\n", x.load());

	return 0;
}
```


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/ccadfc00cd7d4e018034ce35137d87f0.png)

### CAS操作


- 比如模拟实现一个CAS操作：

```cpp
int main()
{
	size_t n1 = 10000;
	size_t n2 = 10000;
	mutex mtx;

	atomic<size_t> x = 0;
	thread t1([&]() {
			for (size_t i = 0; i < n1; i++)
			{
				size_t old, newval;
				do
				{
					old = x;
					newval = old + 2;
				} while (!atomic_compare_exchange_weak(&x, &old, newval));
			}
		});

	thread t2([&]() {
			for (size_t i = 0; i < n2; i++)
			{
				size_t old, newval;
				do
				{
					old = x;
					newval = old++; // 相当于operator++
					//newval = old + 2; // +2 也是可以的
				} while (!atomic_compare_exchange_weak(&x, &old, newval));
			}
		});

	t1.join();
	t2.join();

	cout << x << endl;

	return 0;
}
```

## lock_guard与unique_lock

- 在多线程环境下，如果想要保证某个变量的安全性，只要将其设置成对应的原子类型即可，即高效又不容易出现死锁问题。但是有些情况下，我们可能需要保证一段代码的安全性，那么就只能通过锁的方式来进行控制。

- 比如：一个线程对变量number进行加一100次，另外一个减一100次，每次操作加一或者减一之 后，输出number的结果，要求：number最后的值为0。


```cpp
#include <thread>
#include <mutex>
int number = 0;
mutex g_lock;
int ThreadProc1()
{
	for (int i = 0; i < 100; i++)
	{
		g_lock.lock();
		++number;
		cout << "thread 1 :" << number << endl;
		g_lock.unlock();
	}
	return 0;
}
int ThreadProc2()
{
	for (int i = 0; i < 100; i++)
	{
		g_lock.lock();
		--number;
		cout << "thread 2 :" << number << endl;
		g_lock.unlock();
	}
	return 0;
}


int main()
{
	thread t1(ThreadProc1);
	thread t2(ThreadProc2);
	t1.join();
	t2.join();
	cout << "number:" << number << endl;
	return 0;
}
```



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c822214dcbbf48319250ef0654efabfe.png)


- 上述代码的缺陷：锁控制不好时，可能会造成死锁，最常见的比如在锁中间代码返回，或者在锁的范围内抛异常。因此：C++11采用RAII的方式对锁进行了封装，即`lock_guard`和`unique_lock`。


## mutex的种类

在C++11中，Mutex总共包了四个互斥量的种类：


1. std::mutex
- C++11提供的最基本的互斥量，该类的对象之间不能拷贝，也不能进行移动。`mutex`最常用的三个函数：

| 函数名        | 函数功能                                                     |
| ------------- | ------------------------------------------------------------ |
| lock() 上锁   | 锁住互斥量                                                   |
| unlock() 解锁 | 释放对互斥量的所有权                                         |
| try_lock()    | 尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞 |

- 注意，线程函数调用lock()时，可能会发生以下三种情况：
	- 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁
	- 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住
	- 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)

- 线程函数调用try_lock()时，可能会发生以下三种情况：


- 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用`unlock`释放互斥量
- 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉
- 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)

2. std::recursive_mutex

其允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，
释放互斥量时需要调用与该锁层次深度相同次数的`unlock()`，除此之外，`std::recursive_mutex`的特性和 `std::mutex`大致相同。


3. std::timed_mutex

- 比 std::mutex 多了两个成员函数，`try_lock_for()`，`try_lock_until()` 。

- try_lock_for()
	- 接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与
	`std::mutex 的 try_lock()` 不同，`try_lock` 如果被调用时没有获得锁则直接返回
	false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超
	时（即在指定时间内还是没有获得锁），则返回 `false`。
- try_lock_until()
	- 接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，
	如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指
	定时间内还是没有获得锁），则返回 `false`。

4. std::recursive_timed_mutex

### lock_guard

[文档](https://legacy.cplusplus.com/reference/mutex/lock_guard/?kw=lock_guard)


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2a35371073254cd8ae8436ce08d303d4.png)


- lock_guard类模板主要是通过RAII的方式，对其管理的互斥量进行了封装，在需要加锁的地方，只需要用上述介绍的任意互斥体实例化一个`lock_guard`，调用构造函数成功上锁，出作用域前，`lock_guard`对象要被销毁，调用析构函数自动解锁，可以有效避免死锁问题。

**lock_guard的缺陷**：太单一，用户没有办法对该锁进行控制，因此C++11又提供了`unique_lock`。

### unique_lock

- 与`lock_gard`类似，unique_lock类模板也是采用RAII的方式对锁进行了封装，并且也是以独占所有权的方式管理mutex对象的上锁和解锁操作，即其对象之间不能发生拷贝。在构造(或移动(move)赋值)时，**unique_lock 对象需要传递一个 Mutex 对象作为它的参数**，新创建的unique_lock 对象负责传入的 Mutex 对象的上锁和解锁操作。使用以上类型**互斥量实例化unique_lock的对象**时，自动调用构造函数上锁，**unique_lock对象销毁时自动调用析构函数解锁**，可以很方便的防止死锁问题。

与lock_guard不同的是，unique_lock更加的灵活，提供了更多的成员函数：
- 上锁/解锁操作：`lock`、`try_lock`、`try_lock_for`、`try_lock_until`和`unlock`
- 修改操作：移动赋值、交换(swap：与另一个unique_lock对象互换所管理的互斥量所有权)、释放(release：返回它所管理的互斥量对象的指针，并释放所有权)
- 获取属性：owns_lock(返回当前对象是否上了锁)、operator bool()(与owns_lock()的功能相同)、mutex(返回当前unique_lock所管理的互斥量的指针)。

### 支持两个线程交替打印，一个打印奇数，一个打印偶数


- 用来进行线程之间的互相通知。`condition_variable`和`Linux posix`的条件变量并没有什么大的区别，主要还是面向对象实现的。


[condition_variable(条件变量)](https://legacy.cplusplus.com/reference/condition_variable/)


```cpp
#include <thread>
#include <mutex>
#include <condition_variable>
int main()
{
	std::mutex mtx;
	// 条件变量
	condition_variable c;
	int x = 1;

	// 标志默认为false
	bool flag = false;
	thread t1([&] {
			for (size_t i = 0; i < 10; i++)
			{
				// 使用unique_lock管理锁
				unique_lock<mutex> lock(mtx);
			
				// 如果flag == true就进行等待
				//if (flag)
				while (flag) // 使用while更保险
					c.wait(lock); // 在wait的时候会自动解锁

				// 必定第一次执行
				cout << "thread 1:" << this_thread::get_id() << ":" << x << endl;
				++x;

				// 执行一次后flag变为true，下次线程再来执行的时候就会进行等待
				flag = true;
				// 唤醒线程2
				c.notify_one();
			}
		});

	thread t2([&]{
			for (size_t i = 0; i < 10; i++)
			{
				// 使用unique_lock管理锁
				unique_lock<mutex> lock(mtx);

				// 如果flag == false就等待 true就开始执行下面的代码
				//if (!flag)
				while (!flag) // 使用while更保险
					c.wait(lock); // 在wait的时候会自动解锁

				cout << "thread 2:" << this_thread::get_id() << ":" << x << endl;
				++x;
				
				// 执行完成后改成false，如果线程2再来执行的时候就会进行等待
				flag = false;
				// 唤醒线程1
				c.notify_one();
			}
		}
	);

	t1.join();
	t2.join();

	return 0;
}
```

- 场景1：t1先启动，t2待定
	- 假设t1先运行，t1先抢到lock，flag是false，t1先打印，flag改成true

notetify没有线程等待，出作用域解锁

a：如果t2是在a状况，t1又抢到锁，但是flag为true，wait阻塞(unlock)

b：如果t2是在b状况，t1解锁，唤醒t2，t2获取到锁，falg是true，t2不会阻塞打印

- t2 两种状况：
	- a、没启动起来，或者没有分到时间片->t2总会开始开始运行，lock，flag是true，他不会wait t2打印值，flag 改成false，notify唤醒t1．后续就是类似交替走了
	- b、运行起来，lock阻塞

---

- 场景2：t2先启动，t1待定
t2先启动，t2会lock，wait (unlock)

	- t1两种状况:
a：没启动，或者没分到时间片。->t1总会分到时间片运行，lock，打印，flag改成true，然后notify t2。

- b：t1慢一步，但是也分到时间片开始执行了，t1 lock阻塞t2，wait时，unlock会唤醒t1获取锁保证t1先运行。


