
## 一、this指针的引出


- 我们先来定义一个日期类`Date`，下面这段代码执行的结果是什么呢？


```cpp
class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void print()
	{
		cout << _year << "-" << _month << "-" << _day << endl;
		
	}
private:
	int _year; 
	int _month; 
	int _day; 
};
int main()
{
	Date d1, d2;
	
	d1.Init(2022, 5, 11);
	d2.Init(2022, 5, 12);

	d1.print();
	d2.print();
	return 0;
}
```

- 可以看到分别打印出了**两个日期**，它是怎么知道改打印哪个的？

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6069c982dacd4e20840ca421e99ce0d1.png)


- 我们来分析一下，先看一下**汇编代码，看一看**


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/dba395b3dc58423b92fa5d0b44abdfcb.png)


----

- 我们看到上面的代码是调用的**同一个函数**，那么编译器是如何知道那两个日期的？

- 其实C++里有一个**隐含**的**this指针**，在[微软的官方文档](https://learn.microsoft.com/zh-cn/cpp/cpp/this-pointer?view=msvc-170)也有说明

- 在使用函数的时候其实里面**传了一个地址，然后有一个隐的this指针来接收**

---

>原形是这样：


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fcc3f5a320bb4692a65474ddce4eba88.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/da0b81f7cab34af0898930cb25b289a0.png)


- 那为什么这里**报错**了呢？
- 因为不必要写，这个是**隐含**的~~，我们可以**直接在类里面使用**



## 二、this指针的特性

- 刚刚上面也给你看了原形，细心的烙铁已经发现了，这个this指针是有一个**const修饰**的，而且这个const是在`*`的右边

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d561f02819e2498f9f842af479520663.png)


- 这里的`const`修饰，在`const`的右边

- 下面我们回忆一下~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/221ab0d8a51540be90c5c7d5ff12f0a7.png)

- 到这里就得出的**this本身是不被修改的，但是做指向的值是可以被修改**

- 我们可以在类中打印一下`this`指针的地址，再打印一下`d1`和`d2`的地址，我们来看一下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/26696d96afce46419aeca6760ef18445.png)

- 得到结果就是this指针指向一个指向**当前对象**的指针

---

- 我们还可以下面这样，是不会报错的，但是不能向上面直接在形参就写上

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f76630adebed4fdcbd84da92faaf531c.png)

特点：

**1、形参和实参的位置，我们不能显示写
2、函数内部可以使用**

---

- **最后总结一下：**

1. this指针的类型：类型 **\*const**，即成员函数中，**不能给this指针赋值**。
2. 只能在“**成员函数**”的内部使用
3. this指针本质上是“**成员函数**”的形参，当对象调用成员函数时，**将对象地址作为实参传递给this形参。所以对象中不存储this指针。**
4. this指针是**成员函数**第一个**隐含的指针形参**，一般情况由编译器通过**`ecx`寄存器**自动传递，不需要用户传递


### 【面试题】

1. this指针存在哪里？
>a、堆    b、栈    c、静态区    d、常量区    e、对象里面

- 首先排除`e`，因为我们知道，在算类里的**对象**的时候是没有算**this指针**的大小，所以**排除`e`**
- C++的**const**变量不是在常量区，可以看到这两个地址是挨着的

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7d7dd50f37844e27b5b071ed170834b7.png)

- 那么什么在常量区呢？是`const`修饰的值在常量区，这个指针变量在**栈区**，指向了这个**常量区的字符串的首字符**，所以`d`也就排除

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5b66f197b26646558c7f692f38662b79.png)

- **c就更不可能了**，static和全局的才在静态区
- **a也可以排除**，因为malloc的才在堆，这里不是malloc，所以排除

- 最后就是在栈上，因为**是一个形参**（有些编译比如vs可能会用寄存器存储）。不同的编译器放在不同的位置，可能是栈，也可能是寄存器，(VC++编译器是放在ECX中，其它编译器有可能不同，也就是成员函数的其它参数正常都是存放在栈中。而this指针参数则是存放在寄存器中。)

- 打开汇编我们也可以看到这里的lea就是**load effective address**【加载有效地址】，是存在`ecx`的值加载到 **[d1]** 里

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/0a6b7e0da754451a8468f311814ded3a.png)




2. this指针可以为空吗？

>下面我们来看两道题来解决这个问题的答案~

---

>第一道：下面程序编译运行结果是？ A、编译报错 B、运行崩溃 C、正常运行


```cpp
class A
{
public:
	void Print()
	{
		cout << "Print()" << endl;
	}
private:
	int _a;
};
int main()
{
	A* p = nullptr;
	p->Print();
	return 0;
}
```

- 已经**完美运行**了，因为我这里没有访问类里的对象，所以可以正常运行

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5070b89d560f4a0f851df1ad2f0ccb7f.png)

---


>第二道：下面程序编译运行结果是？ A、编译报错 B、运行崩溃 C、正常运行


```cpp
class A
{
public:
	void PrintA()
	{
		cout << _a << endl;
	}
private:
	int _a;
};

int main()
{
	A* p = nullptr;
	p->PrintA();
	return 0;
}
```

- 这里引发了**空指针**，因为我需要打印这里的`_a`，就要找到那块空间



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2fa0be8c18954b1a80656add9d303e04.png)

- 也就可以写成这样，**this指针是空指针**，解引用就会报错

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5470627570dc45d881eb24a3b817378a.png)

- 所以**this指针**是可以为空的，**只要在成员函数内部不访问其内容**，程序可以正常执行的。
