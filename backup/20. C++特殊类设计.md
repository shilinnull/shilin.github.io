## 请设计一个类，不能被拷贝


- 拷贝只会放生在两个场景中：**拷贝构造函数以及赋值运算符重载**，因此想要让一个类禁止拷贝， 只需让该类不能调用拷贝构造函数以及赋值运算符重载即可。


**C++98：**


```cpp
class CopyBan {
	// ...

private: 
	CopyBan(const CopyBan&); 
	CopyBan& operator=(const CopyBan&);
	//... 
};
```
原因： 
1. 设置成私有：如果只声明没有设置成private，用户自己如果在类外定义了，就可以不 能禁止拷贝了 
2. 只声明不定义：不定义是因为该函数根本不会调用，定义了其实也没有什么意义，不写 反而还简单，而且如果定义了就不会防止成员函数内部拷贝了。

**C++11：**

- C++11扩展delete的用法，delete除了释放new申请的资源外，如果在默认成员函数后跟上 `=delete`，表示让编译器删除掉该默认成员函数。


```cpp
class CopyBan {
CopyBan(const CopyBan&) = delete;
CopyBan& operator=(const CopyBan&) = delete;
};
```


## 请设计一个类，只能在堆上创建对象


**实现方式：** 

1. 将类的构造函数私有，拷贝构造声明成私有。防止别人调用拷贝在栈上生成对象。 
2. 提供一个静态的成员函数，在该静态成员函数中完成堆对象的创建

```cpp
class HeapOnly
{
public:
    static HeapOnly* CreateObject()
    {
        return new HeapOnly;
    }
private:
    HeapOnly() {}
    // C++98
    // 1.只声明,不实现。因为实现可能会很麻烦，而你本身不需要
    // 2.声明成私有
    HeapOnly(const HeapOnly&);
    
    // C++11    
    HeapOnly(const HeapOnly&) = delete;
};
```

## 请设计一个类，只能在栈上创建对象

- 方法一：同上将构造函数私有化，然后设计静态方法创建对象返回即可。

```cpp
class StackOnly
{
public:
	static StackOnly CreateObj()
	{
		return StackOnly();
	}
	// 禁掉operator new可以把下面用new 调用拷贝构造申请对象给禁掉
	// StackOnly obj = StackOnly::CreateObj();
	// StackOnly* ptr3 = new StackOnly(obj);
	void* operator new(size_t size) = delete;
	void operator delete(void* p) = delete;
private:
	StackOnly()
		:_a(0)
	{}
private:
	int _a;
};
```


##  请设计一个类，不能被继承

**C++98方式：**


- C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承


```cpp
class NonInherit
{
public:
	static NonInherit GetInstance()
	{
		return NonInherit();
	}
private:
	NonInherit()
	{}
};
```


**C++11方法：**
- `final`关键字，final修饰类，表示该类不能被继承。

```cpp
class NonInherit final
{
public:
	// ...
};
```


## 请设计一个类，只能创建一个对象(单例模式)

设计模式：
- 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的 总结。为什么会产生设计模式这样的东西呢？就像人类历史发展会产生兵法。最开始部落之间打 仗时都是人拼人的对砍。后来春秋战国时期，七国之间经常打仗，就发现打仗也是有套路的，后 来孙子就总结出了《孙子兵法》。孙子兵法也是类似。


- 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模 式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。


### 单例模式：
- 一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个 访问它的全局访问点，该实例被所有程序模块共享。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再 通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理。


单例模式有**两种**实现模式：


#### 饿汉模式：

- 饿汉模式:就是说不管你将来用不用，程序启动时就创建一个唯一的实例对象，提前(main函数启动时)创建好实例对象
	- **优点：实现简单**
	- **缺点：1、可能会导致进程启动慢、2、如果两个单例有启动先后顺序，那么饿汉无法控制**


```cpp
class A
{
public:
	static A * GetInstance()
	{
		return &_inst;
	}

	void Add(const string & key, const string & value)
	{
		_dict[key] = value;
	}

	void Print()
	{
		for (auto& kv : _dict)
		{
			cout << kv.first << ":" << kv.second << endl;
		}
		cout << endl;
	}
private:
	// 构造函数私有
	A()
	{}

	A(const A & aa) = delete;
	A& operator=(const A& aa) = delete;

	map<string, string> _dict;
	int _n = 0;

	static A _inst;
};

// 在程序入口之前就完成单例对象的初始化
A A::_inst;

int main()
{
	// 无法创建
	//A aa1;
	//A aa2;

	// 可以进行调用
	A::GetInstance()->Add("sort", "排序");
	A::GetInstance()->Add("left", "左边");
	A::GetInstance()->Add("right", "右边");
	A::GetInstance()->Print();

	// 拷贝构造禁止使用
	// A copy(*A::GetInstance());
	// copy.Print();
	// A::GetInstance()->Add("left", "剩余");
	// copy.Print();
	// A::GetInstance()->Print();

	// 赋值也无法使用
	// *A::GetInstance() = *A::GetInstance();

	return 0;
}
```

- 如果这个单例对象在多线程高并发环境下频繁使用，性能要求较高，那么显然使用饿汉模式来避 免资源竞争，提高响应速度更好。

#### 懒汉模式：


- 如果单例对象构造十分耗时或者占用很多资源，比如加载插件啊， 初始化网络连接啊，读取 文件啊等等，而有可能该对象程序运行时不会用到，那么也要在程序一开始就进行初始化， 就会导致程序启动时非常的缓慢。 所以这种情况使用懒汉模式（延迟加载）更好。


- **优点：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制。** 
- **缺点：复杂**


```cpp
class B
{
public:
	static B* GetInstance()
	{
		if (_inst == nullptr)
		{
			_inst = new B;
		}

		return _inst;
	}

	void Add(const string& key, const string& value)
	{
		_dict[key] = value;
	}

	void Print()
	{
		for (auto& kv : _dict)
		{
			cout << kv.first << ":" << kv.second << endl;
		}
		cout << endl;
	}

	static void DelInstance()
	{
		if (_inst)
		{
			delete _inst;
			_inst = nullptr;
		}
	}

private:
	B()
	{}

	~B()
	{
		// 持久化：要求把数据写到文件
		cout << "数据写到文件" << endl;
	}

	B(const B& aa) = delete;
	B& operator=(const B& aa) = delete;

	map<string, string> _dict;
	int _n = 0;
	static B* _inst;

	// 期望main函数结束后自动调用
	class gc
	{
	public:
		~gc()
		{
			DelInstance();
		}
	};
	static gc _gc;
};

B* B::_inst = nullptr;

// 期望main函数结束后自动调用
B::gc B::_gc;

int main()
{
	B::GetInstance()->Add("sort", "排序");
	B::GetInstance()->Add("left", "左边");
	B::GetInstance()->Add("right", "右边");
	B::GetInstance()->Print();

	B::GetInstance()->Add("right", "xxx");
	B::GetInstance()->Print();
	
	// 显示的调用释放
	B::DelInstance();
	cout << "xxxxxxxxxxx" << endl;

	return 0;
}
```

### 懒汉模式的线程安全问题

- 懒汉模式的线程安全问题已经在 **Linux多线程【线程互斥】** 中讲解：
	- 大概实现如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3255aa45a27844bfb380862c5280f68e.png)



- **局部的静态对象，是在第一次调用时初始化**
- C++11之前，他不是，也就说, C++11之前的编译器，那么这个代码不安全的
- C++11之后可以保证局部静态对象的初始化是线程安全的，只初始化一次

```cpp
class Singleton
{
public:
	// 提供获取单例对象的接口函数
	static Singleton& GetInstance()
	{
		// 局部的静态对象，是在第一次调用时初始化
		// C++11之前，他不是，也就说, C++11之前的编译器，那么这个代码不安全的
		// C++11之后可以保证局部静态对象的初始化是线程安全的，只初始化一次
		static Singleton inst;

		return inst;
	}

private:
	// 构造函数私有
	Singleton()
	{
		cout << "Singleton()" << endl;
	}
	// 防拷贝
	Singleton(const Singleton& s) = delete;
	Singleton& operator=(const Singleton& s) = delete;
};

int main()
{
	Singleton::GetInstance();
	return 0;
}
```

#### 工厂模式

- 用于创建对象的一个接口，让子类决定实例化哪个类

```cpp
class Product {
public:
    virtual void show() = 0;
};
 
class ConcreteProduct : public Product {
public:
    void show() override {
        std::cout << "ConcreteProduct Show" << std::endl;
    }
};
 
class Factory {
public:
    virtual Product* createProduct() = 0;
};
 
class ConcreteFactory : public Factory {
public:
    Product* createProduct() override {
        return new ConcreteProduct();
    }
};
```

#### 观察者模式

- 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象

```cpp
#include <iostream>
#include <list>
#include <string>
 
class Observer {
public:
    virtual void update(std::string message) = 0;
};
 
class ConcreteObserver : public Observer {
public:
    void update(std::string message) override {
        std::cout << "Received message: " << message << std::endl;
    }
};
 
class Subject {
private:
    std::list<Observer*> observers;
    std::string message;
 
public:
    void attach(Observer* observer) {
        observers.push_back(observer);
    }
 
    void notify() {
        for (auto observer : observers) {
            observer->update(message);
        }
    }
 
    void setMessage(std::string msg) {
        message = msg;
    }
};
 
int main() {
    Subject subject;
    Observer* observer = new ConcreteObserver();
    subject.attach(observer);
    subject.setMessage("Hello, World!");
    subject.notify();
    delete observer;
    return 0;
}
```

