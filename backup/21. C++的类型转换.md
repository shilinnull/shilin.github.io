## C语言中的类型转换


- 在C语言中，如果赋值运算符左右两侧类型不同，或者形参与实参类型不匹配，或者返回值类型与接收返回值类型不一致时，就需要发生类型转化，C语言中总共有两种形式的类型转换：隐式类型转换和显式类型转换。


1. **隐式类型转化**：编译器在编译阶段自动进行，能转就转，不能转就编译失败 
2. **显式类型转化**：需要用户自己处理


```cpp
int main()
{
	int i = 1;
	// 隐式类型转换
	double d = i;
	printf("%d, %.2f\n", i, d);
	int* p = &i;

	// 显示的强制类型转换
	int address = (int)p; 
	printf("%x, %d\n", p, address);

	return 0;
}
```
**缺陷：**
- 转换的可视性比较差，所有的转换形式都是以一种相同形式书写，难以跟踪错误的转换


## 为什么C++需要四种类型转


C风格的转换格式很简单，但是有不少缺点的： 

1. 隐式类型转化有些情况下可能会出问题：比如数据精度丢失
 2. 显式类型转换将所有情况混合在一起，代码不够清晰

因此C++提出了自己的类型转化风格，注意因为C++要兼容C语言，所以C++中还可以使用C语言的转化风格。

## C++强制类型转换


- 标准C++为了加强类型转换的可视性，引入了四种命名的强制类型转换操作符：

	- `static_cast`、`reinterpret_cast`、`const_cast`、`dynamic_cast`


## static_cast (静态转换)

- `static_cast`用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可用 `static_cast`，但它不能用于两个不相关的类型进行转换


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e80f02b5bd56440c9d87fd78f05028d3.png)



##  reinterpret_cast


- reinterpret_cast操作符通常为操作数的位模式提供较低层次的重新解释，用于将一种类型转换 为另一种不同的类型

```cpp
int main()
{
	double d = 3.14;
	int a = static_cast<int>(d);
	cout << a << endl;
	// 这里使用static_cast会报错，应该使用reinterpret_cast
	// int *p = static_cast<int*>(a);
	int* p = reinterpret_cast<int*>(a);

	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/118098bd3468472794d9cec6b5fae4d3.png)



## const_cast

- `const_cast`最常用的用途就是删除变量的const属性，方便赋值


- 这里编译器可能是对其作了优化，直接将const修饰的值放到了寄存器里，在读取的时候没有向内存中读，而修改的时候是修改的内存中的数据，所以是不一样的~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6d4d2b6a8f8749c29526a5caf6750015.png)

- 然而加上了`volatile`后，值一样了，但是a的地址又不一样了，这里可能是流插入的运算符捣的鬼，在匹配的时候匹配错了


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a3c8a25105f349c1ab32b06f66975c1f.png)

- 那么我分别使用C语言的`printf`和`cout`打印也是正常的：



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/da2225586cc546a4a286881478ab8f07.png)


- 在Linux平台下也是如此：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/87c1f434357b450585ee9e789b7d4bfe.png)




![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7459bd3f749743ad8c22f5d37c2f6587.png)


## dynamic_cast

- dynamic_cast用于将一个父类对象的指针/引用转换为子类对象的指针或引用(动态转换) 
- 向上转型：子类对象指针/引用->父类指针/引用(不需要转换，赋值兼容规则) 
- 向下转型：父类对象指针/引用->子类指针/引用(用dynamic_cast转型是安全的) 

注意： 
1. **dynamic_cast只能用于父类含有虚函数的类**
2. **dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回0**


```cpp
class A
{
public:
	virtual void f() {}
	int _a = 0;
};

class B : public A
{

public:
	int _b = 1;
};

//void fun(A* pa)
//{
//	// 向下转换：直接转换是不安全的
//	// 如果pa是指向父类A对象，存在越界问题
//	B* ptr = (B*)pa;
//	ptr->_a++;
//	ptr->_b++;
//}

// 解决方法：使用dynamic_cast
void fun(A* pa)
{
	B* ptr = dynamic_cast<B*>(pa);
	if (ptr)
	{
		ptr->_a++;
		ptr->_b++;
	}
	else
	{
		cout << "转换失败" << endl;
	}
}

int main()
{
	// 向下转换规则：父类对象不能转换成子类对象，但是父类指针和引用可以转换子类指针和引用
	B b1;
	A a;
	B b;
	fun(&a);
	fun(&b);

	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/07cf5fc419be43fe91ba4d0f30eecd96.png)


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7f5ae24046d740099466d972980bd266.png)




3. dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回0 注意 强制类型转换关闭或挂起了正常的类型检查，每次使用强制类型转换前，程序员应该仔细考虑是 否还有其他不同的方法达到同一目的，如果非强制类型转换不可，则应限制强制转换值的作用 域，以减少发生错误的机会。强烈建议：避免使用强制类型转换


## RTTI
- RTTI：Run-time Type identification的简称，即：运行时类型识别。
- C++通过以下方式来支持RTTI：
	- 1. typeid运算符
	- 2. dynamic_cast运算符
	- 3. decltype

## 其他类型转换小结

1. 内置类型之间，相近类型可以转换 
2. 构造函数，其他类型转换成自定义类型，有构造函数就可以支持
    - 自定义类型 <- 内置类型 
    - 自定义类型 <- 自定义类型
3. operator type()  内置类型 <- 自定义类型


```cpp
class C
{
public:
	C(int x)
	{}
};

class D
{
public:
	D(const C& c)
	{}
};

class E
{
public:
	operator int()
	{
		// ...
		return 0;
	}
};

int main()
{
	// 显示类型转换
	int* p = nullptr;
	int i = (int)p;

	// 自定义类型 <- 内置类型
	C c1 = 11;
	string s1 = "xxxx";

	// 自定义类型 <- 自定义类型
	D d = c1;

	// 内置类型 <- 自定义类型
	E e;
	int x = e;
	cout << x << endl;

	return 0;
}
```

