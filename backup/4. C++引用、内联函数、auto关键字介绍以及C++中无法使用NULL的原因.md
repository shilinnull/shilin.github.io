## 一、引用
### 1.1 引用概念

>C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用（reference）就是C++对C语言的重要扩充。引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：**类型标识符 &引用名=目标变量名；** -->[百度百科](https://baike.baidu.com/item/C++%E5%BC%95%E7%94%A8/463646)


- 这个引用就相当于是**别名**

```cpp
void TestRef()
{
	int a = 10;
	int& ra = a;//<====定义引用类型
	printf("%p\n", &a);
	printf("%p\n", &ra);
}
```

- **类型& 引用变量名(对象名) = 引用实体；**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/af1a937831ed489daed3bc072ce6d5da.png)

- 我们通过调试来看一下：


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2ca4f801b6604ee5b9eb6f8ad5add42d.png)



### 1.2 引用特性

1. 引用在定义时**必须初始化**
2. 一个变量可以有**多个引用**
3. 引用一旦**引用一个实体**，**再不能引用其他实体**


```cpp
void main()
{
	int a = 10;
	// int& ra; // 该条语句编译时会出错,必须要初始化
	int& ra = a;
	int& rra = a;

	printf("%p %p %p\n", &a, &ra, &rra);
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/edb73455e54d462cb866d27dd57496f7.png)




### 1.3 常引用
- 取别名不能放大权限

```cpp
int main()
{
	int a = 0;
	// 权限的缩小
	const int& c = a;
	
	const int x = 10;
	// 权限的放大
	int& y = x;
	return 0;
}
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/35657382c2a74bf7877d22d3a7f32a14.png)

- 可以这样写，相等的就可以

```cpp
const int x = 10;
const int y = x; 
```

- `a + x`的结果是一个临时变量，临时变量具有常性，`const`引用就可以
- `int& n = a + x;`的返回值是临时变量，**临时对象具有常性**，是一个权限放大


```cpp
int a = 0;
const int x = 10;
const int& z = 10;
const int& m = a + x; //这样写也可以
int& n = a + x; // 这样写不可以
```

- 这里**const加上**就可以将不同类型取别名
- 类型转换的时候会出现一个临时变量**，临时变量具有常性，所以就可以~**

```cpp
double d = 1.1;
int i = d; // 强制类型转换
int& ri = d; // 无法赋予，类型不同
const int& ri = d; // 加上const就可以了
```


>- **被引用的实体不能是常量**
>- **引用的类型必须相同**



### 1.4 使用场景

>引用有两个场景分别是做参数和做返回值

#### 1.4.1 做参数

- 做参数【在我们C语言阶段的时候使用函数交换两个变量的值就需要**传地址**过去，否则的话，形参只是实参的一份临时拷贝】

```cpp
void Swap(int* a, int* b)
{
	int tmp = *a;
	*a = *b;
	*b = tmp;
}
int main()
{
	int x = 0, y = 1;
	
	Swap(&x, &y);
	return 0;
}
```
- 而我们学了**引用**，这个时候就可以把指针替换下去了，使用引用作为参数

```cpp
void Swap(int& a, int& b)
{
	int tmp = a;
	a = b;
	b = tmp;
}

int main()
{
	int x = 0, y = 1;
	
	Swap(x, y);
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e7fc7e4b62a245c7a33de9b7e5830ea0.png)


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/68956c2f0513430ab5c5deba3743c3b1.png)

- 那么引用可以代替指针吗？【不可以！】
> 指针和引用的功能是类似的，有重叠的
C++的引用，**对指针使用比较复杂的场景进行一些替换**，让代码更简单易懂，但是不能完全替代指针
- 针引用不能完全替代指针原因：**引用定义后，不能改变指向**

>就比如说在数据结构中学的链表，指针需要改变指向，引用不能改变指向，这就是引用不能代替指针的原因

- 那`java`和`python`等其他语言有没有指针？-->**没有**
- 那他们的链表是怎么实现的呢？-->**引用**
- 本质上就是**引用可以改变指向**


-----

- 我们再来看一个案例，在我们学数据结构的时候单链表学习阶段
- 有这这么一段代码，这里的`pphead`必须要传二级指针，有点不好理解

```cpp
void PushBack(struct Node** pphead, int x)
{
	 *pphead = newnode;
}
int main()
{
	struct Node* plist = NULL;
	return 0;
}
```

- 而我们学了引用就可以这样写了，加上一个引用，也就是**phead是plist的一份临时拷贝**

```cpp
void PushBack(struct Node*& phead, int x)
{
	phead = newnode;
}

int main()
{
	struct Node* plist = NULL;

	return 0;
}
```
---

- 传值、传引用效率比较

- 我们这里可以测试一下性能，对比一下**传值、传引用**

```cpp
#include <time.h>

struct A { int a[10000]; };
void TestFunc1(A a) {}
void TestFunc2(A& a) {}

void main()
{
	A a;
	// 以值作为函数参数
	size_t begin1 = clock();
	for (size_t i = 0; i < 10000; ++i)
		TestFunc1(a);
	
    size_t end1 = clock();

	// 以引用作为函数参数
	size_t begin2 = clock();
	for (size_t i = 0; i < 10000; ++i)
		TestFunc2(a);
	
    size_t end2 = clock();

	// 分别计算两个函数运行结束后的时间
	cout << "TestFunc1(A)-time:" << end1 - begin1 << endl;
	cout << "TestFunc2(A&)-time:" << end2 - begin2 << endl;
}

```

- 可以看到**传值需要8毫秒**，而传**引用小于0毫秒**，小于0毫秒这里显示不出来，所以显示的0

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/66c7c94380f4437d8d797e1c81ed58e4.png)

- 那我再次测试一下**以引用作为函数的返回值类型**和**以值作为函数的返回值类型**的性能


```cpp
#include <time.h>
struct A { int a[10000]; };
A a;
// 值返回
A TestFunc1() { return a; }
// 引用返回
A& TestFunc2() { return a; }
void main()
{
	// 以值作为函数的返回值类型
	size_t begin1 = clock();
	for (size_t i = 0; i < 100000; ++i)
		TestFunc1();
	size_t end1 = clock();
	// 以引用作为函数的返回值类型
	size_t begin2 = clock();
	for (size_t i = 0; i < 100000; ++i)
		TestFunc2();
	size_t end2 = clock();
	// 计算两个函数运算完成之后的时间
	cout << "TestFunc1 time:" << end1 - begin1 << endl;
	cout << "TestFunc2 time:" << end2 - begin2 << endl;
}
```

- 这就不用我说了吧~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bccf0c62b1fb40649b8b79d5935e457c.png)


- **以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低**

---

#### 1.4.2做返回值

- 首先来看这段代码，这段代码是将a的值返回，然后ret接收，没有什么问题

```cpp
int func()
{
	int a = 0;
	return a;
}

int main()
{
	int ret = func();
	cout << ret << endl;

	return 0;
}
```

- 学了引用后，我们是不是可以这样

```cpp
int& func()
{
	int a = 0;
	return a;
}

int main()
{
	int ret = func();
	cout << ret << endl;
	return 0;
}
```
- 这里是报了一个**警告**，**返回局部变量或临时变量的地址**，那么这个程序的结果是什么？



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/aebcc52250274e44a195c96ec2cddc06.png)


- 我们以前说指针有野指针，那么引用也有**野引用**
- 上面的代码在`func`函数里是将a的别名返回了，函数调用完会销毁，**这里与函数的栈帧的创建与销毁有关**
- **在调用完函数后，那块空间会被销毁，然后再访问被销毁的地址，会造成野引用**
- 栈帧销毁的时候可能被清理，结果可能是**随机值**，但是在`vs`上是不清理的


我们可以证明一下：

```cpp
int& func()
{
	int a = 0;
	return a;
}

int& fx()
{
	int b = 1;
	return b;
}

int main()
{
	int& ret = func();
	cout << ret << endl;

	fx();
	cout << ret << endl;
	return 0;
}
```

- 在调用完一次后再次调用，栈帧大小是一样的，**会复用前面的空间**


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8db1eb1aa61d49b094927d3639c2d8db.png)

结论：**返回变量出了函数作用域生命周期就销毁了，不能用引用返回**

- 那什么情况下可以用引用返回呢？

>**全局变量**/**静态变量**/**堆**上的变量等就可以用引用返回


---

那么我这里举例用一个现实中的场景：

首先来看一下：

- 这里已经`c`和`c++`混着写了


```cpp
#include<assert.h>
// 升级成类了，直接就可以使用名字，不用typedef了
struct SeqList
{
	int* a;
	int size;
	int capacity;
};

void SLInit(SeqList& sl)
{
	sl.a = (int*)malloc(sizeof(int) * 4);
	// ..
	sl.size = 0;
	sl.capacity = 4;
}

void SLPushBack(SeqList& sl, int x)
{
	//...扩容
	sl.a[sl.size++] = x;
}

// 修改
void SLModity(SeqList& sl, int pos, int x)
{
	assert(pos >= 0);
	assert(pos < sl.size);

	sl.a[pos] = x;
}

int SLGet(SeqList& sl, int pos)
{
	assert(pos >= 0);
	assert(pos < sl.size);

	return sl.a[pos];
}

int main()
{
	SeqList s;
	SLInit(s);
	// 这里接收的是引用，所以我们就不需要取地址了
	SLPushBack(s, 1);
	SLPushBack(s, 2);
	SLPushBack(s, 3);
	SLPushBack(s, 4);

	for (int i = 0; i < s.size; i++)
	{
		cout << SLGet(s, i) << " ";
	}
	cout << endl;
	
	// 获取每偶数进行*2
	for (int i = 0; i < s.size; i++)
	{
		int val = SLGet(s, i);
		if (val % 2 == 0)
		{
			SLModity(s, i, val * 2);
		}
	}
	cout << endl;
	
	for (int i = 0; i < s.size; i++)
	{
		cout << SLGet(s, i) << " ";
	}
	cout << endl;
	return 0;
}
```

- 首先这里C++写有变化：


```cpp
struct SeqList
{
	// 成员变量
	int* a;
	int size;
	int capacity;

	// 成员函数
	void Init()
	{
		a = (int*)malloc(sizeof(int) * 4);
		// ...
		size = 0;
		capacity = 4;
	}

	void PushBack(int x)
	{
		// ... 扩容
		a[size++] = x;
	}
	// 读写返回变量
	// 临时变量具有常性
	// 所以必须返回引用，引用中间没有产生临时变量，是一个别名
	int& Get(int pos)
	{
		assert(pos >= 0);
		assert(pos < size);
	
		return a[pos];
	}
};

int main()
{
	SeqList s;
	s.Init();
	s.PushBack(1);
	s.PushBack(2);
	s.PushBack(3);
	s.PushBack(4);

	for (int i = 0; i < s.size; i++)
	{
		cout << s.Get(i)<< " ";
	}
	cout << endl;

	for (int i = 0; i < s.size; i++)
	{
		if (s.Get(i) % 2 == 0)
		{
			s.Get(i) *= 2;
		}
	}
	cout << endl;

	for (int i = 0; i < s.size; i++)
	{
		cout << s.Get(i) << " ";
	}
	cout << endl;

	return 0;
}
```

- 上面的代码C++首先将C语言的结构体升级成了类了，然后函数可以定义到类里面了，在使用的时候获取值就要注意一个点：必须返回引用，之前不是说不能用引用返回吗？这里就不一样了，这个`malloc`出来的空间，是在堆上的，所以可以返回，返回别名后，修改，修改别名也就是修改原来的地址...end


### 1.5 引用和指针的区别
- 对比区别的话，要从两个维度来对比，一个是**语法**，一个是**底层**，这两个不要混在一起了

>语法层面理解：

- 来看下面的这段代码：


```cpp
int main()
{
	int a = 10;
	int& ra = a;  // 语法不开空间，
	ra = 20;

	int* pa = &a; // 语法上开空间
	*pa = 20;

	return 0;
}
```

- 引用是别名，不开空间，指针是地址，需要开空间
- 这里我们上面都已经知道了~

#### 1.5.1 底层理解：

- 我们来看一下**汇编代码**



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1e5b3e1e9cc049fc81db396f41a9f3d3.png)

- 看到在底层是开空间的，**引用底层是指针实现的**
- 语法含义和底层实现是背离的

### 1.6 小结一下

**语法层面上：**
1. 引用是别名，不开空间，指针是地址，需要开空间
2. 引用必须初始化，指针可以初始化也可以不初始化
3. 引用不能改变指向，指针可以
4. 引用相对更安全，没有空引用，但是有空指针，容易出现野指针，但是不容易出现野引用
5. `sizeof` 、`++`、`解引用`访问等方面的区别

**底层层面上：【汇编】**
汇编层面上，没有引用，都是指针，引用编译后也转换成指针了




## 二、内联函数

### 2.1 内联的概念
>以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数调用建立栈帧的开销，内联函数提升程序运行的效率。


- 假设我要频繁调用100w次，建立100w个栈帧

```cpp
int Add(int a, int b)
{
	return a + b;
}
```
- c语言如何解决这个问题的？宏函数


```cpp
#define ADD(a, b) ((a)+(b))
```

- 核心点：**宏是预处理阶段进行替换**

**宏的缺点：**
1、语法复杂，坑很多，不容易控制
2、不能调试
3、没有类型安全的检查


- 这个时候C++就引入了一个概念**inline**，就是把函数的运算逻辑放到里面来，不进行建立栈帧

```cpp
inline int Add(int a, int b)
{
	return a + b;
}

int main()
{
	int ret1 = Add(1, 2) * 3;

	int x = 1, y = 2;
	int ret2 = Add(x | y, x & y);

	return 0;
}
```

- 如果在上述函数前增加`inline`关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用


查看方式：

1. 在release模式下，查看编译器生成的汇编代码中是否存在`call Add`
2. 在debug模式下，需要对编译器进行设置，否则不会展开(因为debug模式下，编译器默认不会对代码进行优化，下面是vs2022的设置)




![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/499e0d5c990e473d80c105ce6dbfe33d.png)


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/54a5aab8a1ad48d8a39948479b448260.png)


- 在不加内联的情况下

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/4258c33df0c6437aaeaa85935fd844bb.png)


- 添加了内联后，可以看到有很大的特别


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c730a001625a4d3c9cd1ff3f532c14e2.png)


- 我们再来看一个场景
- 就是分文件定义的时候，我就想在.h文件中定义一个函数


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8efcb97d938940b68af6e474dfc92663.png)

- 然而我在使用的时候两个文件都包含了这个头文件，在编译阶段链接的时候就会报链接错误，冲突的原因就是两个文件都会生成符号表，进行链接，有同名，会冲突因为是同一个函数，这咋办啊~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8989a7bb3472489082e7b4dc89b1deef.png)

>我们有三种解决方案：

**第一种就是声明和定义分离**
- 这个不多说，基本都会，之前我们用的都是这样的方法

**第二种方式就是static修饰函数，链接属性，只在当前文件可见**

- 在C语言阶段详细大家知道滴~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fbdc2b434bb1464fadf4b1cab9f214cf.png)

**第三种方式就是加入内联函数**

- 这里的内联函数相当于也就是**static**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/97d3341a6d7446858ec940593d39b282.png)

- 这里要注意，内联修饰的函数比较大，他是不会展开的，小函数就会展开，所以**小函数使用内联，大函数使用静态**

---

### 2.2 内联的特性

1. inline是一种以空间换时间的做法，如果编译器将函数当成内联函数处理，在编译阶段，会用函数体替换函数调用，缺陷：可能会使目标文件变大，优势：少了调用开销，提高程序运行效率。
2. inline对于编译器而言只是一个建议，不同编译器关于inline实现机制可能不同，一般建议：将函数规模较小(即函数不是很长，具体没有准确的说法，取决于编译器内部实现)、不是递归、且频繁调用的函数采用inline修饰，否则编译器会忽略inline特性。下图为《C++prime》第五版关于inline的建议：
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/05d46853a52e43118655c912a793a07e.png)
3. inline **不建议声明和定义分离**，分离会导致链接错误。因为**inline被展开**，就没有函数地址了，链接就会找不到。

---
### 2.3 【面试题】
**宏的优缺点？**

**优点：**
1. 增强代码的复用性。
2. 提高性能。


**缺点：**

1. 不方便调试宏。（因为预编译阶段进行了替换）
2. 导致代码可读性差，可维护性差，容易误用。
3. 没有类型安全的检查 。

---

**C++有哪些技术替代宏？**

1. 常量定义 换用`const` `enum`
2. 短小函数定义换用**内联函数**

---


## 三、auto关键字(C++11)

### 3.1 类型别名思考

- 随着程序越来越复杂，程序中用到的类型也越来越复杂，经常体现在：

1. 类型难于拼写
2. 含义不明确导致容易出错


```cpp
int main()
{
	std::map<std::string, std::string> m{ { "apple", "苹果" }, { "orange","橙子" },{"pear","梨"} };
	std::map<std::string, std::string>::iterator it = m.begin();
	while (it != m.end())
	{
		//....
	}
	return 0;
}
```

- 大家来上面的一个代码，有可能看不懂，但是我们只需要知道`std::map<std::string, std::string>::iterator`是一个类型但是该类型太长了，特别容易写错。聪明的同学可能已经想到：可以通过typedef给类型取别名，比如：

```cpp
typedef std::map<std::string, std::string> Map;
```

使用typedef给类型取别名确实可以简化代码，但是typedef有会遇到新的难题：

```cpp
typedef char* pstring;

int main()
{
	const pstring p1; 
	const pstring* p2; 
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/55acabfb652b4debb176edc15ac9d177.png)

- 在编程时，常常需要把表达式的值赋值给变量，这就要求在声明变量的时候清楚地知道表达式的
  类型。然而有时候要做到这点并非那么容易，因此C++11给auto赋予了新的含义。

- 这个时候auto就有作用了

---
### 3.2 auto简介

- 在早期C/C++中auto的含义是：使用auto修饰的变量，是具有自动存储器的局部变量，但遗憾的是一直没有人去使用它，大家可思考下为什么？

- C++11中，标准委员会赋予了auto全新的含义即：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。

如下所示：


```cpp
int TestAuto()
{
	return 10;
}
int main()
{
	int a = 10;
	auto b = a; // 整形
	auto c = 'a'; // 字符类型
	auto f = &a; //指针类型
	auto d = TestAuto(); // 函数指针类型
	// auto e;  error 必须要对其进行初始化

	cout << typeid(b).name() << endl;
	cout << typeid(c).name() << endl;
	cout << typeid(d).name() << endl;
	cout << typeid(f).name() << endl;
	return 0;
}
```

- 这里的**typeid(函数名).name()**，就是打印类型

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2a94efdd5980494789661845da731530.png)

- 就刚刚上面的代码就可以这样写了

```cpp
#include <string>
#include <map>
int main()
{
	std::map<std::string, std::string> m{ { "apple", "苹果" }, { "orange","橙子" },{"pear","梨"} };
	auto it = m.begin();
	while (it != m.end())
	{
		//....
	}
	return 0;
}
```

- 类型就可以写成auto自动识别了~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b96646bffde24d07aaf9837765acdf09.png)


【注意】

- **使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。**


## 四、auto的使用细则

1. auto与指针和引用结合起来使用

用auto声明指针类型时，用**auto**和**auto***没有任何区别，但用 **auto** 声明引用类型时则必须加 **&**

```cpp
int main()
{
	int x = 10;
	auto a = &x;
	auto* b = &x;
	auto& c = x;

	cout << typeid(a).name() << endl;
	cout << typeid(b).name() << endl;
	cout << typeid(c).name() << endl;
	
	*a = 20;
	*b = 30;
	c = 40;
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/310b7839b95c4acfbaebdd0b8b6efc53.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/215ebebe8b134649a4f9db6b8158c626.png)

2. 在同一行定义多个变量

当在同一行声明多个变量时，这些变量**必须是相同的类型**，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。

```cpp
void TestAuto()
{
	auto a = 1, b = 2;
	auto c = 3, d = 4.0; 
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d2591f2976344d10987c9101bb4130af.png)

3. auto不能推导的场景

- auto不能作为函数的参数

```cpp
// 此处代码编译失败，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导
void TestAuto(auto a)
{}
```
- auto不能直接用来声明数组

```cpp
void TestAuto()
{
	int a[] = {1,2,3};
	auto b[] = {4，5，6};
}
```
- 为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法
- auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有`lambda`表达式等进行配合使用。


### 4.1 基于范围的for循环(C++11)

>范围for的语法

- 在C++98中如果要遍历一个数组，可以按照以下方式进行：

```cpp
void TestFor()
{
	int array[] = { 1, 2, 3, 4, 5 };
	
	for (int i = 0; i < sizeof(array) / sizeof(array[0]); ++i)
		array[i] *= 2;
		
	for (int* p = array; p < array + sizeof(array)/ sizeof(array[0]); ++p)
		cout << *p << endl;
}
```
- 对于一个**有范围的集合**而言，由程序员来说明循环的范围是多余的，有时候还会容易犯错误。因此C++11中引入了基于范围的for循环。**for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。**

```cpp
void TestFor()
{
	int array[] = { 1, 2, 3, 4, 5 };
	for (auto& e : array)
		e *= 2;
	for (auto e : array)
		cout << e << " ";
}
```
- 注意：**与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环。9.2 范围for的使用条件**

### 4.2 范围for的使用条件
- for循环迭代的范围必须是确定的

- 对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围。

注意：以下代码就有问题，因为for的范围不确定


```cpp
void TestFor(int array[])
{
	for(auto& e : array)
	cout<< e <<endl;
}
```
- 迭代的对象要实现++和==的操作。

## 五、指针空值nullptr(C++11)

- 在良好的C/C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的错误，比如未初始化的指针。如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化：

```cpp
void TestPtr()
{
	int* p1 = NULL;
	int* p2 = 0;
	// ……
}
```
- NULL实际是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码：

```cpp
#ifndef NULL
	#ifdef __cplusplus
		#define NULL 0
	#else
		#define NULL ((void *)0)
	#endif
#endif
```

- 或者我们右键转到定义就可以看到：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2069ca7a2d0243fdad0e3627a7b2c831.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fc6768be15c74d5fa33089e2c86fd3c6.png)


- 可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)的常量。不论采取何种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如：

```cpp
void f(int)
{
	cout << "f(int)" << endl;
}
void f(int*)
{
	cout << "f(int*)" << endl;
}
int main()
{
	f(0);
	f(NULL);
	f((int*)NULL);
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cd26f37dd8904dd3abd1e9ca60d64b57.png)


- 程序本意是想通过f(NULL)调用指针版本的`f(int*)`函数，但是由于NULL被定义成0，因此与程序的初衷相悖。

- 在C++98中，字面常量0既可以是一个整形数字，也可以是无类型的指针`(void*)`常量，但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转`(void*)0`。

注意：


1. 在使用`nullptr`表示指针空值时，不需要包含头文件，因为`nullptr`是C++11作为新关键字引入的。
2. 在C++11中，`sizeof(nullptr)` 与 `sizeof((void*)0)`所占的字节数相同。
3. 为了提高代码的健壮性，在后续表示指针空值时建议最好使用`nullptr`。
