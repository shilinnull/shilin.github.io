## 前言

>在学习C++我们必须要掌握的6个默认成员函数，接下来我们挨个学习：

## 构造函数


- 如果一个类中什么成员都没有，简称为空类。

- 空类中真的什么都没有吗？并不是，任何类在什么都不写时，编译器会自动生成以下6个默认成员函数。

- 默认成员函数：用户没有显式实现，编译器会生成的成员函数称为**默认成员函数**。


```cpp	
class Date {};
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3a0556fd156d44e8967406dbffd622e9.png)




### 构造函数的概念

- 首先我们看下面的代码来引入一下**构造函数**：

```cpp
class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print()
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1;
	d1.Init(2022, 7, 5);
	d1.Print();
	Date d2;
	d2.Init(2022, 7, 6);
	d2.Print();
	return 0;
}
```

- 对于Date类，可以通过 `Init()` 公有方法给对象设置日期，但如果每次创建对象时都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？

 - 在C++中就有这么一个方法解决此问题------->**构造函数**

- **构造函数是一个特殊的成员函数**，**名字与类名相同**，创建类类型对象时由编译器**自动调用**，以**保证每个数据成员都有一个合适的初始值**，并且在**对象整个生命周期内只调用一次**。


### 构造函数的特性

- 构造函数是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是构造函数的主要任务并不是开空间创建对象，而是**初始化对象**。

特性：


1. 函数名与类名相同。
2. 无返回值。
3. 对象实例化时编译器自动调用对应的构造函数。
4. 构造函数可以重载。

```cpp
class Date
{
public:
	// 1.无参构造函数
	Date()
	{
		_year = 1;
		_month = 1;
		_day = 1;
	}
	// 2.带参构造函数
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
void TestDate()
{
	Date d1; // 调用无参构造函数
	Date d2(2015, 1, 1); // 调用带参的构造函数
	Date d3();
}
```

- 可以看到正常运行了：

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/31d56f936b6044958964f8c869557a6e.png)



- 上面在创建对象的时候跟上了要初始化的数据，那么我想使用默认构造函数，直接创建对象的时候什么都不写就可以直接使用，那么可以带上括号吗？

```cpp
Date d3();
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/2398e91561914bb6b006503421f49b7d.png)

- 可以看到结论，是不可以的~
  - 主要的是无法和函数的声明区分开

- 上面的代码的函数：声明了`d3`函数，该函数无参，返回一个日期类型的对象

- 注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明

---

实际上我们可以这样写：

- 直接给一个**全缺省**，是不是很很好~

```cpp
class Date
{
public:
	Date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void print()
	{
		cout <<  _year << "/" << _month << "/" << _day << endl;
	}
private:
	int _year;
	int _month;
	int _day;
};
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a579219a02914191855b2e28191b7cc6.png)


- 那么这两个函数可以同时存在吗？

```cpp
Date()
{
	_year = 1;
	_month = 1;
	_day = 1;
}
Date(int year = 1, int month = 1, int day = 1)
{
	_year = year;
	_month = month;
	_day = day;
}
```

- 语法上可以，但是调用的时候会存在歧义，就是到底要调用谁


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/92fcf763456b40f7a5de9882d4160425.png)


- 显而易见是不可以的，接下来再看：

5. 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。

```cpp
class Date
{
public:
	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1;
	d1.Print();
	return 0;
}
```

- 如果我们不指定默认构造函数，它会自动生成一个，但是生成的这个默认构造函数它又什么都没做

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/be484349ffa54f1ebe0d2d31bae22feb.png)


- 到这里我们先得出一个结论：**内置类型/基本类型不做处理**

- 我们这里还有一个点，就是**内置类型**呢？

```cpp
class A
{
public:
	A()
	{
		cout << "A()" << endl;
		_a = 0;
	}
private:
	int _a;
};
class Date
{
public:
	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}
private:
	int _year;
	int _month;
	int _day;

	A _aa;
};
int main()
{
	Date d1;
	d1.Print();
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b28b3fef01e94e5ab655f1427011cd4d.png)

- 再得出一个结论：**对自定义类型，自定义类型回去调用它的默认构造函数**

- C++11委员会对这个语法进行打了补丁，在**内置类型成员变量在类中声明时可以给默认值**,有一个值不给就还是随机值

```cpp
class A
{
public:
	A()
	{
		cout << "A()" << endl;
		_a = 0;
	}
private:
	int _a;
};
class Date
{
public:
	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}
private:
	// 声明给缺省值
	int _year = 1;
	int _month = 1;
	int _day = 1;

	A _aa;
};
int main()
{
	Date d1;
	d1.Print();
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/5a7444092334420a918900a20b3f6146.png)


- 如果用户**显式定义了构造函数，编译器将不再生成**


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d9bf7eaf3d3d4de3aca6a238ee3e5f0a.png)



- 将Date类中构造函数屏蔽后，代码可以通过编译，因为编译器生成了一个无参的默认构造函数
- 将Date类中构造函数放开，代码编译失败，因为一旦显式定义任何构造函数，编译器将不再生成
- 无参构造函数，放开后报错：`error C2512: “Date”: 没有合适的默认构造函数可用`

否则这样用用就不会报错：

```cpp
Date d1(2024,1,31);
```


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/c99b1a7a5d8747d0a878e1c592574569.png)

- 或者再提供一个**默认构造**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/62969d0c3da54142a79c3d5a1b5e1496.png)

- 在或者提供一个**全缺省**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/db8af65df33947729e56eec2e9200b9b.png)


- 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。注意：**无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。**


---


- **那么默认生成的构造函数还有意义吗？**
- 我们再来看这个代码：

```cpp
class Stack
{
public:
	Stack()
	{
		//....
		cout << "Stack()" << endl;
	}
};

// 两个栈实现队列
class MyQueue
{
private:
	Stack st1;
	Stack st2;
};

int main()
{
	MyQueue q;
	return 0;
}
```

- 这里的`MyQueue`就不用写默认构造函数
- 所以还是有意义的，分析一个类型成员和初始化要求，需要写构造函数就我们自己写，不需要的时候用编译器自己生成。结论：**绝大多数场景下都需要自己实现构造函数**，不要老想着编译器自己生成~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/677d095b18fd4a97a9ec48051e56e741.png)


## 析构函数


- 通过前面构造函数的学习，我们知道一个对象是怎么来的，那一个对象又是怎么没呢的？


- 析构函数：与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成的。而对象在销毁时会自动调用析构函数，完成对象中资源的清理工作。

---


- 析构函数是特殊的成员函数，其特征如下：

1. **析构函数名是在类名前加上字符 ~。**

2. **无参数无返回值类型。**
3. **一个类只能有一个析构函数。若未显式定义，系统会自动生成默认的析构函数。注意：`析构函数不能重载`**
4. **对象生命周期结束时，C++编译系统系统自动调用析构函数。**

```cpp
typedef int DataType;
class Stack
{
public:
	Stack(size_t capacity = 3)
	{
		_array = (DataType*)malloc(sizeof(DataType) * capacity);
		if (nullptr == _array)
		{
			perror("malloc申请空间失败!!!");
			return;
		}
		_capacity = capacity;
		_size = 0;
	}
	void Push(DataType data)
	{
		// CheckCapacity();
		_array[_size] = data;
		_size++;
	}

private:
	DataType* _array;
	int _capacity;
	int _size;
};
void TestStack()
{
	Stack s;
	s.Push(1);
	s.Push(2);
}
```

- 在我们上面的代码，我们一般在`C语言阶段`都要在写完后要调用一个销毁函数，如果上面的代码不写析构函数，他是会发生**内存泄漏**的【如果程序不结束的话】

```cpp
typedef int DataType;
class Stack
{
public:
	Stack(size_t capacity = 4)
	{
		_array = (DataType*)malloc(sizeof(DataType) * capacity);
		if (nullptr == _array)
		{
			perror("malloc申请空间失败!!!");
			return;
		}
		_capacity = capacity;
		_size = 0;
	}
	void Push(DataType data)
	{
		// CheckCapacity();
		_array[_size] = data;
		_size++;
	}
	// 其他方法...
	~Stack()
	{
		if (_array)
		{
			free(_array);
			_array = nullptr;
			_capacity = 0;
			_size = 0;
		}
	}
private:
	DataType* _array;
	int _capacity;
	int _size;
};
void TestStack()
{
	Stack s;
	s.Push(1);
	s.Push(2);
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f81b11d267af4d8eaf8235c2b7aa8851.png)


- 再次定义一个，我们观察到和栈一样的，
- **先定义的先构造，后定义的后构造**
- **但是析构是反过来的，后定义的先析构，要满足先进后出的性质**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b5c1a3cec4e34f26847acb117368aa20.png)



5. 关于编译器自动生成的析构函数，是否会完成一些事情呢？下面的程序我们会看到，**编译器生成的默认析构函数，对自定类型成员调用它的析构函数**。


```cpp
class Time
{
public:
	~Time()
	{
		cout << "~Time()" << endl;
	}
private:
	int _hour;
	int _minute;
	int _second;
};
class Date
{
private:
	// 基本类型(内置类型)
	int _year = 1970;
	int _month = 1;
	int _day = 1;
	// 自定义类型
	Time _t;
};
int main()
{
	Date d;
	return 0;
}
```

- 下图中程序运行结束后输出：`~Time()`

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1e00a214f4114544878bc341c04def1c.png)


- 在`main`方法中根本没有直接创建`Time`类的对象，为什么最后会调用`Time`类的析构函数？
  - **因为**：main方法中创建了Date对象d，而d中包含**4**个成员变量，其中 **_year, _month,_day** 三个是内置类型成员，**销毁时不需要资源清理**，最后系统直接将其内存回收即可；而 **_`tTime`类对象** ，所以在d销毁时，要将其内部包含的Time类的_t对象销毁，所以要**调用Time类的析构函数** 。但是：main函数中**不能直接调用Time类的析构函数，实际要释放的是Date类对象**，所以编译器会调用**Date类的析构函数**，而Date没有显式提供，则编译器会给Date类**生成一个默认的析构函数**，目的是在其内部调用`Time`。

- 类的析构函数，即当Date对象销毁时，要**保证其内部每个自定义对象都可以正确销毁**
- main函数中并**没有直接调用Time类析构函数**，而是**显式调用编译器为Date类生成的默认析
  构函数**
- 注意：**创建哪个类的对象则调用该类的析构函数，销毁那个类的对象则调用该类的析构函数**

- **默认生成的析构函数跟构造函数类似，内置类型不做处理，自定义类型区调用它的析构**


6. 如果类中没有申请资源时，**析构函数可以不写**，直接使用编译器生成的默认析构函数，比如Date类；**有资源申请时，一定要写**，否则会造成资源泄漏，比如Stack类。

## 拷贝构造

- 在学习的时候，我们有的时候需要一个与已存在对象一某一样的新对象

- 那在创建对象时，可否创建一个与已存在对象一某一样的新对象呢？
- 拷贝构造函数：只有单个形参，该形参是对本类类型对象的引用(一般常用`const`修饰)，在用已存在的类类型对象创建新对象时由编译器自动调用。

拷贝构造函数也是特殊的成员函数，其**特征**如下：


1. 拷贝构造函数是构造函数的一个**重载形式**。
2. 拷贝构造函数的参数只有一个且必须是**类类型对象的引用**，使用传值方式编译器直接报错，因为**会引发无穷递归调用**。


```cpp
class Date
{
public:
	Date(int year = 1900, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	//Date(const Date d) // 错误写法：编译报错，会引发无穷递归
	Date(const Date& d) // 必须传引用
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1(2024,2,1);
	Date d2(d1);
	return 0;
}
```




![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/bc6631adb4244eaba491ea0ad1ac7a59.png)


- 下面我们解释一下：
- 这里的`const`可加可不加，但是建议加上
- 有些人就写这个写昏头了，写反了，不加`const`的话不会提示

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fef320fd2ba84f17a26a391ff2ce03fd.png)

- 加上了就知道哪里错了，所以还是加上较好


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e1b15fc2948c4a6185ac6fe460647529.png)



- 这里的拷贝构造**必须传引用**，要不然会引发无穷递归【反正编译会报错~】

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b1a7fb8d35bd4852be4d24e3e522645c.png)


- 再看下面代码，我是没有写拷贝构造的，但是这里自动拷贝了，毕竟这个是默认成员函数，这里生成的还和之前几个的默认成员函数还不一样，之前的对默认成员函数对内置类型不处理，而这个拷贝构造对内置类型处理了，如果没有处理，这里就拷贝不出来
- 说明这里会自动生成一个拷贝构造函数，将值拷贝回去

4. 若未显式定义，编译器会生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝叫做**浅拷贝**，或者**值拷贝**。

```cpp
class Date
{
public:
	// 构造函数
	Date(int year = 2024, int month = 2, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1(2024, 2, 1);
	Date d2(d1);
	
	d1.Print();
	d2.Print();

	return 0;
}
```



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cffaad12482647f09727dda654049a54.png)

### 拷贝构造对于自定义类型【浅拷贝】

- 对于自定义类型：

```cpp
class Time
{
public:
	Time(const Time& t)
	{
		_hour = t._hour;
		_minute = t._minute;
		_second = t._second;
		cout << "Time::Time(const Time&)" << endl;
	}
private:
	int _hour;
	int _minute;
	int _second;
};

class Date
{
public:
	Date(int year = 2024, int month = 2, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void Print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}
private:
	int _year;
	int _month;
	int _day;

	// 自定义类型
	Time _t;
};
int main()
{
	Date d1(2024,2,1);
	Date d2(d1);
	
	d1.Print();
	d2.Print();
	return 0;
}
```


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/070b63f0da8e40dba993edd1a86e113a.png)



- 我们有一个方法就是**强制让编译器生成**

- 加上这一条：

```cpp
Time() = default;
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9a4c22a73162445b99c52a2674310063.png)


### 深拷贝

- 刚刚上面的一种场景叫做浅拷贝，还有一个场景就是**深拷贝**


- 编译器生成的默认拷贝构造函数已经可以完成字节序的值拷贝了，还需要自己显式实现吗？当然像日期类这样的类是没必要的。那么下面的类呢？验证一下试试？


- 下面我这个代码没有写拷贝构造，它会自动生成一个**默认的值拷贝**，我们来运行一下

```cpp
typedef int DataType;
class Stack
{
public:
	Stack(size_t capacity = 10)
	{
		_array = (DataType*)malloc(capacity * sizeof(DataType));
		if (nullptr == _array)
		{
			perror("malloc申请空间失败");
			return;
		}
		_size = 0;
		_capacity = capacity;
	}
	void Push(const DataType& data)
	{
		// CheckCapacity();
		_array[_size] = data;
		_size++;
	}
	~Stack()
	{
		if (_array)
		{
			free(_array);
			_array = nullptr;
			_capacity = 0;
			_size = 0;
		}
	}
private:
	DataType* _array;
	size_t _size;
	size_t _capacity;
};
int main()
{
	Stack s1;
	s1.Push(1);
	s1.Push(2);
	s1.Push(3);
	s1.Push(4);
	Stack s2(s1);
	return 0;
}
```

- 我们看到程序崩溃了~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e1635181e213438f84aaf3fb273e6294.png)



- 也就是在一些场景下，默认生成的拷贝构造是会出事的

- 再调试看一下：


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/032ed1d2a2bc497e8b1c0458fdde21e3.png)



- 这会导致**两个对象指向同一块空间**

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6a17884ca253496d945bf939b4589b5f.png)


- **在结束的时候会调用析构函数，会把那块空间给释放了**


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/93e8d1f8df284225baa36410061b837a.png)

- 再次释放的时候会出现错误
- 同一块空间被释放了两次【所以是绝对不能的】

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f69b3cbb65b34589bf12f39c7e70c952.png)

- 正确的我们这样写
- 需要引入一个叫做**深拷贝**

```cpp
Stack(const Stack& s)
{
	// 深拷贝
	DataType* tmp = (DataType*)malloc(s._capacity * sizeof(DataType));
	if (nullptr == tmp)
	{
		perror("malloc fail\n");
		exit(-1);
	}
	memcpy(tmp, s._array, sizeof(DataType) * s._size);
	_array = tmp;
	// 浅拷贝
	_size = s._size;
	_capacity = s._capacity;
}
```


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/39842ae9829c46c7ba03d17e31d718d3.png)



**注意**：类中如果没有涉及资源申请时，拷贝构造函数是否写都可以；一旦涉及到资源申请时，则拷贝构造函数是一定要写的，否则就是浅拷贝

### 拷贝构造函数典型调用场景

- 使用已存在对象创建新对象
- 函数参数类型为类类型对象
- 函数返回值类型为类类型对象


```cpp
class Date
{
public:
	Date(int year, int minute, int day)
	{
		cout << "Date(int,int,int):" << this << endl;
	}
	Date(const Date& d)
	{
		cout << "Date(const Date& d):" << this << endl;
	}
	~Date()
	{
		cout << "~Date():" << this << endl;
	}
private:
	int _year;
	int _month;
	int _day;
};
Date Test(Date d)
{
	Date temp(d);
	return temp;
}
int main()
{
	Date d1(2022, 1, 13);
	Test(d1);
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/909b30f845344ab6aa4aa3c727a78450.png)

为了提高程序效率，**一般对象传参时，尽量使用引用类型**，返回时根据实际场景，能用引用尽量使用引用。
