## 前言
>扫雷游戏是1992年发行的一款大众类益智游戏，对于许多80后、90后来说都是童年的回忆。如今三十年过去了，这款游戏依旧受到很多网友的喜爱，今天我们一起来模拟实现一下扫雷游戏。
>![在这里插入图片描述](https://img-blog.csdnimg.cn/9b996bb020af443c952a005426a828d0.png)


本文所用的编译器是VS2022


## 一、扫雷游戏代码设计思路
这里我们使用模块化设计，模块化设计就是把各个模块的代码分别放在各个新建的`.c`文件里，在`.h`文件里提供外部可调用函数的声明，其它`.c`文件想使用其中的代码时，只需要`#include "XXX.h"`文件即可。使用模块化编程可极大的提高代码的可阅读性、可维护性、可移植性等。

1. 创建菜单函数【选择进入游戏（1）或者退出游戏（0）】
2. 实现9x9扫雷
3. 初始化棋盘
4. 打印棋盘
5. 随机布置雷的位置
6. 排查雷的信息

>检查输入坐标是不是雷
如果这个位置不是雷，就计算这个位置的周围8个坐标有几个雷，并显示雷的个数
如果这个位置是雷，就炸死了，游戏结束
如果把不是雷的位置都找出来了，那游戏也结束了


## 二、设计扫雷代码


### 1.创建菜单函数

> **菜单界面函数实际上就像是我们的一个界面，就好比是游戏的界面目录，餐馆当中的菜单。一样的道理。这个是库函数就有的我们只需要直接引用下即可。**

**game函数的实现**

**主要功能如下：**

> **1.创建并初始化棋盘**
>
> **2.设置雷的位置（使用rand函数）**
>
> **3.打印棋盘信息**
>
> **4.排查雷：a.展开一片非雷区域**
>
> ​                   **b.显示周围雷的个数**
>
> ​          	     **c.判断游戏输赢**

**代码示例:**

```c
#define _CRT_SECURE_NO_WARNINGS 1
#include"game.h"

void enmu() {
	printf("\n");
	printf("***********************\n");
	printf("*******  1.play  ******\n");
	printf("*******  0.exit  ******\n");
	printf("***********************\n");
	printf("\n");
}

void game() {
	//游戏代码逻辑
	//创建数组
	char mine[ROWS][COLS];
	char show[ROWS][COLS];
	//初始化棋盘
	InitBoard(mine, ROWS, COLS, '0');
	InitBoard(show, ROWS, COLS, '*');
	DisplayBoard(show, ROW, COL);
	//布置雷
	SetMine(mine, ROW, COL);
	//DisplayBoard(mine, ROW, COL);
	//排查雷
	FindMine(mine,show, ROW, COL);

} 

int main() {
	srand((unsigned int)time(NULL));
	int input = 0;
	do {
		enmu();
		printf("请选择：>");
		scanf("%d", &input);
		switch (input) {
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏");
			break;
		default:
			printf("选择错误，请重新选择!\n");
			break;
		}
	} while (input);
}
```

效果图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/04ab59fec6334d2d98e71fb444f0ab1b.png)


###  2.实现9x9扫雷

```c
#define ROW 9
#define COL 9
```

**使用 #define 宏定义在这里的好处：**

> - 方便程序的修改，不用对整个程序进行修改，只需对宏定义上进行修改。
> - 提高程序的运行效率，更加方便模块化。
> - 在9x9扫雷基础上，只需改变宏定义的值，就可以实现NxN扫雷的效果。

### 3.初始化棋盘

> **数组最开始存放的是空格，达到为打印棋盘做准备的一个初始化棋盘的实现。**

**初始化棋盘首先要创建两个数组，一个是mine数组存放雷的信息，一个数组是show显示排查雷的位置；我们封装一个InitBoard的函数来实现对以上两个数组的初始化。**
**注**：这里传参时的set是决定数组初始化的内容，所以多传了一个参数。只要调用两次这个InitBoard函数就可以实现两个数组的初始化。
这里是函数的传参，封装在game函数里面**

> 在game.h文件中#define定义了以下符号ROWS,COLS,ROW,COL

这定义11*11的数组是为了防止数组越界访问

game.h

```c
#define ROWS ROW+2
#define COLS COL+2
```

```c
void InitBoard(char board[ROWS][COLS], int rows, int cols, char set) {
	int i = 0;
	int j = 0;
	for (i = 0; i < rows; i++) {
		for (j = 0; j < cols; j++) {
			board[i][j] = set;
		}
	}
}
```

###  4.打印棋盘

> 打印棋盘，本质上是打印数组的内容。

**代码示例：**

```c
void DisplayBoard(char board[ROWS][COLS], int row, int col) {
	int i = 0;
	int j = 0;
	printf("---------扫雷--------\n");
	for (i = 0; i <= col; i++) {
		printf("%d ", i);//打印行
	}
	printf("\n");
	for (i = 1; i <= row; i++) {
		printf("%d ", i);//打印列
		for (j = 1; j <= col; j++) {
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("---------扫雷--------\n");
}
```

效果图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/a50d5c8130ca47949a9df6745263522e.png)


###  5.随机布置雷的位置

> - **字符‘1’表示雷**
> - **字符‘0’表示不是雷**
> - **字符星号表示还没有被排查过的位置**
> - **在布置雷这里，我们又需要用到rand这个随机函数了，需要用到<stdlib.h>头文件，这个函数在使用前，需要使用srand这个函数，srand这个函数的使用只需要调用一次，srand函数在使用时需要一个随机种子，这个随机种子可以用时间戳，所以需要用到<time.h>的头文件**
> - **这里的EASY_COUNT在game.h文件中#define声明了这个符号为10，这是布置雷的个数**

game.h

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
//要布置的雷个数
#define EASY_COUNT 10
//布置雷
void SetMine(char mine[ROWS][COLS], int row, int col);
```
game.c
```c
void SetMine(char mine[ROWS][COLS], int row, int col) {
	int count = EASY_COUNT;
	while (count) {
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if ('0' == mine[x][y])
		{
			mine[x][y] = '1';
			count--;
		}
	}
}
```

### 6.排查雷的信息

**排查雷的信息，我们需要考虑到排查雷的信息是一个循环，所以需要用到while语句；什么时候结束呢？**

row*col个字符中有10个雷，只有当我们把所有不是雷的位置排查完，游戏才算赢，我们在while条件判断里面写win < (row * col - EASY_COUNT)作为输赢的条件；

> 输入的坐标值必须在9x9的范围内

1. 如果坐标不在9x9的范围内，则这个坐标是非法的
2. 如果输入的坐标位置的内容不是星号则表示该坐标位置已经被排查过，
3. 如果输入的坐标位置上的字符等于‘1’，则表示这个坐标是雷，游戏结束
4. 如果以上都不是，则显示目标位置周围的8的坐标的雷的数量，排查一个win++；
5. 只有当win等于总字符数减去雷的个数时，才表示排雷成功；

game.h

```c
void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);
```


```c
int GetMineCount(char mine[ROWS][COLS],int x, int y) {
	return mine[x - 1][y] +
		mine[x - 1][y - 1] +
		mine[x][y - 1] +
		mine[x + 1][y - 1] +
		mine[x + 1][y] +
		mine[x + 1][y + 1] +
		mine[x][y + 1] +
		mine[x - 1][y + 1] - 8 * '0';
}

void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col) {
	int x = 0;
	int y = 0;
	int win = 0;
	while (win < row * col + EASY_COUNT) {
		printf("请输入坐标，进行排查雷：>");
		scanf("%d%d", &x, &y);
		if (x >= 1 && x <= row && y >= 1 && y <= col) {
			if (show[x][y] != '*'){
				printf("该坐标被排查了，请重新输入坐标\n");
			}
			else if ('1' == mine[x][y]) {
				printf("很遗憾，被炸死了!\n");
				DisplayBoard(mine, ROW, COL);
				break;
			}
			else {
				int c = GetMineCount(mine, x, y);
				show[x][y] = c + '0';
				DisplayBoard(show, ROW, COL);
				win++;
			}
		}
		else {
			printf("坐标输入非法，请重新输入!\n");
		}
		if (win == row * col - EASY_COUNT) {
			printf("恭喜你，排雷成功\n");
			DisplayBoard(mine, ROW, COL);
		}
	}
}
```
### 7.递归展开

- 函数接受三个参数：`mine`，`show`，以及要展开的单元格的坐标 `x` 和 `y`。
- 检查坐标（x，y）是否在地雷场边界内（ROWS和COLS）。
- 如果坐标（x，y）处的单元格为空（周围的地雷数为0），则递归探索并展开相邻单元格，直到到达具有非零地雷数的单元格。
- 如果单元格周围有地雷，它显示地雷的数量。
- 每次成功展开单元格时，变量 `win` 都会递增。

```c
void expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y, int* win)
{

	if (x >= 1 && x <= ROW && y >= 1 && y <= COL) //限制在棋盘内展开，防止越界
	{
		int count = GetMineCount(mine, x, y);//获取雷数

		if (count == 0) //四周没雷，进入递归展开
		{
			show[x][y] = ' ';//四周没雷的改为 空格  ' '

			int i = 0;
			//向四周共8个位置递归
			for (i = x - 1; i <= x + 1; i++)
			{
				int j = 0;
				for (j = y - 1; j <= y + 1; j++)
				{

					//只对 '*' 进行展开，防止死循环
					if (show[i][j] == '*')
					{
						expand(mine, show, i, j, win);
					}
				}
			}
		}
		else   //四周有雷显示雷数
		{
			show[x][y] = count + '0';
		}
		//记录展开的数量
		(*win)++;
	}
}
```


##  三、源码

### 1.新建一个test.c源文件

> **test.c文件用来存放游戏的逻辑代码。**

```c
#define _CRT_SECURE_NO_WARNINGS 1
#include "game.h"


void menu()
{
	printf("***********************\n");
	printf("******  1. play   *****\n");
	printf("******  0. exit   *****\n");
	printf("***********************\n");
}

void game()
{
	//数组
	char mine[ROWS][COLS];//'0'
	char show[ROWS][COLS];//'*'
	InitBoard(mine, ROWS, COLS, '0');
	InitBoard(show, ROWS, COLS, '*');
	//棋盘打印
	//DisplayBoard(mine, ROW, COL);
	DisplayBoard(show, ROW, COL);

	//布置雷
	SetMine(mine, ROW, COL);
	//DisplayBoard(mine, ROW, COL);

	//排查雷
	FindMine(mine, show, ROW, COL);
}

int main()
{
	int input = 0;
	srand((unsigned int)time(NULL));
	do
	{
		menu();
		printf("请选择:>");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误，重新选择\n");
			break;
		}
		//...
	} while (input);
	return 0;
}
```

### 2.新建一个game.c源文件

> **game.c文件用来存放函数的定义。**

```c
#define _CRT_SECURE_NO_WARNINGS 1

#include "game.h"


void InitBoard(char board[ROWS][COLS], int rows, int cols, char set)
{
	int i = 0;
	for (i = 0; i < rows; i++)
	{
		int j = 0;
		for (j = 0; j < cols; j++)
		{
			board[i][j] = set;
		}
	}
}


void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	printf("--------扫雷游戏-------\n");
	for (i = 0; i <= row; i++)
	{
		printf("%d ", i);
	}
	printf("\n");
	for (i = 1; i <= row; i++)
	{
		printf("%d ", i);
		int j = 0;
		for (j = 1; j <= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("--------扫雷游戏-------\n");
}

void SetMine(char mine[ROWS][COLS], int row, int col)
{
	int count = EASY_COUNT;

	while (count)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (mine[x][y] == '0')
		{
			mine[x][y] = '1';
			count--;
		}
	}
}

static int GetMineCount(char mine[ROWS][COLS], int x, int y)
{
	return (mine[x - 1][y] +
		mine[x - 1][y - 1] +
		mine[x][y - 1] +
		mine[x + 1][y - 1] +
		mine[x + 1][y] +
		mine[x + 1][y + 1] +
		mine[x][y + 1] +
		mine[x - 1][y + 1] - 8 * '0');
}


void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0, y = 0, z = 0;
	int win = 0;;// 用于判断是否所有的雷已经排尽
	int s = EASY_COUNT;//雷数
	while (win < (row * col) - s)
	{
		system("cls");
		if (z == 0)
		{
			printf("游戏开始\n");
		}
		if (z > 0)
		{
			printf("\n");
		}
		DisplayBoard(show, ROW, COL);
		printf("请输入要排查的坐标:>");
		scanf("%d %d", &x, &y);
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (mine[x][y] == '1')
			{

				system("cls");
				printf("很遗憾，被炸死了!!1\n");
				DisplayBoard(mine, ROW, COL);
				break;
			}
			else
			{
				expand(mine, show, x, y, &win);

				//统计周围雷数
				int c = GetMineCount(mine, x, y);
				show[x][y] = c + '0';// 字符0ascll为48 1为49 加字符即可打印出周围集合的相关的字符
				//每排查一次打印一次棋盘
				DisplayBoard(mine, ROW, COL);
				win++;
			}
		}
		else
		{
			printf("坐标非法请重新输入\n");
		}
		z++;
	}
	if (win == (row * col) - s)
	{
		printf("恭喜你，排雷成功\n");
		DisplayBoard(mine, ROW, COL);

	}
}


void expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y, int* win)
{

	if (x >= 1 && x <= ROW && y >= 1 && y <= COL) //限制在棋盘内展开，防止越界
	{
		int count = GetMineCount(mine, x, y);//获取雷数

		if (count == 0) //四周没雷，进入递归展开
		{
			show[x][y] = ' ';//四周没雷的改为 空格  ' '

			int i = 0;
			//向四周共8个位置递归
			for (i = x - 1; i <= x + 1; i++)
			{
				int j = 0;
				for (j = y - 1; j <= y + 1; j++)
				{

					//只对 '*' 进行展开，防止死循环
					if (show[i][j] == '*')
					{
						expand(mine, show, i, j, win);
					}
				}
			}
		}
		else   //四周有雷显示雷数
		{
			show[x][y] = count + '0';
		}
		//记录展开的数量
		(*win)++;
	}
}
```

### 3.创建一个game.h头文件

> **game.h文件用来存放函数声明，符号声明头文件的包含以及宏定义。**

```c
#pragma once
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROW 9
#define COL 9

//要布置的雷个数
#define EASY_COUNT 10


#define ROWS ROW+2
#define COLS COL+2

//初始化数组
void InitBoard(char board[ROWS][COLS], int rows, int cols, char set);

//打印
void DisplayBoard(char board[ROWS][COLS], int row, int col);

//布置雷
void SetMine(char mine[ROWS][COLS], int row, int col);

//排查雷

void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);

//递归展开
void expand(char mine[ROWS][COLS], char show[ROWS][COLS], int x, int y, int* win);
```

