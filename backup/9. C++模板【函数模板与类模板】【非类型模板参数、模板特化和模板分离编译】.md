## 前言

- 如何实现一个通用的交换函数呢？


```cpp
void Swap(int& left, int& right)
{
	int temp = left;
	left = right;
	right = temp;
}
void Swap(double& left, double& right)
{
	double temp = left;
	left = right;
	right = temp;
}
void Swap(char& left, char& right)
{
	char temp = left;
	left = right;
	right = temp;
}
// ......
```


使用函数重载虽然可以实现，但是有一下几个不好的地方：
1. 重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函数
2. 代码的可维护性比较低，一个出错可能所有的重载均出错


那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？


- 如果在C++中，也能够存在这样一个模具，通过给这个模具中填充不同材料(类型)，来获得不同材料的铸件(即生成具体类型的代码），那将会节省许多头发。巧的是前人早已将树栽好，我们只需在此乘凉。

- 泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是**泛型编程**的基础。


下面介绍两个模板：
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/eed25600d31b413db270f84864ff0afe.png)


## 函数模板

####  函数模板概念

- 函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。


函数模板格式：

```cpp
template<typename T1, typename T2,......,typename Tn>
```
`返回值类型 函数名(参数列表){}`


- 这个时候我们就可以写成


```cpp
template<typename T>

void Swap(T& left, T& right)
{
	T tmp = left;
	left = right;
	right = tmp;
}
```
注意：`typename`是用来定义模板参数关键字，也可以使用`class`(切记：不能使用struct代替class)

 ## 函数模板的原理


- 那么如何解决上面的问题呢？大家都知道，瓦特改良蒸汽机，人类开始了工业革命，解放了生产力。机器生产淘汰掉了很多手工产品。本质是什么，重复的工作交给了机器去完成。有人给出了论调：懒人创造世界。


- 函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来应该我们做的重复的事情交给了编译器


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/83a407db99c542e38a1349498a13fc8a.png)


- 在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码，对于字符类型也是如此。


## 函数模板的实例化


- 用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：隐式实例化和显式实例化

- 	隐式实例化：让编译器根据实参推演模板参数的实际类型

```cpp
template<class T>
T Add(const T& left, const T& right)
{
	return left + right;
}
int main()
{
	int a1 = 10, a2 = 20;
	double d1 = 10.0, d2 = 20.0;
	Add(a1, a2);
	Add(d1, d2);

	Add(a1, d1); // 无法通过编译
	
	return 0;
}
```


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/29da333913ef46d49de330f0301098d5.png)




- `Add(a1, d1);`该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有一个T，编译器无法确定此处到底该将T确定为int 或者 double类型而报错

- 注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅

此时有两种处理方式：**1. 用户自己来强制转化 2. 使用显式实例化**
```cpp
Add(a1, (int)d1);
```

## 显式实例化

- 显式实例化：在函数名后的<>中指定模板参数的实际类型
- 就是直接在函数名的后面加上尖括号【<类型>】

```cpp
int a = 10;
double b = 20.0;
 
// 显式实例化
Add<int>(a, b);
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/e00d35c3de3d4426abe8c133d82aeadc.png)

- 如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。


## 模板参数的匹配原则

1. 一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数。


```cpp
// 专门处理int的加法函数
int Add(int left, int right)
{
	return left + right;
}
// 通用加法函数
template<class T>
T Add(T left, T right)
{
	return left + right;
}
void Test()
{
	Add(1, 2); // 与非模板函数匹配，编译器不需要特化
	Add<int>(1, 2); // 调用编译器特化的Add版本
}
```

2. 对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板。


```cpp
// 专门处理int的加法函数
int Add(int left, int right)
{
	return left + right;
}
// 通用加法函数
template<class T>
T Add(T left, T right)
{
	return left + right;
}
void Test()
{
	Add(1, 2); // 与非函数模板类型完全匹配，不需要函数模板实例化
	Add(1, 2.0); // 模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函数
}
```

3. 模板函数不允许自动类型转换，但普通函数可以进行自动类型转换。


## 类模板

- 定义

```cpp
template<class T1, class T2, ..., class Tn>
class 类模板名
{
	// 类内成员定义
};
```

- 使用

```cpp
template<class T>

class Vector
{
public:
	Vector(size_t capacity = 10)
		: _pData(new T[capacity])
		, _size(0)
		, _capacity(capacity)
	{}
	// 使用析构函数演示：在类中声明，在类外定义。
	~Vector();
	void PushBack(const T& data)；
		void PopBack()；
		// ...
		size_t Size() { return _size; }
	T& operator[](size_t pos)
	{
		assert(pos < _size);
		return _pData[pos];
	}
private:
	T* _pData;
	size_t _size;
	size_t _capacity;
};
// 注意：类模板中函数放在类外进行定义时，需要加模板参数列表
template <class T>
Vector<T>::~Vector()
{
	if (_pData)
		delete[] _pData;
	_size = _capacity = 0;
}
```

####  类模板的实例化

- 类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟<>，然后将实例化的类型放在<>中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。

```cpp
// Vector类名，Vector<int>才是类型
Vector<int> s1;
Vector<double> s2;
```

## 非类型模板参数

- 模板参数可分为**类型形参**和**非类型形参**。
- **类型形参**： 出现在模板参数列表中，跟在`class`或`typename`关键字之后的参数类型名称。
- **非类型形参**： 用一个常量作为类（函数）模板的一个参数，在类（函数）模板中可将该参数当成常量来使用。


例如：我们要实现一个**静态数组的类**，就需要用到非类型模板参数。

- 这里的`array`和`std`标准库里面冲突了，所以我们需要用命名空间

**非类型模板参数   类型  常量**
- 这里编译器帮我实例化了两个类，编译器帮我做了，只需要自己手动控制一下需要实例化的数组大小，**计算机擅长干重复的事情。**
- 模板也**支持缺省参数**

```c
namespace lsl
{
	// 定义一个模板类型的静态数组
	// 非类型模板参数   类型  常量
	template<class T, size_t N = 10>
	class array
	{
	public:
		T& operator[](size_t index) { return _array[index]; }
		const T& operator[](size_t index)const { return _array[index]; }
		size_t size()const { return _size; }
		bool empty()const { return 0 == _size; }
	private:
		T _array[N];
		size_t _size;
	};
}

int main() 
{
	// 默认为数组为10
	lsl::array<int> arr1;

	// 指定大小
	lsl::array<int, 1000> arr2;
	
	cout << sizeof(arr1) << endl;
	cout << sizeof(arr2) << endl;
	return 0;
}
```

- 这样就可以要多少给多少



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/8d7114e4960d4250b6ae0bd1a5c11857.png)


**注意：**

1. 浮点数、类对象以及字符串是不允许作为非类型模板参数的。
2. 非类型的模板参数必须在编译期就能确认结果。


---


### C++11中的array

- C++11中新增加了`array`
- 越界读写都会检查
- 这里的数组是在**栈上开辟的，开辟过大还会导致栈溢出**

```c
#include<array>
int main()
{
	// C++11中的array
	std::array<int, 10> arr1; // 默认不会初始化
	// 普通数组
	int arr2[10];// 默认不会初始化

	// C++11中的array越界都会检查
	arr1[10];
	arr1[15] = 1;

	// 普通数组越界写是抽查，读检查不出来
	arr2[10];
	arr2[15] = 1; // 不会报错

	return 0;
}
```


- 其实我们有更好的`vector`
- 既会检查，又不会溢出


```c
#include<vector>

int main()
{
	std::vector<int> a1(10, 0); // 可以初始化
	for (auto &e : a1) {
		cout << e << " ";
	}

	// 都会检查
	a1[10];
	a1[15] = 1;

	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/268ee81683ef4ec9b9530900b63c11de.png)


---

### 按需实例化


- 我们这里明显是一个语法错误，但是编译器检查不出来

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/98ebf13b443a40ee86e76e04a9c766fa.png)

- 这里是因为**实例化这个类的时候，会按需实例化（调用哪个成员函数就实例化哪个）**

- `根据模板实例化-->半成品模板-->实例化成具体的类/函数-->语法编译`


![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/38f20a29ddce487caf38f00b426fa0ba.png)

---

## 模板的特化


### 概念


- 通常情况下，使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些错误的结果，需要特殊处理，**比如：实现了一个专门用来进行小于比较的函数模板**


```c
// 函数模板 -- 参数匹配
template<class T>
bool Less(T left, T right)
{
	return left < right;
}

class Date
{
public:
	friend ostream& operator<<(ostream& _cout, const Date& d);

	Date(int year = 1900, int month = 1, int day = 1)
		: _year(year)
		, _month(month)
		, _day(day)
	{}

	bool operator<(const Date& d)const
	{
		return (_year < d._year) ||
			(_year == d._year && _month < d._month) || 
			(_year == d._year && _month == d._month && _day < d._day);
	}

	bool operator>(const Date& d)const
	{
		return (_year > d._year) || 
			(_year == d._year && _month > d._month) || 
			(_year == d._year && _month == d._month && _day > d._day);
	}
private:
	int _year;
	int _month;
	int _day;
};

ostream& operator<<(ostream& _cout, const Date& d)
{
	_cout << d._year << "-" << d._month << "-" << d._day;
	return _cout;
}

int main()
{
	cout << Less(1, 2) << endl; // 可以比较，结果正确

	Date d1(2024, 4, 10);
	Date d2(2024, 4, 11);
	
	cout << Less(d1, d2) << endl; // 可以比较，结果正确
	Date* p1 = &d1;
	Date* p2 = &d2;

	cout << Less(p1, p2) << endl; // 可以比较，结果错误
	return 0;
}
```


- 可以看到，Less绝对多数情况下都可以正常比较，但是在特殊场景下就得到错误的结果。上述示例中，**p1指向的d1显然小于p2指向的d2对象**，但是**Less内部并没有比较p1和p2指向的对象内容，而比较的是p1和p2指针的`地址`** ，这就无法达到预期而错误。


- 此时，就需要对模板进行**特化**。即：在原模板类的基础上，针对特殊类型所进行特殊化的实现方式。模板特化中分**为函数模板特化与类模板特化**。

---

## 函数模板特化

>函数模板的特化步骤：


1. 必须要先有一个基础的函数模板
2. 关键字template后面接一对空的尖括号<>
3. 函数名后跟一对尖括号，尖括号中指定需要特化的类型
4. 函数形参表: 必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误。

```c
// 函数模板 -- 参数匹配
template<class T>
bool Less(T left, T right)
{
	return left < right;
}

// 模板特化
template<>
bool Less<Date*>(Date* left, Date* right)
{
	return *left < *right;
}


int main()
{
	Date d1(2022, 7, 7);
	Date d2(2022, 7, 8);

	cout << Less(d1, d2) << endl; // 走的普通模板
	Date* p1 = &d1;
	Date* p2 = &d2;

	cout << Less(p1, p2) << endl; // 走的是模板特化
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/be29f76ff3f64553a01c31257d34fb52.png)



**注意**：一般情况下如果函数模板遇到不能处理或者处理有误的类型，为了实现简单通常都是将该函数直接给出。


```c
// 直接使用函数进行
bool Less(Date* left, Date* right)
{
	return *left < *right;
}
```
- 有现成的直接走现成的了

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/1d8219032a7a441589bbf2aaac192700.png)


- 上面那种实现简单明了，**本质是一种重载**，代码的可读性高，容易书写，因为对于一些参数类型复杂的函数模板，特化时特别给出，因此**函数模板不建议特化**。


----

## 类模板特化


### 全特化


>全特化即是将模板参数列表中所有的参数都确定化。


```c
template<class T1, class T2>
class Data
{
public:
	Data() { 
		cout << "Data<T1, T2>" << endl; 
	}
private:
	T1 _d1;
	T2 _d2;
};

// 模板特化
template<>
class Data<int, char> // 全特化
{
public:
	Data() { 
		cout << "Data<int, char>" << endl; 
	}
private:
	int _d1;
	char _d2;
};

int main() 
{
	Data<int, int> d1; // 匹配的是普通模板
	Data<int, char> d2; // 匹配的是模板特化
	return 0;
}
```



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/861a40dc957d40e28a16c8edf5c9decc.png)



### 偏特化（半特化）

- 这里的半特化不是指的只一半


偏特化：**任何针对模版参数进一步进行条件限制设计的特化版本**。比如对于以下模板类：

```c
template<class T1, class T2>
class Data
{
public:
	Data() {
		cout << "Data<T1, T2>" << endl;
	}
private:
	T1 _d1;
	T2 _d2;
};
```

- 偏特化有以下两种表现方式：


####  部分特化

- 将模板参数类表中的一部分参数特化。

```c
template <class T1>
class Data<T1, int>
{
public:
	Data() { 
		cout << "Data<T1, int>" << endl; 
	}
private:
	T1 _d1;
	int _d2;
};
```



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cda0c90c25e04324980ced92f063468c.png)


- 参数更进一步的限制

偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本。



```c
// 普通模板
template<class T1, class T2>
class Data
{
public:
	Data() {
		cout << "Data<T1, T2>" << endl;
	}
private:
	T1 _d1;
	T2 _d2;
};

// 模板特化
template<>
class Data<int, char>
{
public:
	Data() {
		cout << "Data<int, char>" << endl;
	}
private:
	int _d1;
	char _d2;
};

// 偏特化
template <class T1>
class Data<T1, int>
{
public:
	Data() { 
		cout << "Data<T1, int>" << endl; 
	}
private:
	T1 _d1;
	int _d2;
};

//两个参数偏特化为指针类型
template <typename T1, typename T2>
class Data <T1*, T2*>
{
public:
	Data() { cout << "Data<T1*, T2*>" << endl; }
private:
	T1 _d1;
	T2 _d2;
};

//两个参数偏特化为引用类型
template <typename T1, typename T2>
class Data <T1&, T2&>
{
public:
	Data(const T1& d1, const T2& d2)
		: _d1(d1)
		, _d2(d2)
	{
		cout << "Data<T1&, T2&>" << endl;
	}
private:
	const T1& _d1;
	const T2& _d2;
};


int main()
{

	Data<double, int> d1; // 调用特化的int版本
	Data<int, double> d2; // 调用基础的模板
	Data<int, char> d3; // 调用全特化版本
	Data<int*, int*> d4; // 调用特化的指针版本
	Data<int&, int&> d5(1, 2); // 调用特化的指针版本
	
	return 0;
}
```

## 类模板特化应用示例


有如下专门用来按照小于比较的类模板Less：


```c
#include <vector>
#include <algorithm>
template<class T>
struct Less
{
	bool operator()(const T& x, const T& y) const
	{
		return x < y;
	}
};

int main()
{
	Date d1(2022, 7, 7);
	Date d2(2022, 7, 6);
	Date d3(2022, 7, 8);
	vector<Date> v1;
	v1.push_back(d1);
	v1.push_back(d2);
	v1.push_back(d3);

	// 可以直接排序，结果是日期升序
	sort(v1.begin(), v1.end(), Less<Date>());

	vector<Date*> v2;
	v2.push_back(&d1);
	v2.push_back(&d2);
	v2.push_back(&d3);

	// 可以直接排序，结果错误日期还不是升序，而v2中放的地址是升序
	// 此处需要在排序过程中，让sort比较v2中存放地址指向的日期对象
	// 但是走Less模板，sort在排序时实际比较的是v2中指针的地址，因此无法达到预期
	sort(v2.begin(), v2.end(), Less<Date*>());
	return 0;
}
```


- 通过观察上述程序的结果发现，对于日期对象可以直接排序，并且结果是正确的。但是如果待排序元素是指针，结果就不一定正确。因为：sort最终按照Less模板中方式比较，所以只会比较指针，而不是比较指针指向空间中内容，此时可以使用类版本特化来处理上述问题：


- 特化之后，在运行上述代码，就可以得到正确的结果

```c
// 对Less类模板按照指针方式特化
template<>
struct Less<Date*>
{
	bool operator()(const Date* x, const Date* y) const 
	{
		return *x < *y;
	}
};
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/db58a5c4a7d14070b02952f995aa0c1e.png)


---
## 模板分离编译

#### 什么是分离编译


- 一个程序（项目）由若干个源文件共同实现，而每个源文件单独编译生成目标文件，最后将所有目标文件链接起来形成单一的可执行文件的过程称为分离编译模式。

#### 模板的分离编译


- 有以下场景，模板的声明与定义分离开，在头文件中进行声明，源文件中完成定义：



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/065c3ff1254f4ab286adffbb90acfa91.png)



**分析：**



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7f9f45c24b99498c934b8d739971728d.png)

- 可以将实现放到`xxx.h`，就不会链接错误了



![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/83517d0f66d34b2eb6e40e5467b5de88.png)




---

### 解决方法


1. 将声明和定义放到一个文件 `xxx.hpp` 里面或者`xxx.h`其实也是可以的。推荐使用这种。
2. 模板定义的位置显式实例化。这种方法**不实用，不推荐使用**。


---
## 模板总结

**【优点】**
1. 模板复用了代码，节省资源，更快的迭代开发，C++的标准模板库(STL)因此而产生
2. 增强了代码的灵活性


**【缺陷】**
1. 模板会导致代码膨胀问题，也会导致编译时间变长
2. 出现模板编译错误时，错误信息非常凌乱，不易定位错误
