<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/108561949?v=4&size=64"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## C++11简介

>C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。">
<meta property="og:title" content="16. C++11 右值引用和移动语义，完美转发和万能引用，移动构造和移动赋值，可变参数模板，lambda表达式，包装器">
<meta property="og:description" content="## C++11简介

>C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://xiaolinzi.eu.org/post/16.%20C%2B%2B11%20-you-zhi-yin-yong-he-yi-dong-yu-yi-%EF%BC%8C-wan-mei-zhuan-fa-he-wan-neng-yin-yong-%EF%BC%8C-yi-dong-gou-zao-he-yi-dong-fu-zhi-%EF%BC%8C-ke-bian-can-shu-mo-ban-%EF%BC%8Clambda-biao-da-shi-%EF%BC%8C-bao-zhuang-qi.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/108561949?v=4&size=64">
<title>16. C++11 右值引用和移动语义，完美转发和万能引用，移动构造和移动赋值，可变参数模板，lambda表达式，包装器</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">16. C++11 右值引用和移动语义，完美转发和万能引用，移动构造和移动赋值，可变参数模板，lambda表达式，包装器</h1>
<div class="title-right">
    <a href="https://xiaolinzi.eu.org" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shilinnull/shilinnull.github.io/issues/18" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>C++11简介</h2>
<blockquote>
<p>C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。它取代第二版标准ISO/IEC 14882:2003（第一版ISO/IEC 14882:1998公开于1998年，第二版于2003年更新，分别通称C++98以及C++03，两者差异很小），且已被C++14取代。相比于C++03，C++11标准包含核心语言的新机能，而且扩展C++标准程序库，并入了大部分的C++ Technical Report 1程序库（数学的特殊函数除外）。 ISO／IEC JTC1/SC22/WG21 C++标准委员会计划在2010年8月之前完成对最终委员会草案的投票，以及于2011年3月召开的标准会议完成国际标准的最终草案。然而，WG21预期ISO将要花费六个月到一年的时间才能正式发布新的C++标准。为了能够如期完成，委员会决定致力于直至2006年为止的提案，忽略新的提案[1]。最终于2011年8月12日公布，并于2011年9月出版。</p>
</blockquote>
<h2>统一的列表初始化</h2>
<h3>｛｝初始化</h3>
<ul>
<li>在C++98中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定。比如：</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">struct</span> <span class="pl-en">Point</span>
{
	<span class="pl-k">int</span> _x;
	<span class="pl-k">int</span> _y;
};

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">int</span> array1[] = { <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span> };
	<span class="pl-k">int</span> array2[<span class="pl-c1">5</span>] = { <span class="pl-c1">0</span> };
	<span class="pl-c1">Point</span> p = { <span class="pl-c1">1</span>, <span class="pl-c1">2</span> };
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>C++11扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定义的类型，使用初始化列表时，可添加等号(=)，也可不添加。</li>
<li>创建对象时也可以使用列表初始化方式调用构造函数初始化</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">struct</span> <span class="pl-en">Point</span>
{
	<span class="pl-k">int</span> _x;
	<span class="pl-k">int</span> _y;
};
<span class="pl-k">class</span> <span class="pl-en">Date</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">Date</span>(<span class="pl-k">int</span> year, <span class="pl-k">int</span> month, <span class="pl-k">int</span> day)
		:_year(year)
		, _month(month)
		, _day(day)
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Date(int year, int month, int day)<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
<span class="pl-k">private:</span>
	<span class="pl-k">int</span> _year;
	<span class="pl-k">int</span> _month;
	<span class="pl-k">int</span> _day;
};

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> 内置类型</span>
	<span class="pl-k">int</span> i = <span class="pl-c1">0</span>;
	<span class="pl-k">int</span> j = { <span class="pl-c1">0</span> };
	<span class="pl-k">int</span> k{ <span class="pl-c1">0</span> };
	<span class="pl-k">int</span> array1[]{ <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span> };
	<span class="pl-k">int</span> array2[<span class="pl-c1">5</span>]{ <span class="pl-c1">0</span> };
	
	<span class="pl-c"><span class="pl-c">//</span> 自定义类型</span>
	<span class="pl-c1">Point</span> p{ <span class="pl-c1">1</span>, <span class="pl-c1">2</span> };
	Date <span class="pl-smi">d1</span>(<span class="pl-c1">2023</span>, <span class="pl-c1">11</span>, <span class="pl-c1">25</span>);

	<span class="pl-c"><span class="pl-c">//</span> 类型转换  构造+拷贝构造-&gt;优化直接构造</span>
	Date d2 = { <span class="pl-c1">2024</span>, <span class="pl-c1">5</span>, <span class="pl-c1">15</span> };
	Date d3{ <span class="pl-c1">2024</span>, <span class="pl-c1">5</span>, <span class="pl-c1">15</span> };

	string s1 = <span class="pl-s"><span class="pl-pds">"</span>xxxx<span class="pl-pds">"</span></span>;

	<span class="pl-k">const</span> Date&amp; d4 = { <span class="pl-c1">2023</span>, <span class="pl-c1">11</span>, <span class="pl-c1">25</span> };

	<span class="pl-c"><span class="pl-c">//</span> new 表达式</span>
	Date* p1 = <span class="pl-k">new</span> Date[<span class="pl-c1">3</span>]{ d1, d2, d3 };
	Date* p2 = <span class="pl-k">new</span> Date[<span class="pl-c1">3</span>]{ {<span class="pl-c1">2022</span>, <span class="pl-c1">11</span>, <span class="pl-c1">25</span>}, {<span class="pl-c1">2022</span>, <span class="pl-c1">11</span>, <span class="pl-c1">26</span>}, {<span class="pl-c1">2022</span>, <span class="pl-c1">11</span>, <span class="pl-c1">27</span>} };

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h3>std::initializer_list</h3>
<p><code class="notranslate">std::initializer_list</code>的介绍文档：</p>
<p><a href="https://legacy.cplusplus.com/reference/initializer_list/initializer_list/" rel="nofollow">https://legacy.cplusplus.com/reference/initializer_list/initializer_list/</a></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> the type of il is an initializer_list </span>
	<span class="pl-k">auto</span> il = { <span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">30</span> };
	cout &lt;&lt; <span class="pl-c1">typeid</span>(il).<span class="pl-c1">name</span>() &lt;&lt; endl;
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><strong>std::initializer_list使用场景</strong></p>
<ul>
<li>std::initializer_list一般是作为构造函数的参数，C++11对STL中的不少容器就增加</li>
<li>std::initializer_list作为参数的构造函数，这样初始化容器对象就更方便了。也可以作为operator=的参数，这样就可以用大括号赋值。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	vector&lt;<span class="pl-k">int</span>&gt; v1 = { <span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span> };
	vector&lt;<span class="pl-k">int</span>&gt; v2 = { <span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>,<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>};

	v1 = { <span class="pl-c1">10</span>,<span class="pl-c1">20</span>,<span class="pl-c1">30</span> };

	list&lt;<span class="pl-k">int</span>&gt; lt = { <span class="pl-c1">10</span>,<span class="pl-c1">20</span>,<span class="pl-c1">30</span> };

	<span class="pl-c"><span class="pl-c">//</span> 多参数构造类型转换  构造+拷贝构造-&gt;优化直接构造</span>
	<span class="pl-c"><span class="pl-c">//</span> 跟对应构造函数参数个数匹配</span>
	Date d2 = { <span class="pl-c1">2023</span>, <span class="pl-c1">11</span>, <span class="pl-c1">25</span> };

	<span class="pl-c"><span class="pl-c">//</span> the type of il is an initializer_list </span>
	<span class="pl-k">auto</span> il1 = { <span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">30</span>, <span class="pl-c1">40</span>, <span class="pl-c1">50</span> };
	cout &lt;&lt; <span class="pl-c1">typeid</span>(il1).<span class="pl-c1">name</span>() &lt;&lt; endl;

	initializer_list&lt;<span class="pl-k">int</span>&gt; il2 = { <span class="pl-c1">10</span>, <span class="pl-c1">20</span>, <span class="pl-c1">30</span>};

	initializer_list&lt;<span class="pl-k">int</span>&gt;::iterator it2 = il2.<span class="pl-c1">begin</span>();
	<span class="pl-k">while</span> (it2 != il2.<span class="pl-c1">end</span>())
	{
		cout &lt;&lt; *it2 &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
		++it2;
	}
	cout &lt;&lt; endl;
	
	<span class="pl-c"><span class="pl-c">//</span>for (int e : il2)</span>
	<span class="pl-k">for</span> (<span class="pl-k">auto</span> e : il2)
	{
		cout &lt;&lt; e &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
	}
	cout&lt;&lt; endl;

	pair&lt;string, string&gt; <span class="pl-c1">kv1</span>(<span class="pl-s"><span class="pl-pds">"</span>sort<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>排序<span class="pl-pds">"</span></span>);
	map&lt;string, string&gt; dict = {{<span class="pl-s"><span class="pl-pds">"</span>insert<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>插入<span class="pl-pds">"</span></span>}, {<span class="pl-s"><span class="pl-pds">"</span>get<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>获取<span class="pl-pds">"</span></span>} };
	<span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp; kv : dict)
	{
		cout &lt;&lt; kv.<span class="pl-smi">first</span> &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span> &lt;&lt; kv.<span class="pl-smi">second</span> &lt;&lt; endl;
	}

	Date dd2 = { <span class="pl-c1">2023</span>, <span class="pl-c1">11</span>, <span class="pl-c1">25</span> };
	<span class="pl-c"><span class="pl-c">//</span> Date dd3 = { 2023, 11, 25, 20}; // 报错</span>

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>让模拟实现的vector也支持{}初始化和赋值</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">namespace</span> <span class="pl-en">lsl</span>
{
	<span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
	<span class="pl-k">class</span> <span class="pl-en">vector</span> {
	<span class="pl-k">public:</span>
		<span class="pl-k">typedef</span> T* iterator;

		<span class="pl-en">vector</span>(initializer_list&lt;T&gt; l)
		{
			_start = <span class="pl-k">new</span> T[l.<span class="pl-c1">size</span>()];
			_finish = _start + l.<span class="pl-c1">size</span>();
			_endofstorage = _start + l.<span class="pl-c1">size</span>();
			iterator vit = _start;
			<span class="pl-k">typename</span> initializer_list&lt;T&gt;::iterator lit = l.<span class="pl-c1">begin</span>();
			<span class="pl-k">while</span> (lit != l.<span class="pl-c1">end</span>())
			{
				*vit++ = *lit++;
			}
		}
		vector&lt;T&gt;&amp; <span class="pl-k">operator</span>=(initializer_list&lt;T&gt; l) {
			vector&lt;T&gt; <span class="pl-c1">tmp</span>(l);
			<span class="pl-c1">std::swap</span>(_start, tmp.<span class="pl-smi">_start</span>);
			<span class="pl-c1">std::swap</span>(_finish, tmp.<span class="pl-smi">_finish</span>);
			<span class="pl-c1">std::swap</span>(_endofstorage, tmp.<span class="pl-smi">_endofstorage</span>);
			<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
		}
	<span class="pl-k">private:</span>
		iterator _start;
		iterator _finish;
		iterator _endofstorage;
	};
}</pre></div>
<h3>声明</h3>
<ul>
<li>c++11提供了多种简化声明的方式，尤其是在使用模板时。</li>
</ul>
<h4>auto</h4>
<ul>
<li>在C++98中auto是一个存储类型的说明符，表明变量是局部自动存储类型，但是局部域中定义局部的变量默认就是自动存储类型，所以auto就没什么价值了。C++11中废弃auto原来的用法，将其用于实现自动类型截断。这样要求必须进行显示初始化，让编译器将定义对象的类型设置为初始化值的类型。</li>
</ul>
<h4>decltype</h4>
<ul>
<li>关键字<code class="notranslate">decltype</code>将变量的类型声明为表达式指定的类型。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">int</span> i = <span class="pl-c1">1</span>;
	<span class="pl-k">double</span> d = <span class="pl-c1">2.2</span>;

	<span class="pl-c"><span class="pl-c">//</span> 类型以字符串形式获取到</span>
	cout &lt;&lt; <span class="pl-c1">typeid</span>(i).<span class="pl-c1">name</span>() &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-c1">typeid</span>(d).<span class="pl-c1">name</span>() &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span> typeid(i).name() j;</span>
	<span class="pl-k">auto</span> j = i;

	<span class="pl-k">auto</span> ret = i * d;
	<span class="pl-c1">decltype</span>(ret) x = ret;

	<span class="pl-c"><span class="pl-c">//</span> 用ret的类型去实例化vector</span>
	<span class="pl-c"><span class="pl-c">//</span> decltype可以推导对象的类型。这个类型是可以用来模板实参，或者再定义对象</span>
	vector&lt;<span class="pl-c1">decltype</span>(ret)&gt; v;
	v.<span class="pl-c1">push_back</span>(<span class="pl-c1">1</span>);
	v.<span class="pl-c1">push_back</span>(<span class="pl-c1">1.1</span>);
	<span class="pl-k">for</span> (<span class="pl-k">auto</span> e : v)
	{
		cout &lt;&lt; e &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
	}
	cout &lt;&lt; endl;

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/bc622afe4931fa7310b01b9f6bf33fa288ebc1bd9cc6b1ce1cb9235c7e0fc075/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f66313731663834373332646334666434386365353361323330356466653932322e706e67"><img src="https://camo.githubusercontent.com/bc622afe4931fa7310b01b9f6bf33fa288ebc1bd9cc6b1ce1cb9235c7e0fc075/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f66313731663834373332646334666434386365353361323330356466653932322e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/f171f84732dc4fd48ce53a2305dfe922.png" style="max-width: 100%;"></a></p>
<h4>nullptr</h4>
<ul>
<li>由于C++中NULL被定义成字面量0，这样就可能回带来一些问题，因为0既能指针常量，又能表示整形常量。所以出于清晰和安全的角度考虑，C++11中新增了nullptr，用于表示空指针。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">ifndef</span> NULL
    #<span class="pl-k">ifdef</span> __cplusplus
        #<span class="pl-k">define</span> <span class="pl-en">NULL</span> <span class="pl-c1">0</span>
    #<span class="pl-k">else</span>
        #<span class="pl-k">define</span> <span class="pl-en">NULL</span> ((<span class="pl-k">void</span> *)<span class="pl-c1">0</span>)
    #<span class="pl-k">endif</span>
#<span class="pl-k">endif</span></pre></div>
<h3>范围for循环</h3>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	vector&lt;<span class="pl-k">int</span>&gt; v;
	v.<span class="pl-c1">push_back</span>(<span class="pl-c1">1</span>);
	v.<span class="pl-c1">push_back</span>(<span class="pl-c1">2</span>);
	v.<span class="pl-c1">push_back</span>(<span class="pl-c1">3</span>);
	v.<span class="pl-c1">push_back</span>(<span class="pl-c1">4</span>);

	<span class="pl-k">for</span> (<span class="pl-k">auto</span> e : v)
	{
		<span class="pl-c"><span class="pl-c">//</span> 自动解引用，自动++</span>
		cout &lt;&lt; e &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
	}

	cout &lt;&lt; endl;

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>智能指针</h2>
<blockquote>
<p>新开篇幅进行讲解</p>
</blockquote>
<h2>STL中一些变化</h2>
<p>下图是C++11中新加的一些容器，但是实际最有用的是<code class="notranslate">unordered_map</code>和<code class="notranslate">unordered_set</code>。</p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/a5812e97e9db3a04710e9df371ff39b4bce2baabfc48c5fb65b43b8e8407d0d0/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f64343930636465636434323334363566613136626435303831316636313437312e706e67"><img src="https://camo.githubusercontent.com/a5812e97e9db3a04710e9df371ff39b4bce2baabfc48c5fb65b43b8e8407d0d0/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f64343930636465636434323334363566613136626435303831316636313437312e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/d490cdecd423465fa16bd50811f61471.png" style="max-width: 100%;"></a></p>
<p>实际上C++11更新后，容器中增加的新方法最后用的插入接口函数的右值引用版本：</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/vector/vector/emplace_back/" rel="nofollow">http://www.cplusplus.com/reference/vector/vector/emplace_back/</a></li>
<li><a href="http://www.cplusplus.com/reference/vector/vector/push_back/" rel="nofollow">http://www.cplusplus.com/reference/vector/vector/push_back/</a></li>
<li><a href="http://www.cplusplus.com/reference/map/map/insert/" rel="nofollow">http://www.cplusplus.com/reference/map/map/insert/</a></li>
<li><a href="http://www.cplusplus.com/reference/map/map/emplace/" rel="nofollow">http://www.cplusplus.com/reference/map/map/emplace/</a></li>
</ul>
<h2>右值引用和移动语义</h2>
<h3>左值引用和右值引用</h3>
<ul>
<li>传统的C++语法中就有引用的语法，而C++11中新增了的右值引用语法特性，我们之前学习的引用就叫做左值引用。无论左值引用还是右值引用，都是<strong>给对象取别名</strong>。</li>
</ul>
<p><strong>什么是左值？什么是左值引用？</strong></p>
<ul>
<li>左值是一个表示数据的表达式(如变量名或解引用的指针)，我们可以获取它的地址+可以对它赋值，左值可以出现赋值符号的左边，右值不能出现在赋值符号左边。定义时const修饰符后的左值，不能给他赋值，但是可以取它的地址。左值引用就是给左值的引用，给左值取别名。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> 以下的p、b、c、*p都是左值</span>
	<span class="pl-k">int</span>* p = <span class="pl-k">new</span> <span class="pl-c1">int</span>(<span class="pl-c1">0</span>);
	<span class="pl-k">int</span> b = <span class="pl-c1">1</span>;
	<span class="pl-k">const</span> <span class="pl-k">int</span> c = <span class="pl-c1">2</span>;
	<span class="pl-c"><span class="pl-c">//</span> 以下几个是对上面左值的左值引用</span>
	<span class="pl-k">int</span>*&amp; rp = p;
	<span class="pl-k">int</span>&amp; rb = b;
	<span class="pl-k">const</span> <span class="pl-k">int</span>&amp; rc = c;
	<span class="pl-k">int</span>&amp; pvalue = *p;
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><strong>什么是右值？什么是右值引用？</strong></p>
<ul>
<li>右值也是一个表示数据的表达式，如：字面常量、表达式返回值，函数返回值(这个不能是左值引用返回)等等，右值可以出现在赋值符号的右边，但是不能出现出现在赋值符号的左边，右值不能取地址。右值引用就是对右值的引用，给右值取别名。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">double</span> x = <span class="pl-c1">1.1</span>, y = <span class="pl-c1">2.2</span>;
	<span class="pl-c"><span class="pl-c">//</span> 以下几个都是常见的右值</span>
	<span class="pl-c1">10</span>;
	x + y;
	<span class="pl-c1">fmin</span>(x, y);

	<span class="pl-c"><span class="pl-c">//</span> 以下几个都是对右值的右值引用</span>
	<span class="pl-k">int</span>&amp;&amp; rr1 = <span class="pl-c1">10</span>;
	<span class="pl-k">double</span>&amp;&amp; rr2 = x + y;
	<span class="pl-k">double</span>&amp;&amp; rr3 = <span class="pl-c1">fmin</span>(x, y);
	
	<span class="pl-c"><span class="pl-c">//</span> 这里编译会报错：error C2106: “=”: 左操作数必须为左值</span>
	<span class="pl-c1">10</span> = <span class="pl-c1">1</span>;
	x + y = <span class="pl-c1">1</span>;
	<span class="pl-c1">fmin</span>(x, y) = <span class="pl-c1">1</span>;

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>需要注意的是<strong>右值是不能取地址</strong>的，但是给右值取别名后，会导致右值被存储到特定位置，且可以取到该位置的地址，也就是说例如：<strong>不能取字面量10的地址</strong>，<strong>但是rr1引用后，可以对rr1取地址，也可以修改rr1</strong>。<strong>如果不想rr1被修改，可以用const int&amp;&amp; rr1 去引用</strong>。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">double</span> x = <span class="pl-c1">1.1</span>, y = <span class="pl-c1">2.2</span>;
	<span class="pl-k">int</span>&amp;&amp; rr1 = <span class="pl-c1">10</span>;
	<span class="pl-k">const</span> <span class="pl-k">double</span>&amp;&amp; rr2 = x + y;
	rr1 = <span class="pl-c1">20</span>;
	rr2 = <span class="pl-c1">5.5</span>;  <span class="pl-c"><span class="pl-c">//</span> 报错</span>
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c84b853c926ff626e33f632efc14e1539b66b8ea1b9ad58676eb2b99fb2e58b1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f63383863316636326139313934373033623434613161323263366666386339642e706e67"><img src="https://camo.githubusercontent.com/c84b853c926ff626e33f632efc14e1539b66b8ea1b9ad58676eb2b99fb2e58b1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f63383863316636326139313934373033623434613161323263366666386339642e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/c88c1f62a9194703b44a1a22c6ff8c9d.png" style="max-width: 100%;"></a></p>
<h3>左值引用与右值引用比较</h3>
<p>左值引用总结：</p>
<ol>
<li><strong>左值引用只能引用左值，不能引用右值。</strong></li>
<li><strong>但是const左值引用既可引用左值，也可引用右值。</strong></li>
</ol>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> 左值引用只能引用左值，不能引用右值。</span>
	<span class="pl-k">int</span> a = <span class="pl-c1">10</span>;
	<span class="pl-k">int</span>&amp; ra1 = a;

	<span class="pl-c"><span class="pl-c">//</span> ra为a的别名</span>
	<span class="pl-k">int</span>&amp; ra2 = <span class="pl-c1">10</span>;   <span class="pl-c"><span class="pl-c">//</span> 编译失败，因为10是右值</span>
	<span class="pl-c"><span class="pl-c">//</span> const左值引用既可引用左值，也可引用右值。</span>
	<span class="pl-k">const</span> <span class="pl-k">int</span>&amp; ra3 = <span class="pl-c1">10</span>;
	<span class="pl-k">const</span> <span class="pl-k">int</span>&amp; ra4 = a;
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>右值引用总结：</p>
<ol>
<li><strong>右值引用只能右值，不能引用左值。</strong></li>
<li><strong>但是右值引用可以move以后的左值。</strong></li>
</ol>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> 右值引用只能右值，不能引用左值。</span>
	<span class="pl-k">int</span>&amp;&amp; r1 = <span class="pl-c1">10</span>;


	<span class="pl-c"><span class="pl-c">//</span> error C2440: “初始化”: 无法从“int”转换为“int &amp;&amp;”</span>
	<span class="pl-c"><span class="pl-c">//</span> message : 无法将左值绑定到右值引用</span>
	<span class="pl-k">int</span> a = <span class="pl-c1">10</span>;
	<span class="pl-k">int</span>&amp;&amp; r2 = a;


	<span class="pl-c"><span class="pl-c">//</span> 右值引用可以引用move以后的左值</span>
	<span class="pl-k">int</span>&amp;&amp; r3 = <span class="pl-c1">std::move</span>(a);
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/dfd449558491646a05bd71faa23e284cf0419eeb7c8cb31074766dc7c34dbaef/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f32663266373761613239323734636362386161333135643164343735336463352e706e67"><img src="https://camo.githubusercontent.com/dfd449558491646a05bd71faa23e284cf0419eeb7c8cb31074766dc7c34dbaef/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f32663266373761613239323734636362386161333135643164343735336463352e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/2f2f77aa29274ccb8aa315d1d4753dc5.png" style="max-width: 100%;"></a></p>
<h2>右值引用使用场景和意义</h2>
<ul>
<li>
<p>前面我们可以看到左值引用既可以引用左值和又可以引用右值，那为什么C++11还要提出右值引用呢？是不是画蛇添足呢？下面我们来看看左值引用的短板，右值引用是如何补齐这个短板的！</p>
</li>
<li>
<p>在我们之前写的模拟实现<code class="notranslate">string</code>，再进行改造一下：</p>
</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>

<span class="pl-k">namespace</span> <span class="pl-en">lsl</span>
{
	<span class="pl-k">class</span> <span class="pl-en">string</span>
	{
	<span class="pl-k">public:</span>
		<span class="pl-k">typedef</span> <span class="pl-k">char</span>* iterator;
		iterator <span class="pl-en">begin</span>()
		{
			<span class="pl-k">return</span> _str;
		}
		iterator <span class="pl-en">end</span>()
		{
			<span class="pl-k">return</span> _str + _size;
		}
		<span class="pl-en">string</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>* str = <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)
			:_size(strlen(str))
			, _capacity(_size)
		{
			<span class="pl-c"><span class="pl-c">//</span>cout &lt;&lt; "string(char* str)" &lt;&lt; endl;</span>
			_str = <span class="pl-k">new</span> <span class="pl-k">char</span>[_capacity + <span class="pl-c1">1</span>];
			<span class="pl-c1">strcpy</span>(_str, str);
		}
		<span class="pl-c"><span class="pl-c">//</span> s1.swap(s2)</span>
		<span class="pl-k">void</span> <span class="pl-en">swap</span>(string&amp; s)
		{
			<span class="pl-en">::swap</span>(_str, s._str);
			<span class="pl-en">::swap</span>(_size, s._size);
			<span class="pl-en">::swap</span>(_capacity, s._capacity);
		}
		<span class="pl-c"><span class="pl-c">//</span> 拷贝构造</span>
		<span class="pl-en">string</span>(<span class="pl-k">const</span> string&amp; s)
			:_str(<span class="pl-c1">nullptr</span>)
		{
			cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>string(const string&amp; s) -- 深拷贝<span class="pl-pds">"</span></span> &lt;&lt; endl;
			string <span class="pl-smi">tmp</span>(s.<span class="pl-smi">_str</span>);
			<span class="pl-c1">swap</span>(tmp);
		}
		<span class="pl-c"><span class="pl-c">//</span> 赋值重载</span>
		string&amp; <span class="pl-k">operator</span>=(<span class="pl-k">const</span> string&amp; s)
		{
			cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>string&amp; operator=(string s) -- 深拷贝<span class="pl-pds">"</span></span> &lt;&lt; endl;
			string <span class="pl-smi">tmp</span>(s);
			<span class="pl-c1">swap</span>(tmp);
			<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
		}
		<span class="pl-en">~string</span>()
		{
			<span class="pl-k">delete[]</span> _str;
			_str = <span class="pl-c1">nullptr</span>;
		}
		<span class="pl-k">char</span>&amp; <span class="pl-k">operator</span>[](<span class="pl-c1">size_t</span> pos)
		{
			<span class="pl-c1">assert</span>(pos &lt; _size);
			<span class="pl-k">return</span> _str[pos];
		}
		<span class="pl-k">void</span> <span class="pl-en">reserve</span>(<span class="pl-c1">size_t</span> n)
		{
			<span class="pl-k">if</span> (n &gt; _capacity)
			{
				<span class="pl-k">char</span>* tmp = <span class="pl-k">new</span> <span class="pl-k">char</span>[n + <span class="pl-c1">1</span>];
				<span class="pl-c1">strcpy</span>(tmp, _str);
				<span class="pl-k">delete[]</span> _str;
				_str = tmp;
				_capacity = n;
			}
		}
		<span class="pl-k">void</span> <span class="pl-en">push_back</span>(<span class="pl-k">char</span> ch)
		{
			<span class="pl-k">if</span> (_size &gt;= _capacity)
			{
				<span class="pl-c1">size_t</span> newcapacity = _capacity == <span class="pl-c1">0</span> ? <span class="pl-c1">4</span> : _capacity * <span class="pl-c1">2</span>;
				<span class="pl-c1">reserve</span>(newcapacity);
			}

			_str[_size] = ch;
			++_size;
			_str[_size] = <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\0</span><span class="pl-pds">'</span></span>;
		}
		<span class="pl-c"><span class="pl-c">//</span>string operator+=(char ch)</span>
		string&amp; <span class="pl-k">operator</span>+=(<span class="pl-k">char</span> ch)
		{
			<span class="pl-c1">push_back</span>(ch);
			<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
		}
		<span class="pl-k">const</span> <span class="pl-k">char</span>* <span class="pl-en">c_str</span>() <span class="pl-k">const</span>
		{
			<span class="pl-k">return</span> _str;
		}
	<span class="pl-k">private:</span>
		<span class="pl-k">char</span>* _str;
		<span class="pl-c1">size_t</span> _size;
		<span class="pl-c1">size_t</span> _capacity;
	};
	
	lsl::string <span class="pl-en">to_string</span>(<span class="pl-k">int</span> x)
	{
		lsl::string ret;
		<span class="pl-k">while</span> (x)
		{
			<span class="pl-k">int</span> val = x % <span class="pl-c1">10</span>;
			x /= <span class="pl-c1">10</span>;
			ret += (<span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span> + val);
		}
		<span class="pl-c1">reverse</span>(ret.<span class="pl-c1">begin</span>(), ret.<span class="pl-c1">end</span>());

		<span class="pl-k">return</span> ret;
	}
}</pre></div>
<p><strong>左值引用的使用场景：</strong></p>
<ul>
<li><strong>做参数和做返回值都可以提高效率。</strong></li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">func1</span>(lsl::string s)
{}
<span class="pl-k">void</span> <span class="pl-en">func2</span>(<span class="pl-k">const</span> lsl::string&amp; s)
{}
<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	lsl::string <span class="pl-smi">s1</span>(<span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>);
	<span class="pl-c"><span class="pl-c">//</span> func1和func2的调用我们可以看到左值引用做参数减少了拷贝，提高效率的使用场景和价值</span>
	<span class="pl-c1">func1</span>(s1);
	<span class="pl-c1">func2</span>(s1);

	s1 += <span class="pl-s"><span class="pl-pds">'</span>!<span class="pl-pds">'</span></span>;
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><strong>左值引用的短板：</strong></p>
<ul>
<li>但是当函数返回对象是一个局部变量，出了函数作用域就不存在了，就不能使用左值引用返回，只能传值返回。例如：<code class="notranslate">lsl::string to_string(int value)</code>函数中可以看到，这里只能使用传值返回，传值返回会导致至少1次拷贝构造(如果是一些旧一点的编译器可能是两次拷贝构造)。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">lsl::string <span class="pl-en">to_string</span>(<span class="pl-k">int</span> x)
{
	lsl::string ret;
	<span class="pl-k">while</span> (x)
	{
		<span class="pl-k">int</span> val = x % <span class="pl-c1">10</span>;
		x /= <span class="pl-c1">10</span>;
		ret += (<span class="pl-s"><span class="pl-pds">'</span>0<span class="pl-pds">'</span></span> + val);
	}
	<span class="pl-c1">reverse</span>(ret.<span class="pl-c1">begin</span>(), ret.<span class="pl-c1">end</span>());

	<span class="pl-k">return</span> ret;
}
<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> 在bit::string to_string(int value)函数中可以看到，这里</span>
    <span class="pl-c"><span class="pl-c">//</span> 只能使用传值返回，传值返回会导致至少1次拷贝构造(如果是一些旧一点的编译器可能是两次拷贝构造)。</span>
	lsl::string ret = <span class="pl-c1">lsl::to_string</span>(<span class="pl-c1">1234</span>);

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>这里的to_string的返回值是一个右值，用这个右值构造ret2，如果没有移动构造，调用就会匹配调用拷贝构造，因为const左值引用是可以引用右值的，这里就是一个深拷贝</li>
</ul>
<p>右值引用和移动语义解决上述问题：</p>
<ul>
<li>在<code class="notranslate">bit::string</code>中增加移动构造，移动构造本质是将参数右值的资源窃取过来，占位已有，那么就不用做深拷贝了，所以它叫做<strong>移动构造</strong>，就是<strong>窃取别人的资源来构造自己</strong>。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span> 移动构造</span>
<span class="pl-en">string</span>(string&amp;&amp; s)
	:_str(<span class="pl-c1">nullptr</span>)
	, _size(<span class="pl-c1">0</span>)
	, _capacity(<span class="pl-c1">0</span>)
{
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>string(string&amp;&amp; s) -- 移动语义<span class="pl-pds">"</span></span> &lt;&lt; endl;
	<span class="pl-c1">swap</span>(s);
}
<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	lsl::string ret = <span class="pl-c1">lsl::to_string</span>(<span class="pl-c1">1234</span>);
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>
<p>再运行上面<code class="notranslate">lsl::to_string</code>的两个调用，我们会发现，这里没有调用深拷贝的拷贝构造，而是调用了移动构造，移动构造中没有新开空间，拷贝数据，所以效率提高了。</p>
</li>
<li>
<p><code class="notranslate">to_string</code>的返回值是一个右值，用这个右值构造ret，如果即有拷贝构造又有移动构造，调用就会匹配调用移动构造，因为编译器会选择最匹配的参数调用。那么这里就是一个<strong>移动语义</strong>。</p>
</li>
</ul>
<p><strong>不仅仅有移动构造，还有移动赋值：</strong></p>
<ul>
<li>在<code class="notranslate">lsl::string</code>类中增加移动赋值函数，再去调用<code class="notranslate">lsl::to_string(1234)</code>，不过这次是<code class="notranslate">lsl::to_string(1234)</code>返回的右值对象赋值给<code class="notranslate">ret1</code>对象，这时调用的是移动构造。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span> 移动赋值</span>
string&amp; <span class="pl-k">operator</span>=(string&amp;&amp; s)
{
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>string&amp; operator=(string&amp;&amp; s) -- 移动语义<span class="pl-pds">"</span></span> &lt;&lt; endl;
	<span class="pl-c1">swap</span>(s);
	<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
}</pre></div>
<ul>
<li>这里运行后，我们看到调用了一次<strong>移动构造</strong>和一次<strong>移动赋值</strong>。因为如果是用一个已经存在的对象接收，编译器就没办法优化了。<code class="notranslate">lsl::to_string</code>函数中会先用str生成构造生成一个<strong>临时对象</strong>，但是我们可以看到，编译器很聪明的在这里把str识别成了右值，调用了移动构造。然后在把这个临时对象做为<code class="notranslate">lsl::to_string</code>函数调用的返回值赋值给ret1，这里调用的移动赋值。</li>
</ul>
<p>STL中的容器都是增加了移动构造和移动赋值：</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/string/string/string/" rel="nofollow">http://www.cplusplus.com/reference/string/string/string/</a></li>
<li><a href="http://www.cplusplus.com/reference/vector/vector/vector/" rel="nofollow">http://www.cplusplus.com/reference/vector/vector/vector/</a></li>
</ul>
<p><strong>...</strong></p>
<h2>右值引用引用左值及其一些更深入的使用场景分析</h2>
<ul>
<li>按照语法，右值引用只能引用右值，但右值引用一定不能引用左值吗？因为：有些场景下，可能真的需要用右值去引用左值实现移动语义。当需要用右值引用引用一个左值时，<strong>可以通过move函数将左值转化为右值</strong>。C++11中，<code class="notranslate">std::move()</code>函数位于 头文件中，该函数名字具有迷惑性，它并不搬移任何东西，唯一的功能就是将一个左值强制转化为右值引用，然后实现移动语义。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">_Ty</span>&gt;
<span class="pl-k">inline</span> <span class="pl-k">typename</span> remove_reference&lt;_Ty&gt;::type&amp;&amp; move(_Ty&amp;&amp; _Arg) _NOEXCEPT
{
	<span class="pl-c"><span class="pl-c">//</span> forward _Arg as movable</span>
	<span class="pl-k">return</span> ((<span class="pl-k">typename</span> remove_reference&lt;_Ty&gt;::type&amp;&amp;)_Arg);
}</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	lsl::string <span class="pl-smi">s1</span>(<span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>);
	<span class="pl-c"><span class="pl-c">//</span> 这里s1是左值，调用的是拷贝构造</span>
	lsl::string <span class="pl-smi">s2</span>(s1);

	<span class="pl-c"><span class="pl-c">//</span> 这里我们把s1 move处理以后, 会被当成右值，调用移动构造</span>
	<span class="pl-c"><span class="pl-c">//</span> 但是这里要注意，一般是不要这样用的，因为我们会发现s1的</span>
	<span class="pl-c"><span class="pl-c">//</span> 资源被转移给了s3，s1被置空了。</span>
	lsl::string <span class="pl-smi">s3</span>(<span class="pl-c1">std::move</span>(s1));
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>STL容器插入接口函数也增加了右值引用版本：</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/list/list/push_back/" rel="nofollow">http://www.cplusplus.com/reference/list/list/push_back/</a></li>
<li><a href="http://www.cplusplus.com/reference/vector/vector/push_back/" rel="nofollow">http://www.cplusplus.com/reference/vector/vector/push_back/</a></li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	list&lt;lsl::string&gt; lt;
	lsl::string <span class="pl-smi">s1</span>(<span class="pl-s"><span class="pl-pds">"</span>1111<span class="pl-pds">"</span></span>);
	
	<span class="pl-c"><span class="pl-c">//</span> 这里调用的是拷贝构造</span>
	lt.<span class="pl-c1">push_back</span>(s1);

	<span class="pl-c"><span class="pl-c">//</span> 下面调用都是移动构造</span>
	lt.<span class="pl-c1">push_back</span>(<span class="pl-s"><span class="pl-pds">"</span>2222<span class="pl-pds">"</span></span>);
	lt.<span class="pl-c1">push_back</span>(<span class="pl-c1">std::move</span>(s1));
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/25efa78afc988fe9359675c063a5ffcf29a77428e7ca9255d2470f8740f38ec5/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f37626266333464383538633534353830393163663463626239636163303065332e706e67"><img src="https://camo.githubusercontent.com/25efa78afc988fe9359675c063a5ffcf29a77428e7ca9255d2470f8740f38ec5/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f37626266333464383538633534353830393163663463626239636163303065332e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/7bbf34d858c5458091cf4cbb9cac00e3.png" style="max-width: 100%;"></a></p>
<h2>完美转发 &amp;&amp; 万能引用</h2>
<ul>
<li>模板中的<code class="notranslate">&amp;&amp;</code>不代表右值引用，而是<strong>万能引用</strong>，其既能接收左值又能接收右值。</li>
<li>模板的万能引用只是提供了能够接收同时接收左值引用和右值引用的能力</li>
<li>但是引用类型的唯一作用就是限制了接收的类型，后续使用中都退化成了左值</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">Fun</span>(<span class="pl-k">int</span>&amp; x) { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>左值引用<span class="pl-pds">"</span></span> &lt;&lt; endl; }
<span class="pl-k">void</span> <span class="pl-en">Fun</span>(<span class="pl-k">const</span> <span class="pl-k">int</span>&amp; x) { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>const 左值引用<span class="pl-pds">"</span></span> &lt;&lt; endl; }

<span class="pl-k">void</span> <span class="pl-en">Fun</span>(<span class="pl-k">int</span>&amp;&amp; x) { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>右值引用<span class="pl-pds">"</span></span> &lt;&lt; endl; }
<span class="pl-k">void</span> <span class="pl-en">Fun</span>(<span class="pl-k">const</span> <span class="pl-k">int</span>&amp;&amp; x) { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>const 右值引用<span class="pl-pds">"</span></span> &lt;&lt; endl; }

<span class="pl-c"><span class="pl-c">//</span> 函数模板：万能引用</span>
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">PerfectForward</span>(T&amp;&amp; t)
{
	<span class="pl-c1">Fun</span>(t);
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c1">PerfectForward</span>(<span class="pl-c1">10</span>);           <span class="pl-c"><span class="pl-c">//</span> 右值</span>

	<span class="pl-k">int</span> a;
	<span class="pl-c1">PerfectForward</span>(a);            <span class="pl-c"><span class="pl-c">//</span> 左值</span>
	<span class="pl-c1">PerfectForward</span>(<span class="pl-c1">std::move</span>(a)); <span class="pl-c"><span class="pl-c">//</span> 右值</span>

	<span class="pl-k">const</span> <span class="pl-k">int</span> b = <span class="pl-c1">8</span>;
	<span class="pl-c1">PerfectForward</span>(b);		      <span class="pl-c"><span class="pl-c">//</span> const 左值</span>
	<span class="pl-c1">PerfectForward</span>(<span class="pl-c1">std::move</span>(b)); <span class="pl-c"><span class="pl-c">//</span> const 右值</span>

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3287b916b4e8887756293278da4e688407f147c2ef0a342527564ed2f98ca074/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f63336164376635303432326134333263383638653335333434333032643061642e706e67"><img src="https://camo.githubusercontent.com/3287b916b4e8887756293278da4e688407f147c2ef0a342527564ed2f98ca074/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f63336164376635303432326134333263383638653335333434333032643061642e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/c3ad7f50422a432c868e35344302d0ad.png" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">PerfectForward</span>(T&amp;&amp; t)
{
	<span class="pl-c1">Fun</span>(<span class="pl-c1">move</span>(t));
	<span class="pl-c"><span class="pl-c">//</span> Fun(t);</span>
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6493895ea25a7904ee01dbf4e9ee4b10a5056b9db7016a43939b01967dc1cb67/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f65383436623039323334313834316534396136306530663031623862343461392e706e67"><img src="https://camo.githubusercontent.com/6493895ea25a7904ee01dbf4e9ee4b10a5056b9db7016a43939b01967dc1cb67/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f65383436623039323334313834316534396136306530663031623862343461392e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/e846b092341841e49a60e0f01b8b44a9.png" style="max-width: 100%;"></a></p>
<ul>
<li>我们希望能够在传递过程中保持它的左值或者右值的属性, 就需要用我们下面学习的<strong>完美转发</strong></li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">void</span> <span class="pl-en">Fun</span>(<span class="pl-k">int</span>&amp; x) { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>左值引用<span class="pl-pds">"</span></span> &lt;&lt; endl; }
<span class="pl-k">void</span> <span class="pl-en">Fun</span>(<span class="pl-k">const</span> <span class="pl-k">int</span>&amp; x) { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>const 左值引用<span class="pl-pds">"</span></span> &lt;&lt; endl; }

<span class="pl-k">void</span> <span class="pl-en">Fun</span>(<span class="pl-k">int</span>&amp;&amp; x) { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>右值引用<span class="pl-pds">"</span></span> &lt;&lt; endl; }
<span class="pl-k">void</span> <span class="pl-en">Fun</span>(<span class="pl-k">const</span> <span class="pl-k">int</span>&amp;&amp; x) { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>const 右值引用<span class="pl-pds">"</span></span> &lt;&lt; endl; }

<span class="pl-c"><span class="pl-c">//</span> 函数模板：万能引用</span>
<span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt;
<span class="pl-k">void</span> <span class="pl-en">PerfectForward</span>(T&amp;&amp; t)
{
	<span class="pl-c"><span class="pl-c">//</span> 期望保持实参的属性！</span>
	<span class="pl-c"><span class="pl-c">//</span> 完美转发</span>
	<span class="pl-c1">Fun</span>(forward&lt;T&gt;(t));
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c1">PerfectForward</span>(<span class="pl-c1">10</span>);           <span class="pl-c"><span class="pl-c">//</span> 右值</span>

	<span class="pl-k">int</span> a;
	<span class="pl-c1">PerfectForward</span>(a);            <span class="pl-c"><span class="pl-c">//</span> 左值</span>
	<span class="pl-c1">PerfectForward</span>(<span class="pl-c1">std::move</span>(a)); <span class="pl-c"><span class="pl-c">//</span> 右值</span>

	<span class="pl-k">const</span> <span class="pl-k">int</span> b = <span class="pl-c1">8</span>;
	<span class="pl-c1">PerfectForward</span>(b);		      <span class="pl-c"><span class="pl-c">//</span> const 左值</span>
	<span class="pl-c1">PerfectForward</span>(<span class="pl-c1">std::move</span>(b)); <span class="pl-c"><span class="pl-c">//</span> const 右值</span>

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3ed10a0335329455f1c6f525dc02d0605f4c7eed26450a22295fd106a2c3428d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f63663831313964373937633134393137396437373061636630663432356166392e706e67"><img src="https://camo.githubusercontent.com/3ed10a0335329455f1c6f525dc02d0605f4c7eed26450a22295fd106a2c3428d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f63663831313964373937633134393137396437373061636630663432356166392e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/cf8119d797c149179d770acf0f425af9.png" style="max-width: 100%;"></a></p>
<ul>
<li>完美转发的实际使用</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">struct</span> <span class="pl-en">ListNode</span>
{
	ListNode* _next = <span class="pl-c1">nullptr</span>;
	ListNode* _prev = <span class="pl-c1">nullptr</span>;
	T _data;
};

<span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">List</span>
{
	<span class="pl-k">typedef</span> ListNode&lt;T&gt; Node;
<span class="pl-k">public:</span>
	<span class="pl-en">List</span>()
	{
		_head = <span class="pl-k">new</span> Node;
		_head-&gt;<span class="pl-smi">_next</span> = _head;
		_head-&gt;<span class="pl-smi">_prev</span> = _head;
	}
	<span class="pl-k">void</span> <span class="pl-en">PushBack</span>(T&amp;&amp; x)
	{
		<span class="pl-c"><span class="pl-c">//</span>Insert(_head, x);</span>
		<span class="pl-c1">Insert</span>(_head, std::forward&lt;T&gt;(x));
	}
	<span class="pl-k">void</span> <span class="pl-en">PushFront</span>(T&amp;&amp; x)
	{
		<span class="pl-c"><span class="pl-c">//</span>Insert(_head-&gt;_next, x);</span>
		<span class="pl-c1">Insert</span>(_head-&gt;<span class="pl-smi">_next</span>, std::forward&lt;T&gt;(x));
	}
	<span class="pl-k">void</span> <span class="pl-en">Insert</span>(Node* pos, T&amp;&amp; x)
	{
		Node* prev = pos-&gt;<span class="pl-smi">_prev</span>;
		Node* newnode = <span class="pl-k">new</span> Node;
		newnode-&gt;<span class="pl-smi">_data</span> = std::forward&lt;T&gt;(x); <span class="pl-c"><span class="pl-c">//</span> 关键位置</span>
		<span class="pl-c"><span class="pl-c">//</span> prev newnode pos</span>
		prev-&gt;<span class="pl-smi">_next</span> = newnode;
		newnode-&gt;<span class="pl-smi">_prev</span> = prev;
		newnode-&gt;<span class="pl-smi">_next</span> = pos;
		pos-&gt;<span class="pl-smi">_prev</span> = newnode;
	}

	<span class="pl-k">void</span> <span class="pl-en">Insert</span>(Node* pos, <span class="pl-k">const</span> T&amp; x)
	{
		Node* prev = pos-&gt;<span class="pl-smi">_prev</span>;
		Node* newnode = <span class="pl-k">new</span> Node;
		newnode-&gt;<span class="pl-smi">_data</span> = x;                 <span class="pl-c"><span class="pl-c">//</span> 关键位置</span>
		<span class="pl-c"><span class="pl-c">//</span> prev newnode pos</span>
		prev-&gt;<span class="pl-smi">_next</span> = newnode;
		newnode-&gt;<span class="pl-smi">_prev</span> = prev;
		newnode-&gt;<span class="pl-smi">_next</span> = pos;
		pos-&gt;<span class="pl-smi">_prev</span> = newnode;
	}
<span class="pl-k">private:</span>
	Node* _head;
};</pre></div>
<h2>新的类功能</h2>
<p>原来C++类中，有6个默认成员函数：</p>
<ol>
<li>构造函数</li>
<li>析构函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值重载</li>
<li>取地址重载</li>
<li>const取地址重载</li>
</ol>
<p>最后重要的是前4个，后两个用处不大。默认成员函数就是我们不写编译器会生成一个默认的。</p>
<h3>移动构造函数和移动赋值运算符重载</h3>
<ul>
<li>C++11 新增了两个：<strong>移动构造函数</strong>和<strong>移动赋值运算符重载</strong>。</li>
</ul>
<p>针对移动构造函数和移动赋值运算符重载有一些需要注意的点如下：</p>
<ul>
<li>如果你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个。那么编译器会自动生成一个默认移动构造。默认生成的移动构造函数，对于内置类型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动构造，如果实现了就调用移动构造，没有实现就调用拷贝构造。</li>
<li>如果你没有自己实现移动赋值重载函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个，那么编译器会自动生成一个默认移动赋值。默认生成的移动构造函数，对于内置类型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动赋值，如果实现了就调用移动赋值，没有实现就调用拷贝赋值。(默认移动赋值跟上面移动构造完全类似)</li>
<li>如果你提供了移动构造或者移动赋值，编译器不会自动提供拷贝构造和拷贝赋值。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">Person</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>* name = <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, <span class="pl-k">int</span> age = <span class="pl-c1">0</span>)
		:_name(name)
		, _age(age)
	{}
<span class="pl-k">private:</span>
	lsl::string _name; 
	<span class="pl-k">int</span> _age;
};

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	Person s1;
	Person s2 = s1;
	Person s3 = <span class="pl-c1">std::move</span>(s1);
	Person s4;
	s4 = <span class="pl-c1">std::move</span>(s2);
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c98d9774ec556dc5f18850eda3563a26491c4e7fb6d824fedfd63a5cdce178a8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f31633661353532643264613634616264393461653865316438376564376532642e706e67"><img src="https://camo.githubusercontent.com/c98d9774ec556dc5f18850eda3563a26491c4e7fb6d824fedfd63a5cdce178a8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f31633661353532643264613634616264393461653865316438376564376532642e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/1c6a552d2da64abd94ae8e1d87ed7e2d.png" style="max-width: 100%;"></a></p>
<ul>
<li>只要写了其中一个就不会生成</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">Person</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>* name = <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, <span class="pl-k">int</span> age = <span class="pl-c1">0</span>)
		:_name(name)
		, _age(age)
	{}
		<span class="pl-c"><span class="pl-c">/*</span>Person(const Person&amp; p)</span>
<span class="pl-c">		:_name(p._name)</span>
<span class="pl-c">		, _age(p._age)</span>
<span class="pl-c">		{}<span class="pl-c">*/</span></span>

		<span class="pl-c"><span class="pl-c">/*</span>Person&amp; operator=(const Person&amp; p)</span>
<span class="pl-c">		{</span>
<span class="pl-c">		if(this != &amp;p)</span>
<span class="pl-c">		{</span>
<span class="pl-c">			_name = p._name;</span>
<span class="pl-c">			_age = p._age;</span>
<span class="pl-c">		}</span>
<span class="pl-c">			return *this;</span>
<span class="pl-c">		}<span class="pl-c">*/</span></span>
	
		<span class="pl-en">~Person</span>()
		{}

<span class="pl-k">private:</span>
	lsl::string _name; 
	<span class="pl-k">int</span> _age;
};

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	Person s1;
	Person s2 = s1;
	Person s3 = <span class="pl-c1">std::move</span>(s1);
	Person s4;
	s4 = <span class="pl-c1">std::move</span>(s2);
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h3>强制生成默认函数的关键字default:</h3>
<ul>
<li>C++11可以让你更好的控制要使用的默认函数。假设你要使用某个默认的函数，但是因为一些原这个函数没有默认生成。比如：我们提供了拷贝构造，就不会生成移动构造了，那么我们可以使用default关键字显示指定移动构造生成。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span> 强制生成</span>
<span class="pl-en">Person</span>(Person&amp;&amp; p) = default;</pre></div>
<h3>禁止生成默认函数的关键字delete:</h3>
<ul>
<li>如果能想要限制某些默认函数的生成，在C++98中，是该函数设置成<code class="notranslate">private</code>，并且只声明补丁已，这样只要其他人想要调用就会报错。在C++11中更简单，只需在该函数声明加上<code class="notranslate">=delete</code>即可，该语法指示编译器不生成对应函数的默认版本，称<code class="notranslate">=delete</code>修饰的函数为删除函数。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Person</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">Person</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>* name = <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, <span class="pl-k">int</span> age = <span class="pl-c1">0</span>)
		:_name(name)
		, _age(age)
	{}
	<span class="pl-en">Person</span>(<span class="pl-k">const</span> Person&amp; p) = <span class="pl-k">delete</span>;
<span class="pl-k">private:</span>
	lsl::string _name;
	<span class="pl-k">int</span> _age;
};
<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	Person s1;
	Person s2 = s1;
	Person s3 = <span class="pl-c1">std::move</span>(s1);

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h3>继承和多态中的final与override关键字</h3>
<ol>
<li>final：<strong>修饰虚函数，表示该虚函数不能再被重写</strong></li>
</ol>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Car</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Drive</span>() <span class="pl-k">final</span> {}
};
<span class="pl-k">class</span> <span class="pl-en">Benz</span> :<span class="pl-k">public</span> <span class="pl-en">Car</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Drive</span>() { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Benz-舒适<span class="pl-pds">"</span></span> &lt;&lt; endl; }
};</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/59606013366559360a59e7c5c365638d9d879b6db6b7cfc8378758b548886a15/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f31356432336434313036646234626663393739346234663431653333653334652e706e67"><img src="https://camo.githubusercontent.com/59606013366559360a59e7c5c365638d9d879b6db6b7cfc8378758b548886a15/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f31356432336434313036646234626663393739346234663431653333653334652e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/15d23d4106db4bfc9794b4f41e33e34e.png" style="max-width: 100%;"></a></p>
<ol start="2">
<li>override: <strong>检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错。</strong></li>
</ol>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Car</span> {
<span class="pl-k">public:</span>
	 <span class="pl-k">void</span> <span class="pl-en">Drive</span>() {}
};
<span class="pl-k">class</span> <span class="pl-en">Benz</span> :<span class="pl-k">public</span> <span class="pl-en">Car</span> {
<span class="pl-k">public:</span>
	<span class="pl-k">virtual</span> <span class="pl-k">void</span> <span class="pl-en">Drive</span>() <span class="pl-k">override</span> { cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Benz-舒适<span class="pl-pds">"</span></span> &lt;&lt; endl; }
};</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/9828ef9d3656945b25012d7966eb892fd7dfe96d81aa6856028a0da8e0590d4d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f37326530653633313639323534383838613262643336623739636235373465652e706e67"><img src="https://camo.githubusercontent.com/9828ef9d3656945b25012d7966eb892fd7dfe96d81aa6856028a0da8e0590d4d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f37326530653633313639323534383838613262643336623739636235373465652e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/72e0e63169254888a2bd36b79cb574ee.png" style="max-width: 100%;"></a></p>
<h2>可变参数模板</h2>
<ul>
<li>C++11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板，相比C++98/03，类模版和函数模版中只能含固定数量的模版参数，可变模版参数无疑是一个巨大的改进。</li>
</ul>
<p>下面就是一个基本可变参数的函数模板</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span> Args是一个模板参数包，args是一个函数形参参数包</span>
<span class="pl-c"><span class="pl-c">//</span> 声明一个参数包Args...args，这个参数包中可以包含0到任意个模板参数。</span>
<span class="pl-k">template </span>&lt;<span class="pl-k">class</span> ...Args&gt;
<span class="pl-k">void</span> <span class="pl-en">ShowList</span>(Args... args)
{}</pre></div>
<ul>
<li>上面的参数args前面有省略号，所以它就是一个可变模版参数，我们把带省略号的参数称为“参数包”，它里面包含了0到N（$N&gt;=0$）个模版参数。我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数，这是使用可变模版参数的一个主要特点，也是最大的难点，即如何展开可变模版参数。由于语法不支持使用args[i]这样方式获取可变参数，所以我们的用一些奇招来一一获取<strong>参数包</strong>的值。</li>
</ul>
<p><strong>递归函数方式展开参数包</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span> 递归终止函数</span>
<span class="pl-k">template </span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">void</span> <span class="pl-en">ShowList</span>(<span class="pl-k">const</span> T&amp; t)
{
	cout &lt;&lt; t &lt;&lt; endl;
}
<span class="pl-c"><span class="pl-c">//</span> 展开函数</span>
<span class="pl-k">template </span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>, <span class="pl-k">class</span> ...Args&gt;
<span class="pl-k">void</span> <span class="pl-en">ShowList</span>(T value, Args... args)
{
	cout &lt;&lt; value &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
	<span class="pl-c1">ShowList</span>(args...);
}
<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c1">ShowList</span>(<span class="pl-c1">1</span>);
	<span class="pl-c1">ShowList</span>(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">'</span>A<span class="pl-pds">'</span></span>);
	<span class="pl-c1">ShowList</span>(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">'</span>A<span class="pl-pds">'</span></span>, <span class="pl-c1">std::string</span>(<span class="pl-s"><span class="pl-pds">"</span>sort<span class="pl-pds">"</span></span>));
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>逗号表达式展开参数包</h2>
<ul>
<li>
<p>这种展开参数包的方式，不需要通过递归终止函数，是直接在expand函数体中展开的, printarg不是一个递归终止函数，只是一个处理参数包中每一个参数的函数。这种就地展开参数包的方式实现的关键是逗号表达式。我们知道逗号表达式会按顺序执行逗号前面的表达式。</p>
</li>
<li>
<p>expand函数中的逗号表达式：(printarg(args), 0)，也是按照这个执行顺序，先执行printarg(args)，再得到逗号表达式的结果0。同时还用到了C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组, {(printarg(args), 0)...}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0), etc... )，最终会创建一个元素值都为0的数组int arr[sizeof...(Args)]。由于是逗号表达式，在创建数组的过程中会先执行逗号表达式前面的部分printarg(args)打印出参数，也就是说在构造int数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包</p>
</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template </span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">void</span> <span class="pl-en">PrintArg</span>(T t)
{
	cout &lt;&lt; t &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>;
}
<span class="pl-c"><span class="pl-c">//</span>展开函数</span>
<span class="pl-k">template </span>&lt;<span class="pl-k">class</span> ...Args&gt;
<span class="pl-k">void</span> <span class="pl-en">ShowList</span>(Args... args)
{
	<span class="pl-c"><span class="pl-c">//</span> 要初始化arr，强行让解析参数包，参数包有一个参数，PrintArg就依次推演生成几个</span>
	<span class="pl-k">int</span> arr[] = { (<span class="pl-c1">PrintArg</span>(args), <span class="pl-c1">0</span>)... };
	cout &lt;&lt; endl;
}
<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c1">ShowList</span>(<span class="pl-c1">1</span>);
	<span class="pl-c1">ShowList</span>(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">'</span>A<span class="pl-pds">'</span></span>);
	<span class="pl-c1">ShowList</span>(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">'</span>A<span class="pl-pds">'</span></span>, <span class="pl-c1">std::string</span>(<span class="pl-s"><span class="pl-pds">"</span>sort<span class="pl-pds">"</span></span>));
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>STL容器中的empalce相关接口函数：</p>
<ul>
<li><a href="http://www.cplusplus.com/reference/vector/vector/emplace_back/" rel="nofollow">http://www.cplusplus.com/reference/vector/vector/emplace_back/</a></li>
<li><a href="http://www.cplusplus.com/reference/list/list/emplace_back/" rel="nofollow">http://www.cplusplus.com/reference/list/list/emplace_back/</a></li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template </span>&lt;<span class="pl-k">class</span>... Args&gt;
<span class="pl-k">void</span> <span class="pl-en">emplace_back</span> (Args&amp;&amp;... args);</pre></div>
<ul>
<li>
<p><strong>首先我们看到的emplace系列的接口，支持模板的可变参数，并且万能引用。那么相对insert和emplace系列接口的优势到底在哪里呢？</strong></p>
<ul>
<li><code class="notranslate">emplace_back</code>支持可变参数，拿到构建<code class="notranslate">pair</code>对象的参数后自己去创建对象</li>
<li>那么在这里我们可以看到除了用法上，和<code class="notranslate">push_back</code>没什么太大的区别</li>
</ul>
</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	std::list&lt;lsl::string&gt; lt;
	lsl::string <span class="pl-smi">s1</span>(<span class="pl-s"><span class="pl-pds">"</span>1111<span class="pl-pds">"</span></span>);
	lt.<span class="pl-c1">push_back</span>(s1);
	lt.<span class="pl-c1">push_back</span>(<span class="pl-c1">move</span>(s1));

	cout &lt;&lt; endl;
	lsl::string <span class="pl-smi">s2</span>(<span class="pl-s"><span class="pl-pds">"</span>1111<span class="pl-pds">"</span></span>);
	lt.<span class="pl-c1">emplace_back</span>(s2);
	lt.<span class="pl-c1">emplace_back</span>(<span class="pl-c1">move</span>(s2));

	cout &lt;&lt; endl;
	lt.<span class="pl-c1">push_back</span>(<span class="pl-s"><span class="pl-pds">"</span>xxxx<span class="pl-pds">"</span></span>);
	lt.<span class="pl-c1">emplace_back</span>(<span class="pl-s"><span class="pl-pds">"</span>xxxx<span class="pl-pds">"</span></span>);

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3dbae3c5d95d4aba1dcfb0d35749ce88978579b83e372e28a9a9266cbf9f27bf/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f62303466623261626138353334323031623431316632616538356166663363342e706e67"><img src="https://camo.githubusercontent.com/3dbae3c5d95d4aba1dcfb0d35749ce88978579b83e372e28a9a9266cbf9f27bf/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f62303466623261626138353334323031623431316632616538356166663363342e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/b04fb2aba8534201b411f2ae85aff3c4.png" style="max-width: 100%;"></a></p>
<hr>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	std::list&lt;pair&lt;lsl::string, <span class="pl-k">int</span>&gt;&gt; lt;
	lt.<span class="pl-c1">push_back</span>(<span class="pl-c1">make_pair</span>(<span class="pl-s"><span class="pl-pds">"</span>1111<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>));
	
	cout &lt;&lt; endl;
	lt.<span class="pl-c1">emplace_back</span>(<span class="pl-s"><span class="pl-pds">"</span>2222<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span>);
	lt.<span class="pl-c1">emplace_back</span>(<span class="pl-c1">make_pair</span>(<span class="pl-s"><span class="pl-pds">"</span>1111<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>));

	cout &lt;&lt; endl;
	pair&lt;lsl::string, <span class="pl-k">int</span>&gt; <span class="pl-c1">kv</span>(<span class="pl-s"><span class="pl-pds">"</span>1111<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>);
	lt.<span class="pl-c1">emplace_back</span>(kv);

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/1dd57dea8f8efde8e29504ad9a672d6f3cb30760965ce9713ee5d462f2e6ff78/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f32373635353965643464393434333363393935373635643534633938366631352e706e67"><img src="https://camo.githubusercontent.com/1dd57dea8f8efde8e29504ad9a672d6f3cb30760965ce9713ee5d462f2e6ff78/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f32373635353965643464393434333363393935373635643534633938366631352e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/276559ed4d94433c995765d54c986f15.png" style="max-width: 100%;"></a></p>
<ul>
<li>多参数时，分开一个一个传参</li>
<li>emplace_back的形参是可变参数</li>
<li>直接把参数包不断往下传，直接构造到节点中的val上</li>
<li>emplace略微高效一点，并没有很大的提升，因为移动构造的成本也是足够低的</li>
</ul>
<h2>lambda表达式</h2>
<p>C++98中的一个例子</p>
<ul>
<li>在C++98中，如果想要对一个数据集合中的元素进行排序，可以使用<code class="notranslate">std::sort</code>方法。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>algorithm<span class="pl-pds">&gt;</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">int</span> array[] = { <span class="pl-c1">4</span>,<span class="pl-c1">1</span>,<span class="pl-c1">8</span>,<span class="pl-c1">5</span>,<span class="pl-c1">3</span>,<span class="pl-c1">7</span>,<span class="pl-c1">0</span>,<span class="pl-c1">9</span>,<span class="pl-c1">2</span>,<span class="pl-c1">6</span> };
	<span class="pl-c"><span class="pl-c">//</span> 默认按照小于比较，排出来结果是升序</span>
	<span class="pl-c1">std::sort</span>(array, array + <span class="pl-k">sizeof</span>(array) / <span class="pl-k">sizeof</span>(array[<span class="pl-c1">0</span>]));

	<span class="pl-c"><span class="pl-c">//</span> 如果需要降序，需要改变元素的比较规则</span>
	<span class="pl-c1">std::sort</span>(array, array + <span class="pl-k">sizeof</span>(array) / <span class="pl-k">sizeof</span>(array[<span class="pl-c1">0</span>]), greater&lt;<span class="pl-k">int</span>&gt;());
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>如果待排序元素为自定义类型，需要用户定义排序时的比较规则：</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">struct</span> <span class="pl-en">Goods</span>
{
	string _name;  <span class="pl-c"><span class="pl-c">//</span> 名字</span>
	<span class="pl-k">double</span> _price; <span class="pl-c"><span class="pl-c">//</span> 价格</span>
	<span class="pl-k">int</span> _evaluate; <span class="pl-c"><span class="pl-c">//</span> 评价</span>
	<span class="pl-en">Goods</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>* str, <span class="pl-k">double</span> price, <span class="pl-k">int</span> evaluate)
		:_name(str)
		, _price(price)
		, _evaluate(evaluate)
	{}
};

<span class="pl-k">struct</span> <span class="pl-en">ComparePriceLess</span>
{
	<span class="pl-k">bool</span> <span class="pl-en">operator</span>()(<span class="pl-k">const</span> Goods&amp; gl, <span class="pl-k">const</span> Goods&amp; gr)
	{
		<span class="pl-k">return</span> gl.<span class="pl-smi">_price</span> &lt; gr.<span class="pl-smi">_price</span>;
	}
};

<span class="pl-k">struct</span> <span class="pl-en">ComparePriceGreater</span>
{
	<span class="pl-k">bool</span> <span class="pl-en">operator</span>()(<span class="pl-k">const</span> Goods&amp; gl, <span class="pl-k">const</span> Goods&amp; gr)
	{
		<span class="pl-k">return</span> gl.<span class="pl-smi">_price</span> &gt; gr.<span class="pl-smi">_price</span>;
	}
};


<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	vector&lt;Goods&gt; v = { { <span class="pl-s"><span class="pl-pds">"</span>苹果<span class="pl-pds">"</span></span>, <span class="pl-c1">2.1</span>, <span class="pl-c1">5</span> }, { <span class="pl-s"><span class="pl-pds">"</span>香蕉<span class="pl-pds">"</span></span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span> }, { <span class="pl-s"><span class="pl-pds">"</span>橙子<span class="pl-pds">"</span></span>, <span class="pl-c1">2.2</span>, <span class="pl-c1">3</span> }, { <span class="pl-s"><span class="pl-pds">"</span>菠萝<span class="pl-pds">"</span></span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">4</span> } };
	<span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), <span class="pl-c1">ComparePriceLess</span>());
	<span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), <span class="pl-c1">ComparePriceGreater</span>());
}</pre></div>
<ul>
<li>随着C++语法的发展，人们开始觉得上面的写法太复杂了，每次为了实现一个algorithm算法， 都要重新去写一个类，如果每次比较的逻辑不一样，还要去实现多个类，特别是相同类的命名，这些都给编程者带来了极大的不便。因此，在C++11语法中出现了<strong>Lambda</strong>表达式。</li>
</ul>
<h3>lambda表达式</h3>
<h3>lambda表达式语法</h3>
<p>lambda表达式书写格式：[capture-list] (parameters) mutable -&gt; return-type { statement }</p>
<ol>
<li>lambda表达式各部分说明</li>
</ol>
<ul>
<li>
<p>[capture-list] : 捕捉列表，该列表总是出现在lambda函数的开始位置，编译器根据[]来判断接下来的代码是否为lambda函数，捕捉列表能够捕捉上下文中的变量供lambda函数使用。</p>
</li>
<li>
<p>(parameters)：参数列表。与普通函数的参数列表一致，如果不需要参数传递，则可以连同()一起省略</p>
</li>
<li>
<p>mutable：默认情况下，lambda函数总是一个<code class="notranslate">const</code>函数，<code class="notranslate">mutable</code>可以取消其常量性。使用该修饰符时，参数列表不可省略(即使参数为空)。</p>
</li>
<li>
<p>-&gt;returntype：返回值类型。用追踪返回类型形式声明函数的返回值类型，没有返回值时此部分可省略。返回值类型明确情况下，也可省略，由编译器对返回类型进行推导。</p>
</li>
<li>
<p>{statement}：函数体。在该函数体内，除了可以使用其参数外，还可以使用所有捕获到的变量。</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>在lambda函数定义中，参数列表和返回值类型都是可选部分，而捕捉列表和函数体可以为空。因此C++11中最简单的lambda函数为：<strong>[]{}; 该lambda函数不能做任何事情。</strong></li>
</ul>
<p>可以看出lambda表达式像是一个<strong>匿名函数</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	vector&lt;Goods&gt; v = { { <span class="pl-s"><span class="pl-pds">"</span>苹果<span class="pl-pds">"</span></span>, <span class="pl-c1">2.1</span>, <span class="pl-c1">5</span> }, { <span class="pl-s"><span class="pl-pds">"</span>香蕉<span class="pl-pds">"</span></span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span> }, { <span class="pl-s"><span class="pl-pds">"</span>橙子<span class="pl-pds">"</span></span>, <span class="pl-c1">2.2</span>, <span class="pl-c1">3</span> }, { <span class="pl-s"><span class="pl-pds">"</span>菠萝<span class="pl-pds">"</span></span>, <span class="pl-c1">1.5</span>, <span class="pl-c1">4</span> } };

	<span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), [](<span class="pl-k">const</span> Goods&amp; g1, <span class="pl-k">const</span> Goods&amp; g2)-&gt;<span class="pl-smi">bool</span> {g1.<span class="pl-smi">_price</span> &lt; g2.<span class="pl-smi">_price</span>; });
	<span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), [](<span class="pl-k">const</span> Goods&amp; g1, <span class="pl-k">const</span> Goods&amp; g2) {g1.<span class="pl-smi">_price</span> &gt; g2.<span class="pl-smi">_price</span>; });
	<span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), [](<span class="pl-k">const</span> Goods&amp; g1, <span class="pl-k">const</span> Goods&amp; g2) {g1.<span class="pl-smi">_evaluate</span> &lt; g2.<span class="pl-smi">_evaluate</span>; });
	<span class="pl-c1">sort</span>(v.<span class="pl-c1">begin</span>(), v.<span class="pl-c1">end</span>(), [](<span class="pl-k">const</span> Goods&amp; g1, <span class="pl-k">const</span> Goods&amp; g2) {g1.<span class="pl-smi">_evaluate</span> &gt; g2.<span class="pl-smi">_evaluate</span>; });
}</pre></div>
<hr>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">auto</span> f1 = [](<span class="pl-k">int</span> x) {cout &lt;&lt; x &lt;&lt; endl; <span class="pl-k">return</span> <span class="pl-c1">0</span>; };

	cout &lt;&lt; <span class="pl-c1">typeid</span>(f1).<span class="pl-c1">name</span>() &lt;&lt; endl;

	<span class="pl-c1">f1</span>(<span class="pl-c1">1</span>);
	<span class="pl-c1">f1</span>(<span class="pl-c1">2</span>);

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>可以看到类型是一个<strong>类</strong>，在编译之前会被生成类，可以调用<code class="notranslate">operator()</code></li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/07e6dbc8cfb0f7f88e51faa27a3d9269250c6988ebb0b857ec7b6e99b2222fb4/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f33376335313633306236356134313161626161623766373334303635613730652e706e67"><img src="https://camo.githubusercontent.com/07e6dbc8cfb0f7f88e51faa27a3d9269250c6988ebb0b857ec7b6e99b2222fb4/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f33376335313633306236356134313161626161623766373334303635613730652e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/37c51630b65a411abaab7f734065a70e.png" style="max-width: 100%;"></a></p>
<ul>
<li>名字是<code class="notranslate">lambda_uuid</code></li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6878ccd7ed7ab9465f4c9c1d06141faaa700b0daff6f0e2d899056be3cc30ad1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f31333835376563313762316134353334616661343037656232333866663635382e706e67"><img src="https://camo.githubusercontent.com/6878ccd7ed7ab9465f4c9c1d06141faaa700b0daff6f0e2d899056be3cc30ad1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f31333835376563313762316134353334616661343037656232333866663635382e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/13857ec17b1a4534afa407eb238ff658.png" style="max-width: 100%;"></a></p>
<ol start="2">
<li>捕获列表说明</li>
</ol>
<p>捕捉列表描述了上下文中那些数据可以被lambda使用，以及使用的方式传值还是<strong>传引用</strong>。</p>
<ul>
<li>[var]：表示值传递方式捕捉变量var</li>
<li>[=]：表示值传递方式捕获所有父作用域中的变量(包括this)</li>
<li>[&amp;var]：表示引用传递捕捉变量var</li>
<li>[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括this)</li>
<li>[this]：表示值传递方式捕捉当前的this指针</li>
</ul>
<p>注意：</p>
<ul>
<li>
<p>a. 父作用域指包含lambda函数的语句块</p>
</li>
<li>
<p>b. 语法上捕捉列表可由多个捕捉项组成，并以逗号分割。</p>
</li>
<li>
<p>比如：[=, &amp;a, &amp;b]：以引用传递的方式捕捉变量a和b，值传递方式捕捉其他所有变量&amp;，a, this]：值传递方式捕捉变量a和this，引用方式捕捉其他变量</p>
</li>
<li>
<p>c. 捕捉列表不允许变量重复传递，否则就会导致编译错误。</p>
<ul>
<li>比如：[=, a]：=已经以值传递方式捕捉了所有变量，捕捉a重复</li>
</ul>
</li>
<li>
<p>d. 在块作用域以外的lambda函数捕捉列表必须为空。</p>
</li>
<li>
<p>e. 在块作用域中的lambda函数仅能捕捉父作用域中局部变量，捕捉任何非此作用域或者非局部变量都会导致编译报错。</p>
<p>f. lambda表达式之间不能相互赋值，即使看起来类型相同</p>
</li>
</ul>
<p><strong>引用捕捉：</strong></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">int</span> x = <span class="pl-c1">0</span>, y = <span class="pl-c1">1</span>;
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl;

	<span class="pl-k">auto</span> f1 = [](<span class="pl-k">int</span>&amp; r1, <span class="pl-k">int</span>&amp; r2) {
		<span class="pl-k">int</span> tmp = r1;
		r1 = r2;
		r2 = tmp;
	};

	<span class="pl-c1">f1</span>(x, y);
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;


	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl;
	cout &lt;&lt; &amp;x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span> &lt;&lt; &amp;y &lt;&lt; endl;

	<span class="pl-k">auto</span> f2 = [x, y]() <span class="pl-k">mutable</span> {
		cout &lt;&lt; &amp;x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span> &lt;&lt; &amp;y &lt;&lt; endl;

		<span class="pl-k">int</span> tmp = x;
		x = y;
		y = tmp;
	};

	<span class="pl-c1">f2</span>();
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;

	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl;
	cout &lt;&lt; &amp;x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span> &lt;&lt; &amp;y &lt;&lt; endl;
	<span class="pl-k">auto</span> f3 = [&amp;x, &amp;y]() {
		cout &lt;&lt; &amp;x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span> &lt;&lt; &amp;y &lt;&lt; endl;

		<span class="pl-k">int</span> tmp = x;
		x = y;
		y = tmp;
	};

	<span class="pl-c1">f3</span>();
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/cfee76cc201c6f5a14de33e790144ba21221bb764a08b60df126fc5422c8ca7b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f62333431333365353832663234303663386161326464383265366633643734342e706e67"><img src="https://camo.githubusercontent.com/cfee76cc201c6f5a14de33e790144ba21221bb764a08b60df126fc5422c8ca7b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f62333431333365353832663234303663386161326464383265366633643734342e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/b34133e582f2406c8aa2dd82e6f3d744.png" style="max-width: 100%;"></a></p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">AA</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">void</span> <span class="pl-en">func</span>()
	{
		<span class="pl-c"><span class="pl-c">//</span> 捕捉this</span>
		<span class="pl-k">auto</span> f1 = [<span class="pl-c1">this</span>]() {
			cout &lt;&lt; a1 &lt;&lt; endl;
			cout &lt;&lt; a2 &lt;&lt; endl;
		};

		<span class="pl-c"><span class="pl-c">//</span> 全部捕捉</span>
		<span class="pl-k">auto</span> f1 = [=]() {
			cout &lt;&lt; a1 &lt;&lt; endl;
			cout &lt;&lt; a2 &lt;&lt; endl;
		};
		<span class="pl-c1">f1</span>();
	}
<span class="pl-k">private:</span>
	<span class="pl-k">int</span> a1 = <span class="pl-c1">1</span>;
	<span class="pl-k">int</span> a2 = <span class="pl-c1">1</span>;
};


<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">int</span> x = <span class="pl-c1">0</span>, y = <span class="pl-c1">1</span>, z = <span class="pl-c1">2</span>;

	<span class="pl-c"><span class="pl-c">//</span> = 为全部捕捉，z为引用捕捉</span>
	<span class="pl-k">auto</span> f1 = [=, &amp;z]() {
		z++;

		cout &lt;&lt; x &lt;&lt; endl;
		cout &lt;&lt; y &lt;&lt; endl;
		cout &lt;&lt; z &lt;&lt; endl;
	};

	<span class="pl-c1">f1</span>();
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<blockquote>
<p>函数对象，又称为仿函数，即可以想函数一样使用的对象，就是在类中重载了operator()运算符的类对象。</p>
</blockquote>
<p>从使用方式上来看，<strong>函数对象与lambda表达式</strong>完全一样</p>
<ul>
<li>函数对象将rate作为其成员变量，在定义对象时给出初始值即可，lambda表达式通过捕获列表可以直接将该变量捕获到。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3355a748d1346515492bffec7e9d2482e7fe89091b0ae80e8c7f519c8406218c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f62626431383561316433333734353630386234646366653637376437613834332e706e67"><img src="https://camo.githubusercontent.com/3355a748d1346515492bffec7e9d2482e7fe89091b0ae80e8c7f519c8406218c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f62626431383561316433333734353630386234646366653637376437613834332e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/bbd185a1d33745608b4dcfe677d7a843.png" style="max-width: 100%;"></a></p>
<ul>
<li>实际在底层编译器对于lambda表达式的处理方式，完全就是按照函数对象的方式处理的，即：如果定义了一个lambda表达式，编译器会自动生成一个类，在该类中重载了<code class="notranslate">operator()</code>。</li>
</ul>
<h2>包装器</h2>
<ul>
<li>function包装器 也叫作适配器。C++中的<code class="notranslate">function</code>本质是一个<strong>类模板</strong>，也是一个包装器。</li>
</ul>
<p><a href="https://legacy.cplusplus.com/reference/functional/function/?kw=function" rel="nofollow">function</a></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/12ae6a39b19b82349cb0f2ef09abf650a0e6cf727892a5961e0d3e5731cf13c8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f61343530643863653635326434613665386161623632316665313963343465362e706e67"><img src="https://camo.githubusercontent.com/12ae6a39b19b82349cb0f2ef09abf650a0e6cf727892a5961e0d3e5731cf13c8/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f61343530643863653635326434613665386161623632316665313963343465362e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/a450d8ce652d4a6e8aab621fe19c44e6.png" style="max-width: 100%;"></a></p>
<ul>
<li>可调用对象有：<strong>函数指针，仿函数，lambda</strong></li>
</ul>
<p>包装器的使用：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span><span class="pl-s"><span class="pl-pds">&lt;</span>functional<span class="pl-pds">&gt;</span></span>

<span class="pl-k">void</span> <span class="pl-en">swap_func</span>(<span class="pl-k">int</span>&amp; r1, <span class="pl-k">int</span>&amp; r2)
{
	<span class="pl-k">int</span> tmp = r1;
	r1 = r2;
	r2 = tmp;
}

<span class="pl-k">struct</span> <span class="pl-en">Swap</span>
{
	<span class="pl-k">void</span> <span class="pl-en">operator</span>()(<span class="pl-k">int</span>&amp; r1, <span class="pl-k">int</span>&amp; r2)
	{
		<span class="pl-k">int</span> tmp = r1;
		r1 = r2;
		r2 = tmp;
	}
};


<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">int</span> x = <span class="pl-c1">0</span>, y = <span class="pl-c1">1</span>;
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span> lambda</span>
	<span class="pl-k">auto</span> swaplambda = [](<span class="pl-k">int</span>&amp; r1, <span class="pl-k">int</span>&amp; r2) {<span class="pl-k">int</span> tmp = r1; r1 = r2; r2 = tmp; };

	<span class="pl-c"><span class="pl-c">//</span> 函数指针</span>
	function&lt;<span class="pl-c1">void</span>(<span class="pl-k">int</span>&amp;, <span class="pl-k">int</span>&amp;)&gt; f1 = swap_func;
	<span class="pl-c1">f1</span>(x, y);
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;
	<span class="pl-c"><span class="pl-c">//</span> 类[匿名对象]</span>
	function&lt;<span class="pl-c1">void</span>(<span class="pl-k">int</span>&amp;, <span class="pl-k">int</span>&amp;)&gt; f2 = <span class="pl-c1">Swap</span>();
	<span class="pl-c1">f2</span>(x, y);
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;
	<span class="pl-c"><span class="pl-c">//</span> lambda</span>
	function&lt;<span class="pl-c1">void</span>(<span class="pl-k">int</span>&amp;, <span class="pl-k">int</span>&amp;)&gt; f3 = swaplambda;
	<span class="pl-c1">f3</span>(x, y);
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;

	map&lt;std::string, std::function&lt;<span class="pl-c1">void</span>(<span class="pl-k">int</span>&amp;, <span class="pl-k">int</span>&amp;)&gt;&gt; CmdOp{
		{<span class="pl-s"><span class="pl-pds">"</span>函数指针<span class="pl-pds">"</span></span>, swap_func},
		{<span class="pl-s"><span class="pl-pds">"</span>仿函数<span class="pl-pds">"</span></span>, <span class="pl-c1">Swap</span>()},
		{<span class="pl-s"><span class="pl-pds">"</span>lambda<span class="pl-pds">"</span></span>, swaplambda},

		<span class="pl-c"><span class="pl-c">//</span>{"函数指针", f1},</span>
		<span class="pl-c"><span class="pl-c">//</span>{"仿函数", f2},</span>
		<span class="pl-c"><span class="pl-c">//</span>{"lambda", f3},</span>
	};

	<span class="pl-c"><span class="pl-c">//</span> 使用</span>
	CmdOp[<span class="pl-s"><span class="pl-pds">"</span>函数指针<span class="pl-pds">"</span></span>](x, y);
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;

	CmdOp[<span class="pl-s"><span class="pl-pds">"</span>仿函数<span class="pl-pds">"</span></span>](x, y);
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;

	CmdOp[<span class="pl-s"><span class="pl-pds">"</span>lambda<span class="pl-pds">"</span></span>](x, y);
	cout &lt;&lt; x &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> &lt;&lt; y &lt;&lt; endl &lt;&lt; endl;

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>有了包装器，如何解决模板的效率低下，实例化多份的问题呢？</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>functional<span class="pl-pds">&gt;</span></span>
<span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">F</span>, <span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
T <span class="pl-en">useF</span>(F f, T x)
{
	<span class="pl-k">static</span> <span class="pl-k">int</span> count = <span class="pl-c1">0</span>;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>count:<span class="pl-pds">"</span></span> &lt;&lt; ++count &lt;&lt; endl;
	cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>count:<span class="pl-pds">"</span></span> &lt;&lt; &amp;count &lt;&lt; endl;
	<span class="pl-k">return</span> <span class="pl-c1">f</span>(x);
}
<span class="pl-k">double</span> <span class="pl-en">f</span>(<span class="pl-k">double</span> i)
{
	<span class="pl-k">return</span> i / <span class="pl-c1">2</span>;
}
<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-k">struct</span> <span class="pl-en">Functor</span>
	{
		<span class="pl-k">double</span> <span class="pl-en">operator</span>()(<span class="pl-k">double</span> d)
		{
			<span class="pl-k">return</span> d / <span class="pl-c1">3</span>;
		}
	};
	<span class="pl-c"><span class="pl-c">//</span> 函数名</span>
	std::function&lt;<span class="pl-c1">double</span>(<span class="pl-k">double</span>)&gt; func1 = f;
	cout &lt;&lt; <span class="pl-c1">useF</span>(func1, <span class="pl-c1">11.11</span>) &lt;&lt; endl;
	<span class="pl-c"><span class="pl-c">//</span> 函数对象</span>
	std::function&lt;<span class="pl-c1">double</span>(<span class="pl-k">double</span>)&gt; func2 = <span class="pl-c1">Functor</span>();
	cout &lt;&lt; <span class="pl-c1">useF</span>(func2, <span class="pl-c1">11.11</span>) &lt;&lt; endl;
	<span class="pl-c"><span class="pl-c">//</span> lamber表达式</span>
	std::function&lt;<span class="pl-c1">double</span>(<span class="pl-k">double</span>)&gt; func3 = [](<span class="pl-k">double</span> d)-&gt;<span class="pl-smi">double</span> { <span class="pl-k">return</span> d / <span class="pl-c1">4</span>; };
	cout &lt;&lt; <span class="pl-c1">useF</span>(func3, <span class="pl-c1">11.11</span>) &lt;&lt; endl;
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>使用场景</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/" rel="nofollow">150. 逆波兰表达式求值</a></p>
<p>我们之前实现的：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Solution</span> {
<span class="pl-k">public:</span>
    <span class="pl-k">int</span> <span class="pl-en">evalRPN</span>(vector&lt;string&gt;&amp; tokens) {
        stack&lt;<span class="pl-k">int</span>&gt; st;

        <span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp; str : tokens) {
            <span class="pl-k">if</span> (str == <span class="pl-s"><span class="pl-pds">"</span>+<span class="pl-pds">"</span></span> || str == <span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span> || str == <span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span> || str == <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>) {
                <span class="pl-c"><span class="pl-c">//</span> 操作符</span>
                <span class="pl-k">int</span> right = st.<span class="pl-c1">top</span>();
                st.<span class="pl-c1">pop</span>();
                <span class="pl-k">int</span> left = st.<span class="pl-c1">top</span>();
                st.<span class="pl-c1">pop</span>();
                <span class="pl-k">switch</span> (str[<span class="pl-c1">0</span>]) {
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>+<span class="pl-pds">'</span></span>:
                    st.<span class="pl-c1">push</span>(left + right);
                    <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span>:
                    st.<span class="pl-c1">push</span>(left - right);
                    <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>:
                    st.<span class="pl-c1">push</span>(left * right);
                    <span class="pl-k">break</span>;
                <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>/<span class="pl-pds">'</span></span>:
                    st.<span class="pl-c1">push</span>(left / right);
                    <span class="pl-k">break</span>;
                }
            } <span class="pl-k">else</span> {
                <span class="pl-c"><span class="pl-c">//</span> 操作数</span>
                st.<span class="pl-c1">push</span>(<span class="pl-c1">stoi</span>(str));
            }
        }
        <span class="pl-k">return</span> st.<span class="pl-c1">top</span>();
    }
};</pre></div>
<ul>
<li>使用包装器实现：</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Solution</span> {
<span class="pl-k">public:</span>
    <span class="pl-k">int</span> <span class="pl-en">evalRPN</span>(vector&lt;string&gt;&amp; tokens) {
        stack&lt;<span class="pl-k">int</span>&gt; st;
        <span class="pl-c"><span class="pl-c">//</span> 包装器</span>
        map&lt;string, function&lt;<span class="pl-c1">int</span>(<span class="pl-k">int</span>, <span class="pl-k">int</span>)&gt;&gt; CmdOp{
            {<span class="pl-s"><span class="pl-pds">"</span>+<span class="pl-pds">"</span></span>, [](<span class="pl-k">int</span> x, <span class="pl-k">int</span> y) { <span class="pl-k">return</span> x + y; }},
            {<span class="pl-s"><span class="pl-pds">"</span>-<span class="pl-pds">"</span></span>, [](<span class="pl-k">int</span> x, <span class="pl-k">int</span> y) { <span class="pl-k">return</span> x - y; }},
            {<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>, [](<span class="pl-k">int</span> x, <span class="pl-k">int</span> y) { <span class="pl-k">return</span> x * y; }},
            {<span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>, [](<span class="pl-k">int</span> x, <span class="pl-k">int</span> y) { <span class="pl-k">return</span> x / y; }}};

        <span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp; str : tokens) {
            <span class="pl-k">if</span> (CmdOp.<span class="pl-c1">count</span>(str)) {
                <span class="pl-c"><span class="pl-c">//</span> 操作符</span>
                <span class="pl-k">int</span> right = st.<span class="pl-c1">top</span>();
                st.<span class="pl-c1">pop</span>();
                <span class="pl-k">int</span> left = st.<span class="pl-c1">top</span>();
                st.<span class="pl-c1">pop</span>();

                st.<span class="pl-c1">push</span>(CmdOp[str](left, right));
            } <span class="pl-k">else</span> {
                <span class="pl-c"><span class="pl-c">//</span> 操作数</span>
                st.<span class="pl-c1">push</span>(<span class="pl-c1">stoi</span>(str));
            }
        }
        <span class="pl-k">return</span> st.<span class="pl-c1">top</span>();
    }
};</pre></div>
<h2>bind</h2>
<ul>
<li><strong>std::bind</strong>函数定义在头文件中，是一个函数模板，它就像一个函数包装器(适配器)，接受一个可调用对象（callable object），生成一个新的可调用对象来“适应”原对象的参数列表。一般而言，我们用它可以把一个原本接收N个参数的函数fn，通过绑定一些参数，返回一个接收M个（M可以大于N，但这么做没什么意义）参数的新函数。同时，使用<code class="notranslate">std::bind</code>函数还可以实现参数顺序调整等操作。</li>
</ul>
<p><a href="https://legacy.cplusplus.com/reference/functional/bind/?kw=bind" rel="nofollow">原型：bind</a></p>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/e249296ffb3a51c3223abb0970b4190f0768a54d656635ec8b699d3977014f05/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f36616462333232353237313034316136396364323466663663356339396635662e706e67"><img src="https://camo.githubusercontent.com/e249296ffb3a51c3223abb0970b4190f0768a54d656635ec8b699d3977014f05/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f36616462333232353237313034316136396364323466663663356339396635662e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/6adb3225271041a69cd24ff6c5c99f5f.png" style="max-width: 100%;"></a></p>
<ul>
<li>
<p>可以将bind函数看作是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>
</li>
<li>
<p>调用bind的一般形式：<strong>auto newCallable = bind(callable,arg_list);</strong></p>
</li>
<li>
<p>其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。<strong>当我们调用newCallable时，newCallable会调用callable,并传给它arg_list中的参数。</strong></p>
</li>
<li>
<p>arg_list中的参数可能包含形如_n的名字，其中n是一个整数，这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，以此类推。</p>
</li>
</ul>
<p>例如：</p>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">Sub</span>(<span class="pl-k">int</span> a, <span class="pl-k">int</span> b)
{
	<span class="pl-k">return</span> a - b;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	function&lt;<span class="pl-c1">int</span>(<span class="pl-k">int</span>, <span class="pl-k">int</span>)&gt; f1 = Sub;
	cout &lt;&lt; <span class="pl-c1">f1</span>(<span class="pl-c1">10</span>, <span class="pl-c1">5</span>) &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span> 调整参数顺序</span>
	function&lt;<span class="pl-c1">int</span>(<span class="pl-k">int</span>, <span class="pl-k">int</span>)&gt; f2 = <span class="pl-c1">bind</span>(Sub, placeholders::_2, placeholders::_1);
	cout &lt;&lt; <span class="pl-c1">f2</span>(<span class="pl-c1">10</span>, <span class="pl-c1">5</span>) &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span> 调整参数个数，有些参数可以bind时写死</span>
	function&lt;<span class="pl-c1">int</span>(<span class="pl-k">int</span>)&gt; f3 = <span class="pl-c1">bind</span>(Sub, <span class="pl-c1">20</span>, placeholders::_1);
	cout &lt;&lt; <span class="pl-c1">f3</span>(<span class="pl-c1">5</span>) &lt;&lt; endl;

	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<ul>
<li>我们在使用包装器取类成员，成员函数取地址，比较特殊，要加一个类域和&amp;，还有一个this</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">class</span> <span class="pl-en">Plus</span>
{
<span class="pl-k">public:</span>
	<span class="pl-k">static</span> <span class="pl-k">int</span> <span class="pl-en">plusi</span>(<span class="pl-k">int</span> a, <span class="pl-k">int</span> b)
	{
		<span class="pl-k">return</span> a + b;
	}

	<span class="pl-k">double</span> <span class="pl-en">plusd</span>(<span class="pl-k">double</span> a, <span class="pl-k">double</span> b)
	{
		<span class="pl-k">return</span> a + b;
	}
};

<span class="pl-k">void</span> <span class="pl-en">func</span>(<span class="pl-k">int</span> a, <span class="pl-k">int</span> b, <span class="pl-k">int</span> c)
{
	cout &lt;&lt; a &lt;&lt; endl;
	cout &lt;&lt; b &lt;&lt; endl;
	cout &lt;&lt; c &lt;&lt; endl;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> 静态成员可以不加，但是建议加上&amp;</span>
	function&lt;<span class="pl-c1">int</span>(<span class="pl-k">int</span>, <span class="pl-k">int</span>)&gt; f1 = Plus::plusi;
	cout &lt;&lt; <span class="pl-c1">f1</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>) &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span> 成员函数取地址，比较特殊，要加一个类域和&amp;，还有一个this</span>
	function&lt;<span class="pl-c1">double</span>(Plus*, <span class="pl-k">double</span>, <span class="pl-k">double</span>)&gt; f2 = &amp;Plus::plusd;
	Plus ps; 
	cout &lt;&lt; <span class="pl-c1">f2</span>(&amp;ps, <span class="pl-c1">1.1</span>, <span class="pl-c1">2.2</span>) &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span> 或者这样，也可以</span>
	function&lt;<span class="pl-c1">double</span>(Plus, <span class="pl-k">double</span>, <span class="pl-k">double</span>)&gt; f3 = &amp;Plus::plusd;
	cout &lt;&lt; <span class="pl-c1">f3</span>(<span class="pl-c1">Plus</span>(), <span class="pl-c1">1.11</span>, <span class="pl-c1">2.22</span>) &lt;&lt; endl;

	<span class="pl-c"><span class="pl-c">//</span> 但是上面太麻烦，每次写都需要写</span>
	<span class="pl-c"><span class="pl-c">//</span> 将参数固定bind，就可以省略不写</span>
	function&lt;<span class="pl-c1">double</span>(<span class="pl-k">double</span>, <span class="pl-k">double</span>)&gt; f4 = <span class="pl-c1">bind</span>(&amp;Plus::plusd, <span class="pl-c1">Plus</span>(), placeholders::_1, placeholders::_2);
	cout &lt;&lt; <span class="pl-c1">f4</span>(<span class="pl-c1">1.11</span>, <span class="pl-c1">2.22</span>) &lt;&lt; endl;
	
	<span class="pl-c"><span class="pl-c">//</span> 也可以间隔的绑定</span>
	function&lt;<span class="pl-c1">void</span>(<span class="pl-k">int</span>, <span class="pl-k">int</span>)&gt; f5 = <span class="pl-c1">bind</span>(func, placeholders::_1, <span class="pl-c1">10</span>, placeholders::_2);
	<span class="pl-c1">f5</span>(<span class="pl-c1">1</span>, <span class="pl-c1">3</span>);
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h2>线程库</h2>
<blockquote>
<p>新开篇幅讲解</p>
</blockquote></div>
<div style="font-size:small;margin-top:8px;float:right;">❤️ 转载文章请注明出处，谢谢！❤️</div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://xiaolinzi.eu.org">Shilin' Blog</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("06/29/2024"!=""){
    var startSite=new Date("06/29/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shilinnull/shilinnull.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>


</html>
