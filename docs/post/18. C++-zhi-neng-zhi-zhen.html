<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/108561949?v=4&size=64"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## 内存泄漏

### 什么是内存泄漏，内存泄漏的危害
什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。">
<meta property="og:title" content="18. C++智能指针">
<meta property="og:description" content="## 内存泄漏

### 什么是内存泄漏，内存泄漏的危害
什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://xiaolinzi.eu.org/post/18.%20C%2B%2B-zhi-neng-zhi-zhen.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/108561949?v=4&size=64">
<title>18. C++智能指针</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">18. C++智能指针</h1>
<div class="title-right">
    <a href="https://xiaolinzi.eu.org" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/shilinnull/shilinnull.github.io/issues/20" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2>内存泄漏</h2>
<h3>什么是内存泄漏，内存泄漏的危害</h3>
<p>什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内 存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，失去了对 该段内存的控制，因而造成了内存的浪费。</p>
<p>内存泄漏的危害：长期运行的程序出现内存泄漏，影响很大，如操作系统、后台服务等等，出现 内存泄漏会导致响应越来越慢，最终卡死。</p>
<h3>内存泄漏分类</h3>
<p>C/C++程序中一般我们关心两种方面的内存泄漏：</p>
<ul>
<li>堆内存泄漏(Heap leak)</li>
</ul>
<p>堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一 块内存，用完后必须通过调用相应的 free或者delete 删掉。假设程序的设计错误导致这部分 内存没有被释放，那么以后这部分空间将无法再被使用，就会产生Heap Leak。</p>
<ul>
<li>系统资源泄漏</li>
</ul>
<p>指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</p>
<h3>如何检测内存泄漏</h3>
<p><strong>在linux下内存泄漏检测</strong>：<a href="https://blog.csdn.net/gatieme/article/details/51959654" rel="nofollow">linux下几款内存泄漏检测工具</a><br>
<strong>在windows下使用第三方工具</strong>：<a href="https://blog.csdn.net/GZrhaunt/article/details/56839765" rel="nofollow">VLD工具说明</a><br>
<strong>其他工具</strong>：<a href="https://www.cnblogs.com/liangxiaofeng/p/4318499.html" rel="nofollow">内存泄漏工具比较</a></p>
<h3>如何避免内存泄漏</h3>
<ol>
<li>工程前期良好的设计规范，养成良好的编码规范，申请的内存空间记着匹配的去释放。ps： 这个理想状态。但是如果碰上异常时，就算注意释放了，还是可能会出问题。需要下一条智 能指针来管理才有保证。</li>
<li>采用<strong>RAII</strong>思想或者智能指针来管理资源。</li>
<li>有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项。</li>
<li>出问题了使用内存泄漏工具检测。ps：不过很多工具都不够靠谱，或者收费昂贵。</li>
</ol>
<p><strong>总结一下</strong>: 内存泄漏非常常见，解决方案分为两种：<strong>1、事前预防型。如智能指针等。2、事后查错型。如泄 漏检测工具。</strong></p>
<h2>智能指针的使用及原理</h2>
<h3>RAII</h3>
<p>RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内 存、文件句柄、网络连接、互斥量等等）的简单技术。</p>
<p>在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在 对象析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做 法有两大好处：</p>
<ul>
<li>不需要显式地释放资源。</li>
<li>采用这种方式，对象所需的资源在其生命期内始终保持有效。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span> 使用RAII思想设计的SmartPtr类</span>
<span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">SmartPtr</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">SmartPtr</span>(T* ptr)
		:_ptr(ptr)
	{}

	<span class="pl-en">~SmartPtr</span>()
	{
		<span class="pl-k">delete[]</span> ptr;
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>delete[]<span class="pl-pds">"</span></span> &lt;&lt; _ptr &lt;&lt; endl;
	}

<span class="pl-k">private:</span>
	T* _ptr;
};

<span class="pl-k">double</span> <span class="pl-en">Division</span>(<span class="pl-k">int</span> a, <span class="pl-k">int</span> b)
{
	<span class="pl-k">if</span> (b == <span class="pl-c1">0</span>)
	{
		<span class="pl-k">throw</span> <span class="pl-smi">invalid_argument</span>(<span class="pl-s"><span class="pl-pds">"</span>Division by zero condition!<span class="pl-pds">"</span></span>);
	}
	<span class="pl-k">return</span> (<span class="pl-k">double</span>)a / (<span class="pl-k">double</span>)b;
}

<span class="pl-k">void</span> <span class="pl-en">Func</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> RAII</span>
	SmartPtr&lt;<span class="pl-k">int</span>&gt; <span class="pl-c1">sp1</span>(<span class="pl-k">new</span> <span class="pl-k">int</span>[<span class="pl-c1">10</span>]);
	SmartPtr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">sp1</span>(<span class="pl-k">new</span> <span class="pl-k">double</span>[<span class="pl-c1">10</span>]);

	<span class="pl-k">int</span> len, <span class="pl-c1">time</span>;
	cin &gt;&gt; len &gt;&gt; <span class="pl-c1">time</span>;
	cout &lt;&lt; <span class="pl-c1">Division</span>(len, <span class="pl-c1">time</span>) &lt;&lt; endl; <span class="pl-c"><span class="pl-c">//</span> 除零异常</span>
}


<span class="pl-k">int</span> <span class="pl-en">mian</span>()
{
	<span class="pl-k">try</span>
	{
		<span class="pl-c1">Func</span>();
	}
	<span class="pl-k">catch</span> (<span class="pl-k">const</span> <span class="pl-c1">exception</span>&amp; e)
	{
		cout &lt;&lt; e.<span class="pl-c1">what</span>() &lt;&lt; endl;
	}
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<h3>智能指针的原理</h3>
<ul>
<li>上述的SmartPtr还不能将其称为智能指针，因为它还不具有指针的行为。指针可以解引用，也可 以通过-&gt;去访问所指空间中的内容，因此：AutoPtr模板类中还得需要将* 、-&gt;重载下，才可让其 像指针一样去使用。</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">SmartPtr</span>
{
<span class="pl-k">public:</span>
	<span class="pl-c"><span class="pl-c">//</span> RAII</span>
	<span class="pl-en">SmartPtr</span>(T* ptr)
		:_ptr(ptr)
	{}

	<span class="pl-en">~SmartPtr</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>~SmartPtr()-&gt;<span class="pl-pds">"</span></span> &lt;&lt; _ptr &lt;&lt; endl;

		<span class="pl-k">delete</span> _ptr;
	}

	T&amp; <span class="pl-k">operator</span>*()
	{
		<span class="pl-k">return</span> *_ptr;
	}

	T* <span class="pl-k">operator</span>-&gt;()
	{
		<span class="pl-k">return</span> _ptr;
	}
<span class="pl-k">private:</span>
	T* _ptr;
};</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f9ac152b87a82fcb6ea0a46a1db4c2be5a3f2c8dabef111b283bfa7f177230da/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f36623036313335323230333634313965623732303938353833656539363538332e706e67"><img src="https://camo.githubusercontent.com/f9ac152b87a82fcb6ea0a46a1db4c2be5a3f2c8dabef111b283bfa7f177230da/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f36623036313335323230333634313965623732303938353833656539363538332e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/6b0613522036419eb72098583ee96583.png" style="max-width: 100%;"></a></p>
<p>总结一下智能指针的原理：</p>
<ol>
<li>RAII特性</li>
<li>重载operator*和opertaor-&gt;，具有像指针一样的行为。</li>
</ol>
<h2>std::auto_ptr</h2>
<p><a href="https://legacy.cplusplus.com/reference/memory/auto_ptr/" rel="nofollow">std::auto_ptr文档</a></p>
<ul>
<li>std::auto_ptr std::auto_ptr文档 C++98版本的库中就提供了auto_ptr的智能指针。下面演示的auto_ptr的使用及问题。</li>
<li>auto_ptr的实现原理：管理权转移的思想，下面简化模拟实现了一份bit::auto_ptr来了解它的原理</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">auto_ptr</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">auto_ptr</span>(T* ptr)
		:_ptr(ptr)
	{}

	<span class="pl-en">~auto_ptr</span>()
	{
		<span class="pl-k">if</span> (_ptr)
		{
			cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>~auto_ptr()<span class="pl-pds">"</span></span> &lt;&lt; endl;
			<span class="pl-k">delete</span> _ptr;
			_ptr = <span class="pl-c1">nullptr</span>;
		}
	}
	<span class="pl-en">auto_ptr</span>(auto_ptr&lt;T&gt;&amp; ap)
		:_ptr(ap._ptr)
	{
		_ptr = <span class="pl-c1">nullptr</span>;
	}

	T&amp; <span class="pl-k">operator</span>*()
	{
		<span class="pl-k">return</span> *_ptr;
	}

	T* <span class="pl-k">operator</span>-&gt;()
	{
		<span class="pl-k">return</span> _ptr;
	}

<span class="pl-k">private:</span>
	T* _ptr;
};</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/0e1622883184304f848e4e4be2cb2bd00e2e63693f8c9268187459fb6e4f4d10/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f65313838313835623530353534396365613335663462313765363438396536612e706e67"><img src="https://camo.githubusercontent.com/0e1622883184304f848e4e4be2cb2bd00e2e63693f8c9268187459fb6e4f4d10/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f65313838313835623530353534396365613335663462313765363438396536612e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/e188185b505549cea35f4b17e6489e6a.png" style="max-width: 100%;"></a></p>
<h3>std::unique_ptr</h3>
<ul>
<li>C++11中开始提供更靠谱的unique_ptr</li>
</ul>
<p><a href="https://legacy.cplusplus.com/reference/memory/unique_ptr/" rel="nofollow">unique_ptr文档</a></p>
<ul>
<li>unique_ptr的实现原理：<strong>简单粗暴的防拷贝</strong>，下面简化模拟实现了一份UniquePtr来了解它的原 理</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">unique_ptr</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">unique_ptr</span>()
		:_ptr(<span class="pl-c1">nullptr</span>)
	{}

	<span class="pl-en">~unique_ptr</span>()
	{
		<span class="pl-k">if</span> (_ptr)
		{
			cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>~unique_ptr()<span class="pl-pds">"</span></span> &lt;&lt; endl;
			<span class="pl-k">delete</span> _ptr;
			_ptr = <span class="pl-c1">nullptr</span>;
		}
	}

	T&amp; <span class="pl-k">operator</span>*()
	{
		<span class="pl-k">return</span> *_ptr;
	}

	T* <span class="pl-k">operator</span>-&gt;()
	{
		<span class="pl-k">return</span> _ptr;
	}

	<span class="pl-c"><span class="pl-c">//</span> C++11</span>
	<span class="pl-en">unique_ptr</span>(<span class="pl-k">const</span> unique_ptr&lt;T&gt;&amp; up) = <span class="pl-k">delete</span>;
	unique_ptr&lt;T&gt;&amp; <span class="pl-k">operator</span>=(<span class="pl-k">const</span> unique_ptr&lt;T&gt;&amp; up) = <span class="pl-k">delete</span>;

<span class="pl-k">private:</span>
	<span class="pl-c"><span class="pl-c">//</span> C++98</span>
	<span class="pl-c"><span class="pl-c">//</span> 1、只声明不实现</span>
	<span class="pl-c"><span class="pl-c">//</span> 2、限定为私有</span>
	<span class="pl-c"><span class="pl-c">//</span>unique_ptr(const unique_ptr&lt;T&gt;&amp; up);</span>
	<span class="pl-c"><span class="pl-c">//</span>unique_ptr&lt;T&gt;&amp; operator=(const unique_ptr&lt;T&gt;&amp; up);</span>
<span class="pl-k">private:</span>
	T* _ptr;
};</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3983a5a47a70de2f07d3aed5e85ee749d2810af37a6e2d6d0d45b518ea515cb2/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f61323365336433356463363134373137623562383932363536396534633362382e706e67"><img src="https://camo.githubusercontent.com/3983a5a47a70de2f07d3aed5e85ee749d2810af37a6e2d6d0d45b518ea515cb2/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f61323365336433356463363134373137623562383932363536396534633362382e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/a23e3d35dc614717b5b8926569e4c3b8.png" style="max-width: 100%;"></a></p>
<h3>std::shared_ptr</h3>
<p>C++11中开始提供更靠谱的并且支持拷贝的shared_ptr</p>
<p><a href="https://legacy.cplusplus.com/reference/memory/shared_ptr/" rel="nofollow">std::shared_ptr文档</a></p>
<p>shared_ptr的原理：是通过引用计数的方式来实现多个shared_ptr对象之间共享资源</p>
<ol>
<li>shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共 享。</li>
<li>在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减 一。</li>
<li>如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源；</li>
<li>如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。</li>
</ol>
<ul>
<li>引用计数支持多个拷贝管理同一个资源，最后一个析构对象释放资源</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">shared_ptr</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">shared_ptr</span>(T* ptr = <span class="pl-c1">nullptr</span>)
		:_ptr(ptr)
		,_pcount(<span class="pl-k">new</span> <span class="pl-k">int</span>(<span class="pl-c1">1</span>))
	{}
	<span class="pl-k">void</span> <span class="pl-en">release</span>()
	{
		<span class="pl-k">if</span> (--(*_pcount) == <span class="pl-c1">0</span>)
		{
			<span class="pl-c"><span class="pl-c">//</span> cout &lt;&lt; "~shared_ptr()" &lt;&lt; endl;</span>
			<span class="pl-k">delete</span> _ptr;
			<span class="pl-k">delete</span> _pcount;
			_ptr = <span class="pl-c1">nullptr</span>;
		}
	}

	<span class="pl-en">~shared_ptr</span>()
	{
		<span class="pl-c1">release</span>();
	}
	<span class="pl-c"><span class="pl-c">//</span> sp1 = sp2</span>
	shared_ptr&lt;T&gt;&amp; <span class="pl-k">operator</span>=(<span class="pl-k">const</span> shared_ptr&lt;T&gt;&amp; sp)
	{
		<span class="pl-c"><span class="pl-c">//</span> 防止自己给自己赋值</span>
		<span class="pl-k">if</span> (_ptr != sp.<span class="pl-smi">_ptr</span>)
		{
			<span class="pl-c"><span class="pl-c">//</span> 先释放原来的</span>
			<span class="pl-c1">release</span>();

			_pcount = sp.<span class="pl-smi">_pcount</span>;
			_ptr = sp.<span class="pl-smi">_ptr</span>;

			<span class="pl-c"><span class="pl-c">//</span> ++现在的</span>
			++(*_pcount);
		}
		<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
	}

	T&amp; <span class="pl-k">operator</span>*()
	{
		<span class="pl-k">return</span> *_ptr;
	}

	T* <span class="pl-k">operator</span>-&gt;()
	{
		<span class="pl-k">return</span> _ptr;
	}
	T* <span class="pl-en">get</span>() <span class="pl-k">const</span>
	{
		<span class="pl-k">return</span> _ptr;
	}
	<span class="pl-k">int</span> <span class="pl-en">use_count</span>() <span class="pl-k">const</span>
	{
		<span class="pl-k">return</span> *_pcount;
	}
<span class="pl-k">private:</span>
	T* _ptr;
	<span class="pl-k">int</span>* _pcount;
};</pre></div>
<h3>std::shared_ptr的线程安全问题</h3>
<ul>
<li>通过下面的程序我们来测试shared_ptr的线程安全问题。需要注意的是shared_ptr的线程安全分 为两方面：</li>
</ul>
<ol>
<li>
<p>智能指针对象中引用计数是多个<strong>智能指针对象共享</strong>的，两个线程中智能指针的引用计数同时 ++或--，这个操作<strong>不是原子</strong>的，引用计数原来是1，++了两次，可能还是2，这样引用计数就错乱了。会导致资源未释放或者程序崩溃的问题。所以<strong>智能指针中引用计数++、--是需要加锁</strong>的，也就是说引用计数的操作是线程安全的。</p>
</li>
<li>
<p>智能指针管理的对象存放在堆上，<strong>两个线程中同时去访问，会导致线程安全问题</strong></p>
</li>
</ol>
<ul>
<li><code class="notranslate">shared_ptr</code>本身是线程安全的</li>
<li>但是<strong>保护的资源不是线程安全的</strong></li>
</ul>
<hr>
<ul>
<li>在shared_ptr里的内部<code class="notranslate">_pcount</code>可以改成atomic原子操作，这样引用计数就是原子的</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">shared_ptr</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">shared_ptr</span>(T* ptr = <span class="pl-c1">nullptr</span>)
		:_ptr(ptr)
		, _pcount(<span class="pl-k">new</span> atomic&lt;<span class="pl-k">int</span>&gt;(<span class="pl-c1">1</span>)) <span class="pl-c"><span class="pl-c">//</span> 这里也要改成atomic</span>
	{}

	<span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">D</span>&gt;
	<span class="pl-en">shared_ptr</span>(T* ptr, D del)
		: _ptr(ptr)
		, _pcount(<span class="pl-k">new</span> atomic&lt;<span class="pl-k">int</span>&gt;(<span class="pl-c1">1</span>)) <span class="pl-c"><span class="pl-c">//</span> 这里也要改成atomic</span>
		, _del(del)
	{}

	<span class="pl-k">void</span> <span class="pl-en">release</span>()
	{
		<span class="pl-k">if</span> (--(*_pcount) == <span class="pl-c1">0</span>)
		{
			<span class="pl-c1">_del</span>(_ptr);
			<span class="pl-k">delete</span> _pcount;
		}
	}

	<span class="pl-en">~shared_ptr</span>()
	{
		<span class="pl-c1">release</span>();
	}

	<span class="pl-en">shared_ptr</span>(<span class="pl-k">const</span> shared_ptr&lt;T&gt;&amp; sp)
		:_ptr(sp._ptr)
		, _pcount(sp._pcount)
	{
		++(*_pcount);
	}

	<span class="pl-c"><span class="pl-c">//</span> sp1 = sp3</span>
	shared_ptr&lt;T&gt;&amp; <span class="pl-k">operator</span>=(<span class="pl-k">const</span> shared_ptr&lt;T&gt;&amp; sp)
	{
		<span class="pl-k">if</span> (_ptr != sp.<span class="pl-smi">_ptr</span>)
		{
			<span class="pl-c1">release</span>();

			_ptr = sp.<span class="pl-smi">_ptr</span>;
			_pcount = sp.<span class="pl-smi">_pcount</span>;

			++(*_pcount);
		}

		<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
	}

	<span class="pl-c"><span class="pl-c">//</span> 像指针一样</span>
	T&amp; <span class="pl-k">operator</span>*()
	{
		<span class="pl-k">return</span> *_ptr;
	}

	T* <span class="pl-k">operator</span>-&gt;()
	{
		<span class="pl-k">return</span> _ptr;
	}

	<span class="pl-k">int</span> <span class="pl-en">use_count</span>() <span class="pl-k">const</span>
	{
		<span class="pl-k">return</span> *_pcount;
	}

	T* <span class="pl-en">get</span>() <span class="pl-k">const</span>
	{
		<span class="pl-k">return</span> _ptr;
	}

<span class="pl-k">private:</span>
	T* _ptr;
	atomic&lt;<span class="pl-k">int</span>&gt;* _pcount;          <span class="pl-c"><span class="pl-c">//</span> 原子操作</span>

	function&lt;<span class="pl-k">void</span>(T*)&gt; _del = [](T* ptr) { <span class="pl-k">delete</span> ptr; };
};</pre></div>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-c"><span class="pl-c">//</span> shared_ptr本身是线程安全的</span>
<span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c1">size_t</span> n1 = <span class="pl-c1">100000</span>;
	<span class="pl-c1">size_t</span> n2 = <span class="pl-c1">100000</span>;
	mutex mtx;                <span class="pl-c"><span class="pl-c">//</span> 定义锁</span>
	shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">sp</span>(<span class="pl-k">new</span> <span class="pl-c1">double</span>(<span class="pl-c1">1.1</span>));

	atomic&lt;<span class="pl-c1">size_t</span>&gt; x = <span class="pl-c1">1</span>;  <span class="pl-c"><span class="pl-c">//</span> 定义一个原子变量</span>
	thread <span class="pl-smi">t1</span>([&amp;]() {
		<span class="pl-k">for</span> (<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; n1; i++)
		{
			<span class="pl-c"><span class="pl-c">//</span> 线程安全</span>
			shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">copy1</span>(sp);
			++(*copy1);
			<span class="pl-c"><span class="pl-c">//</span> 线程安全</span>
			shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">copy2</span>(sp);
		}
		});

	thread <span class="pl-smi">t2</span>([&amp;]() {
		<span class="pl-k">for</span> (<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; n2; i++)
		{
			<span class="pl-c"><span class="pl-c">//</span> 线程安全</span>
			shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">copy1</span>(sp);
			++(*copy1);
			<span class="pl-c"><span class="pl-c">//</span> 线程安全</span>
			shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">copy2</span>(sp);
		}
		});

	t1.<span class="pl-c1">join</span>();
	t2.<span class="pl-c1">join</span>();

	<span class="pl-c"><span class="pl-c">//</span> 当前的引用计数</span>
	cout &lt;&lt; sp.<span class="pl-c1">use_count</span>() &lt;&lt; endl;
	cout &lt;&lt; *sp &lt;&lt; endl;
}</pre></div>
<ul>
<li>如果不加锁会导致线程安全的问题</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c1">size_t</span> n1 = <span class="pl-c1">100000</span>;
	<span class="pl-c1">size_t</span> n2 = <span class="pl-c1">100000</span>;
	shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">sp</span>(<span class="pl-k">new</span> <span class="pl-c1">double</span>(<span class="pl-c1">1.1</span>));

	thread <span class="pl-smi">t1</span>([&amp;]() {
		<span class="pl-k">for</span> (<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; n1; i++)
		{
			++(*sp);
		}
		});

	thread <span class="pl-smi">t2</span>([&amp;]() {
		<span class="pl-k">for</span> (<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; n2; i++)
		{
			++(*sp);
		}
		});

	t1.<span class="pl-c1">join</span>();
	t2.<span class="pl-c1">join</span>();

	<span class="pl-c"><span class="pl-c">//</span> 当前的引用计数</span>
	cout &lt;&lt; sp.<span class="pl-c1">use_count</span>() &lt;&lt; endl;
	cout &lt;&lt; *sp &lt;&lt; endl;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/af8737baee2aab2f267e189cabf18aa16360fae0d6212800493caf66b11792ac/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f64633465306431366565306634623135616664386635386164353565383432652e706e67"><img src="https://camo.githubusercontent.com/af8737baee2aab2f267e189cabf18aa16360fae0d6212800493caf66b11792ac/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f64633465306431366565306634623135616664386635386164353565383432652e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/dc4e0d16ee0f4b15afd8f58ad55e842e.png" style="max-width: 100%;"></a></p>
<ul>
<li>所以我们需要进行加锁，然后就可以了~~</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c1">size_t</span> n1 = <span class="pl-c1">100000</span>;
	<span class="pl-c1">size_t</span> n2 = <span class="pl-c1">100000</span>;
	mutex mtx; <span class="pl-c"><span class="pl-c">//</span> 定义锁</span>
	shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">sp</span>(<span class="pl-k">new</span> <span class="pl-c1">double</span>(<span class="pl-c1">1.1</span>));

	thread <span class="pl-smi">t1</span>([&amp;]() {
		<span class="pl-k">for</span> (<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; n1; i++)
		{
			unique_lock&lt;mutex&gt; <span class="pl-c1">lock</span>(mtx);
			++(*sp);
		}
		});

	thread <span class="pl-smi">t2</span>([&amp;]() {
		<span class="pl-k">for</span> (<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; n2; i++)
		{
			unique_lock&lt;mutex&gt; <span class="pl-c1">lock</span>(mtx);
			++(*sp);
		}
		});

	t1.<span class="pl-c1">join</span>();
	t2.<span class="pl-c1">join</span>();

	<span class="pl-c"><span class="pl-c">//</span> 当前的引用计数</span>
	cout &lt;&lt; sp.<span class="pl-c1">use_count</span>() &lt;&lt; endl;
	cout &lt;&lt; *sp &lt;&lt; endl;
}</pre></div>
<ul>
<li>保护的资源也不是线程安全，所以我们要加锁</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">int</span> <span class="pl-en">main</span>()
{
	<span class="pl-c1">size_t</span> n1 = <span class="pl-c1">100000</span>;
	<span class="pl-c1">size_t</span> n2 = <span class="pl-c1">100000</span>;
	mutex mtx; <span class="pl-c"><span class="pl-c">//</span> 定义锁</span>
	shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">sp</span>(<span class="pl-k">new</span> <span class="pl-c1">double</span>(<span class="pl-c1">1.1</span>));

	thread <span class="pl-smi">t1</span>([&amp;]() {
		<span class="pl-k">for</span> (<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; n1; i++)
		{
			<span class="pl-c"><span class="pl-c">//</span> 这个拷贝是线程安全的所以不用加速</span>
			shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">copy1</span>(sp);
			
			<span class="pl-c"><span class="pl-c">//</span> 保护的资源也不是线程安全，所以我们要加锁</span>
			{
				<span class="pl-c"><span class="pl-c">//</span> 在域内加锁解锁</span>
				unique_lock&lt;mutex&gt; <span class="pl-c1">lock</span>(mtx);
				++(*copy1);
			}
		}
		});

	thread <span class="pl-smi">t2</span>([&amp;]() {
		<span class="pl-k">for</span> (<span class="pl-c1">size_t</span> i = <span class="pl-c1">0</span>; i &lt; n2; i++)
		{
			shared_ptr&lt;<span class="pl-k">double</span>&gt; <span class="pl-c1">copy1</span>(sp);
			
			{
				<span class="pl-c"><span class="pl-c">//</span> 在域内加锁解锁</span>
				unique_lock&lt;mutex&gt; <span class="pl-c1">lock</span>(mtx);
				++(*copy1);
			}
		}
		});

	t1.<span class="pl-c1">join</span>();
	t2.<span class="pl-c1">join</span>();

	<span class="pl-c"><span class="pl-c">//</span> 当前的引用计数</span>
	cout &lt;&lt; sp.<span class="pl-c1">use_count</span>() &lt;&lt; endl;
	cout &lt;&lt; *sp &lt;&lt; endl;
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/054be1603c1462cca145a98252f49bc34d53f5da514415e2365aa501a08fbb00/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f66313430353463623537343934646433393035363430373963396330313963372e706e67"><img src="https://camo.githubusercontent.com/054be1603c1462cca145a98252f49bc34d53f5da514415e2365aa501a08fbb00/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f66313430353463623537343934646433393035363430373963396330313963372e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/f14054cb57494dd390564079c9c019c7.png" style="max-width: 100%;"></a></p>
<h3>std::shared_ptr的循环引用</h3>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c7c458774dd34d33a25a50a72ca52ff9235289ea018bc69effff4e6ff00a475d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f33666632326238636338333934346163623265373562363230323866633866632e706e67"><img src="https://camo.githubusercontent.com/c7c458774dd34d33a25a50a72ca52ff9235289ea018bc69effff4e6ff00a475d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f33666632326238636338333934346163623265373562363230323866633866632e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/3ff22b8cc83944acb2e75b62028fc8fc.png" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/c359db938801b1fde0993ef5d08b827eb02fd0ea28822f501497f563ab6f5409/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f33636362303765396266656234666436383631643438343361343637653962322e706e67"><img src="https://camo.githubusercontent.com/c359db938801b1fde0993ef5d08b827eb02fd0ea28822f501497f563ab6f5409/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f33636362303765396266656234666436383631643438343361343637653962322e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/3ccb07e9bfeb4fd6861d4843a467e9b2.png" style="max-width: 100%;"></a></p>
<blockquote>
<p>使用std库里的也会同样导致这样的问题</p>
</blockquote>
<p><strong>循环引用分析：</strong></p>
<ol>
<li>node1和node2两个智能指针对象指向两个节点，引用计数变成1，我们不需要手动 delete。</li>
<li>node1的_next指向node2，node2的_prev指向node1，引用计数变成2。</li>
<li>node1和node2析构，引用计数减到1，但是_next还指向下一个节点。但是_prev还指向上 一个节点。</li>
<li>也就是说_next析构了，node2就释放了。</li>
<li>也就是说_prev析构了，node1就释放了。</li>
<li>但是_next属于node的成员，node1释放了，_next才会析构，而node1由_prev管理，_prev 属于node2成员，所以这就叫循环引用，谁也不会释放。</li>
</ol>
<hr>
<ul>
<li>
<p>解决方案：在引用计数的场景下，把节点中的<code class="notranslate">_prev</code>和<code class="notranslate">_next</code>改成<code class="notranslate">weak_ptr</code>就可以了</p>
</li>
<li>
<p>原理就是：<strong>node1-&gt;_next = node2;和node2-&gt;_prev = node1;时weak_ptr的_next和 _prev不会增加node1和node2的引用计数</strong>。</p>
</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">weak_ptr</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">weak_ptr</span>()
		:_ptr(<span class="pl-c1">nullptr</span>)
	{}

	<span class="pl-en">weak_ptr</span>(<span class="pl-k">const</span> shared_ptr&lt;T&gt;&amp; we)
		:_ptr(we.get())
	{}

	weak_ptr&lt;T&gt;&amp; <span class="pl-k">operator</span>=(<span class="pl-k">const</span> shared_ptr&lt;T&gt;&amp; we)
	{
		_ptr = we.<span class="pl-c1">get</span>();
		<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
	}


	T&amp; <span class="pl-k">operator</span>*()
	{
		<span class="pl-k">return</span> *_ptr;
	}

	T* <span class="pl-k">operator</span>-&gt;()
	{
		<span class="pl-k">return</span> _ptr;
	}

<span class="pl-k">private:</span>
	T* _ptr;
};

<span class="pl-k">struct</span> <span class="pl-en">ListNode</span>
{
	lsl::weak_ptr&lt;ListNode&gt; _next;
	lsl::weak_ptr&lt;ListNode&gt; _prev;
	<span class="pl-k">int</span> val;

	<span class="pl-en">~ListNode</span>()
	{
		cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>~ListNode()<span class="pl-pds">"</span></span> &lt;&lt; endl;
	}
};</pre></div>
<p><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/6e52cbc6309e6128f78b750e4a4c9bd700124eaec648455d09c9c359d1ecf56b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f62376237356632383234643234643838383361376336303533646566373038322e706e67"><img src="https://camo.githubusercontent.com/6e52cbc6309e6128f78b750e4a4c9bd700124eaec648455d09c9c359d1ecf56b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f6469726563742f62376237356632383234643234643838383361376336303533646566373038322e706e67" alt="在这里插入图片描述" data-canonical-src="https://img-blog.csdnimg.cn/direct/b7b75f2824d24d8883a7c6053def7082.png" style="max-width: 100%;"></a></p>
<ul>
<li>如果不是new出来的对象如何通过智能指针管理呢？其实<code class="notranslate">shared_ptr</code>设计了一个删除器来解决这个问题</li>
</ul>
<div class="highlight highlight-source-c++"><pre class="notranslate"><span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">class</span> <span class="pl-en">shared_ptr</span>
{
<span class="pl-k">public:</span>
	<span class="pl-en">shared_ptr</span>(T* ptr = <span class="pl-c1">nullptr</span>)
		:_ptr(ptr)
		, _pcount(<span class="pl-k">new</span> <span class="pl-k">int</span>(<span class="pl-c1">1</span>))
	{}

	<span class="pl-c"><span class="pl-c">//</span> 删除器</span>
	<span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">D</span>&gt;
	<span class="pl-en">shared_ptr</span>(T* ptr, D del)
		: _ptr(ptr)
		, _pcount(<span class="pl-k">new</span> <span class="pl-k">int</span>(<span class="pl-c1">1</span>))
		, _del(del)
	{}
	<span class="pl-k">void</span> <span class="pl-en">release</span>()
	{
		<span class="pl-k">if</span> (--(*_pcount) == <span class="pl-c1">0</span>)
		{
			<span class="pl-c"><span class="pl-c">//</span> cout &lt;&lt; "~shared_ptr()" &lt;&lt; endl;</span>
			<span class="pl-c"><span class="pl-c">//</span> delete _ptr;</span>
			<span class="pl-c1">_del</span>(_ptr);
			<span class="pl-k">delete</span> _pcount;
			_ptr = <span class="pl-c1">nullptr</span>;
		}
	}

	<span class="pl-en">~shared_ptr</span>()
	{
		<span class="pl-c1">release</span>();
	}
	<span class="pl-c"><span class="pl-c">//</span> sp1 = sp2</span>
	shared_ptr&lt;T&gt;&amp; <span class="pl-k">operator</span>=(<span class="pl-k">const</span> shared_ptr&lt;T&gt;&amp; sp)
	{
		<span class="pl-c"><span class="pl-c">//</span> 防止自己给自己赋值</span>
		<span class="pl-k">if</span> (_ptr != sp.<span class="pl-smi">_ptr</span>)
		{
			<span class="pl-c"><span class="pl-c">//</span> 先释放原来的</span>
			<span class="pl-c1">release</span>();

			_pcount = sp.<span class="pl-smi">_pcount</span>;
			_ptr = sp.<span class="pl-smi">_ptr</span>;

			<span class="pl-c"><span class="pl-c">//</span> ++现在的</span>
			++(*_pcount);
		}
		<span class="pl-k">return</span> *<span class="pl-c1">this</span>;
	}

	T&amp; <span class="pl-k">operator</span>*()
	{
		<span class="pl-k">return</span> *_ptr;
	}

	T* <span class="pl-k">operator</span>-&gt;()
	{
		<span class="pl-k">return</span> _ptr;
	}
	T* <span class="pl-en">get</span>() <span class="pl-k">const</span>
	{
		<span class="pl-k">return</span> _ptr;
	}
	<span class="pl-k">int</span> <span class="pl-en">use_count</span>() <span class="pl-k">const</span>
	{
		<span class="pl-k">return</span> *_pcount;
	}
<span class="pl-k">private:</span>
	T* _ptr;
	<span class="pl-k">int</span>* _pcount;
	function&lt;<span class="pl-k">void</span>(T*)&gt; _del = [](T* ptr) { <span class="pl-k">delete</span> ptr; };
};

<span class="pl-k">template</span>&lt;<span class="pl-k">class</span> <span class="pl-en">T</span>&gt;
<span class="pl-k">struct</span> <span class="pl-en">DelArray</span>
{
	<span class="pl-k">void</span> <span class="pl-en">operator</span>()(T* ptr)
	{
		<span class="pl-k">delete[]</span> ptr;
	}
};

<span class="pl-k">void</span> <span class="pl-en">main</span>()
{
	<span class="pl-c"><span class="pl-c">//</span> 定制删除器</span>
	lsl::shared_ptr&lt;ListNode&gt; <span class="pl-c1">sp1</span>(<span class="pl-k">new</span> ListNode[<span class="pl-c1">10</span>], DelArray&lt;ListNode&gt;()); <span class="pl-c"><span class="pl-c">//</span> 调用的仿函数</span>
	lsl::shared_ptr&lt;ListNode&gt; <span class="pl-c1">sp2</span>(<span class="pl-k">new</span> ListNode[<span class="pl-c1">10</span>], [](ListNode* ptr) { <span class="pl-k">delete[]</span> ptr; }); <span class="pl-c"><span class="pl-c">//</span> 使用lambda</span>
	lsl::shared_ptr&lt;FILE&gt; <span class="pl-c1">sp3</span>(<span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>Test.cpp<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>), [](FILE* ptr) { <span class="pl-c1">fclose</span>(ptr); });    <span class="pl-c"><span class="pl-c">//</span> 使用lambda</span>

	lsl::shared_ptr&lt;ListNode&gt; <span class="pl-c1">sp4</span>(<span class="pl-k">new</span> ListNode); <span class="pl-c"><span class="pl-c">//</span> 使用缺省参数</span>
}</pre></div>
<h2>C++11和boost中智能指针的关系</h2>
<ol>
<li>C++ 98 中产生了第一个智能指针auto_ptr.</li>
<li>C++ boost给出了更实用的scoped_ptr和shared_ptr和weak_ptr.</li>
<li>C++ TR1，引入了shared_ptr等。不过注意的是TR1并不是标准版。</li>
<li>C++ 11，引入了unique_ptr和shared_ptr和weak_ptr。需要注意的是unique_ptr对应boost 的scoped_ptr。并且这些智能指针的实现原理是参考boost中的实现的。</li>
</ol></div>
<div style="font-size:small;margin-top:8px;float:right;">❤️ 转载文章请注明出处，谢谢！❤️</div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://xiaolinzi.eu.org">Shilin' Blog</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("06/29/2024"!=""){
    var startSite=new Date("06/29/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","shilinnull/shilinnull.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>


</html>
