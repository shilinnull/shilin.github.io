<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Shilin' Blog</title><link>https://xiaolinzi.eu.org</link><description>珍惜每一天~</description><copyright>Shilin' Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/108561949?v=4&amp;size=64</url><title>avatar</title><link>https://xiaolinzi.eu.org</link></image><lastBuildDate>Tue, 09 Jul 2024 06:52:36 +0000</lastBuildDate><managingEditor>Shilin' Blog</managingEditor><ttl>60</ttl><webMaster>Shilin' Blog</webMaster><item><title>19. C++11线程库操作</title><link>https://xiaolinzi.eu.org/post/19.%20C%2B%2B11-xian-cheng-ku-cao-zuo.html</link><description>&#13;
## 线程库&#13;
&#13;
&#13;
###  thread类的简单介绍&#13;
&#13;
&#13;
- 在C++11之前，涉及到多线程问题，都是和平台相关的，比如windows和linux下各有自己的接 口，这使得代码的可移植性比较差。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/19.%20C%2B%2B11-xian-cheng-ku-cao-zuo.html</guid><pubDate>Tue, 09 Jul 2024 06:51:59 +0000</pubDate></item><item><title>18. C++智能指针</title><link>https://xiaolinzi.eu.org/post/18.%20C%2B%2B-zhi-neng-zhi-zhen.html</link><description>## 内存泄漏&#13;
&#13;
### 什么是内存泄漏，内存泄漏的危害&#13;
什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/18.%20C%2B%2B-zhi-neng-zhi-zhen.html</guid><pubDate>Tue, 09 Jul 2024 06:51:18 +0000</pubDate></item><item><title>17. C++异常</title><link>https://xiaolinzi.eu.org/post/17.%20C%2B%2B-yi-chang.html</link><description>## C语言传统的处理错误的方式&#13;
&#13;
传统的错误处理机制：&#13;
&#13;
1.  终止程序，如assert，缺陷：用户难以接受。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/17.%20C%2B%2B-yi-chang.html</guid><pubDate>Tue, 09 Jul 2024 06:50:42 +0000</pubDate></item><item><title>16. C++11 右值引用和移动语义，完美转发和万能引用，移动构造和移动赋值，可变参数模板，lambda表达式，包装器</title><link>https://xiaolinzi.eu.org/post/16.%20C%2B%2B11%20-you-zhi-yin-yong-he-yi-dong-yu-yi-%EF%BC%8C-wan-mei-zhuan-fa-he-wan-neng-yin-yong-%EF%BC%8C-yi-dong-gou-zao-he-yi-dong-fu-zhi-%EF%BC%8C-ke-bian-can-shu-mo-ban-%EF%BC%8Clambda-biao-da-shi-%EF%BC%8C-bao-zhuang-qi.html</link><description>## C++11简介&#13;
&#13;
&gt;C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/16.%20C%2B%2B11%20-you-zhi-yin-yong-he-yi-dong-yu-yi-%EF%BC%8C-wan-mei-zhuan-fa-he-wan-neng-yin-yong-%EF%BC%8C-yi-dong-gou-zao-he-yi-dong-fu-zhi-%EF%BC%8C-ke-bian-can-shu-mo-ban-%EF%BC%8Clambda-biao-da-shi-%EF%BC%8C-bao-zhuang-qi.html</guid><pubDate>Tue, 09 Jul 2024 04:36:06 +0000</pubDate></item><item><title>15. C++哈希表、哈希桶的实现以及模拟实现封装unordered_map 和 unordered_set &amp;&amp; 位图 &amp;&amp; 布隆过滤器 &amp;&amp; 哈希切割相关</title><link>https://xiaolinzi.eu.org/post/15.%20C%2B%2B-ha-xi-biao-%E3%80%81-ha-xi-tong-de-shi-xian-yi-ji-mo-ni-shi-xian-feng-zhuang-unordered_map%20-he-%20unordered_set%20%26%26%20-wei-tu-%20%26%26%20-bu-long-guo-lv-qi-%20%26%26%20-ha-xi-qie-ge-xiang-guan.html</link><description>## unordered系列关联式容器&#13;
&#13;
- 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到$log_2N$，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/15.%20C%2B%2B-ha-xi-biao-%E3%80%81-ha-xi-tong-de-shi-xian-yi-ji-mo-ni-shi-xian-feng-zhuang-unordered_map%20-he-%20unordered_set%20%26%26%20-wei-tu-%20%26%26%20-bu-long-guo-lv-qi-%20%26%26%20-ha-xi-qie-ge-xiang-guan.html</guid><pubDate>Tue, 09 Jul 2024 04:33:51 +0000</pubDate></item><item><title>14. 红黑树【C++实现】</title><link>https://xiaolinzi.eu.org/post/14.%20-hong-hei-shu-%E3%80%90C%2B%2B-shi-xian-%E3%80%91.html</link><description>## 红黑树的概念&#13;
&#13;
**红黑树**（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型用途是实现关联数组。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/14.%20-hong-hei-shu-%E3%80%90C%2B%2B-shi-xian-%E3%80%91.html</guid><pubDate>Tue, 09 Jul 2024 04:33:28 +0000</pubDate></item><item><title>12. C++二叉搜索树介绍以及实现</title><link>https://xiaolinzi.eu.org/post/12.%20C%2B%2B-er-cha-sou-suo-shu-jie-shao-yi-ji-shi-xian.html</link><description>## 二叉搜索树&#13;
&#13;
### 二叉搜索树概念&#13;
&#13;
&#13;
- 二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:&#13;
&#13;
	- 若它的左子树不为空，则左子树上所有节点的值都小于根节点的值&#13;
	- 若它的右子树不为空，则右子树上所有节点的值都大于根节点的值&#13;
	- 它的左右子树也分别为二叉搜索树&#13;
&#13;
&#13;
&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a9d67fd3c3914e179128d2004c1f734d.png)&#13;
&#13;
&#13;
### 二叉搜索树操作&#13;
&#13;
&#13;
&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3fc378ecb75e4ee5a940c98d1c1ee369.png)&#13;
&#13;
&#13;
```c&#13;
int a[] = {8, 3, 1, 10, 6, 4, 7, 14, 13};&#13;
```&#13;
&#13;
&#13;
&#13;
1. 二叉搜索树的**查找**&#13;
a、从根开始比较，查找，比**根大则往右边走查找，比根小则往左边走查找**。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/12.%20C%2B%2B-er-cha-sou-suo-shu-jie-shao-yi-ji-shi-xian.html</guid><pubDate>Tue, 09 Jul 2024 04:32:46 +0000</pubDate></item><item><title>11. C++多态总结与原理、菱形继承问题</title><link>https://xiaolinzi.eu.org/post/11.%20C%2B%2B-duo-tai-zong-jie-yu-yuan-li-%E3%80%81-ling-xing-ji-cheng-wen-ti.html</link><description>## 多态&#13;
&#13;
&#13;
### 什么是多态&#13;
&#13;
- 生活中的多态，是指的客观的事物在人脑中的主观体现。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/11.%20C%2B%2B-duo-tai-zong-jie-yu-yuan-li-%E3%80%81-ling-xing-ji-cheng-wen-ti.html</guid><pubDate>Tue, 09 Jul 2024 04:32:22 +0000</pubDate></item><item><title>10. C++继承总结</title><link>https://xiaolinzi.eu.org/post/10.%20C%2B%2B-ji-cheng-zong-jie.html</link><description>## 封装&#13;
&#13;
&#13;
&gt;我们之前学了封装，那么封装到底是什么呢？&#13;
&#13;
- 封装&#13;
	-	数据和方法放到一起，把想给外面访问的定义成公有，不想给你访问的定义成私有和保护&#13;
	-	一个类型放到另一个类型里面，通过typedef成员函数调整，封装另一个全新的类型&#13;
&#13;
## 继承的概念及定义&#13;
&#13;
### 继承的概念&#13;
&#13;
- 继承(inheritance)机制是面向对象程序**设计使代码可以复用**的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/10.%20C%2B%2B-ji-cheng-zong-jie.html</guid><pubDate>Tue, 09 Jul 2024 04:30:58 +0000</pubDate></item><item><title>9. C++模板【函数模板与类模板】【非类型模板参数、模板特化和模板分离编译】</title><link>https://xiaolinzi.eu.org/post/9.%20C%2B%2B-mo-ban-%E3%80%90-han-shu-mo-ban-yu-lei-mo-ban-%E3%80%91%E3%80%90-fei-lei-xing-mo-ban-can-shu-%E3%80%81-mo-ban-te-hua-he-mo-ban-fen-li-bian-yi-%E3%80%91.html</link><description>## 前言&#13;
&#13;
- 如何实现一个通用的交换函数呢？&#13;
&#13;
&#13;
```cpp&#13;
void Swap(int&amp; left, int&amp; right)&#13;
{&#13;
	int temp = left;&#13;
	left = right;&#13;
	right = temp;&#13;
}&#13;
void Swap(double&amp; left, double&amp; right)&#13;
{&#13;
	double temp = left;&#13;
	left = right;&#13;
	right = temp;&#13;
}&#13;
void Swap(char&amp; left, char&amp; right)&#13;
{&#13;
	char temp = left;&#13;
	left = right;&#13;
	right = temp;&#13;
}&#13;
// ......&#13;
```&#13;
&#13;
&#13;
使用函数重载虽然可以实现，但是有一下几个不好的地方：&#13;
1. 重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函数&#13;
2. 代码的可维护性比较低，一个出错可能所有的重载均出错&#13;
&#13;
&#13;
那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？&#13;
&#13;
&#13;
- 如果在C++中，也能够存在这样一个模具，通过给这个模具中填充不同材料(类型)，来获得不同材料的铸件(即生成具体类型的代码），那将会节省许多头发。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/9.%20C%2B%2B-mo-ban-%E3%80%90-han-shu-mo-ban-yu-lei-mo-ban-%E3%80%91%E3%80%90-fei-lei-xing-mo-ban-can-shu-%E3%80%81-mo-ban-te-hua-he-mo-ban-fen-li-bian-yi-%E3%80%91.html</guid><pubDate>Mon, 08 Jul 2024 12:16:43 +0000</pubDate></item><item><title>8. C++内存管理学习【new】</title><link>https://xiaolinzi.eu.org/post/8.%20C%2B%2B-nei-cun-guan-li-xue-xi-%E3%80%90new%E3%80%91.html</link><description>&#13;
## 一、C/C++内存分布&#13;
&#13;
- 在学习之前我们先看一下下面这些代码都分布在哪里？&#13;
&#13;
```cpp&#13;
int globalVar = 1;&#13;
static int staticGlobalVar = 1;&#13;
void Test()&#13;
{&#13;
	static int staticVar = 1;&#13;
	int localVar = 1;&#13;
	int num1[10] = { 1, 2, 3, 4 };&#13;
	char char2[] = 'abcd';&#13;
	const char* pChar3 = 'abcd';&#13;
	int* ptr1 = (int*)malloc(sizeof(int) * 4);&#13;
	int* ptr2 = (int*)calloc(4, sizeof(int));&#13;
	int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);&#13;
	free(ptr1);&#13;
	free(ptr3);&#13;
}&#13;
```&#13;
1. 选择题：&#13;
&gt;选项: A.栈 B.堆 C.数据段(静态区) D.代码段(常量区)&#13;
&#13;
- globalVar在哪里？__C__ &#13;
- staticGlobalVar在哪里？__C__&#13;
- staticVar在哪里？__C__ &#13;
- localVar在哪里？__A__&#13;
- num1 在哪里？__A__ &#13;
&#13;
---&#13;
&#13;
- char2在哪里？__A__ &#13;
	- 字符串在常量区，char2会栈上开辟一个数组，然后将常量区的字符串拷贝过到栈上，所以结果是A，上题的num1是直接在栈上开辟的，所以相似&#13;
- *char2在哪里？__A__&#13;
	- 这个上题说过了不讲了&#13;
- pChar3在哪里？__A__ &#13;
	- const修饰的是代表常变量，不代表就在常量区，pChar3是栈上的一个变量，指向了常量区的字符串&#13;
- *pChar3在哪里？__D__&#13;
	- 常量区的字符串，解引用就是找的常量区	&#13;
- ptr1在哪里？__A__&#13;
	- 也是栈上的一块变量 &#13;
- *ptr1在哪里？__B__&#13;
	- 开辟的空间在堆上&#13;
&#13;
---&#13;
&#13;
2. 填空题：&#13;
&#13;
   - sizeof(num1) = __40__;&#13;
&#13;
&#13;
   - sizeof(char2) = __5__; &#13;
   - strlen(char2) = __4__;&#13;
   - sizeof(pChar3) = __4/8__;&#13;
   - strlen(pChar3) = __4__;&#13;
   - sizeof(ptr1) = __4/8__;&#13;
&#13;
3. sizeof 和 strlen 区别？&#13;
   - 这里已经在学习C语言章节里说了就不再细说了&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/222e5053152349748dfbb7221935ef4e.png)&#13;
&#13;
&#13;
&#13;
&#13;
【说明】&#13;
1. 栈又叫堆栈--非静态局部变量/函数参数/返回值等等，栈是向下增长的。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/8.%20C%2B%2B-nei-cun-guan-li-xue-xi-%E3%80%90new%E3%80%91.html</guid><pubDate>Mon, 08 Jul 2024 12:16:26 +0000</pubDate></item><item><title>7. C++初始化列表、static成员、友元、匿名对象、附练习题</title><link>https://xiaolinzi.eu.org/post/7.%20C%2B%2B-chu-shi-hua-lie-biao-%E3%80%81static-cheng-yuan-%E3%80%81-you-yuan-%E3%80%81-ni-ming-dui-xiang-%E3%80%81-fu-lian-xi-ti.html</link><description>&#13;
## 前言&#13;
&gt;我们前面学习了关于类和对象的6个默认成员函数，知道了一个空类中有构造函数和析构函数，通过对对象初始化和对象中进行资源清理，达到初始化和销毁的作用。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/7.%20C%2B%2B-chu-shi-hua-lie-biao-%E3%80%81static-cheng-yuan-%E3%80%81-you-yuan-%E3%80%81-ni-ming-dui-xiang-%E3%80%81-fu-lian-xi-ti.html</guid><pubDate>Mon, 08 Jul 2024 12:02:43 +0000</pubDate></item><item><title>6. C++中默认成员函数【取地址重载】【const成员函数】 【运算符重载】【实现一个日期类】</title><link>https://xiaolinzi.eu.org/post/6.%20C%2B%2B-zhong-mo-ren-cheng-yuan-han-shu-%E3%80%90-qu-di-zhi-zhong-zai-%E3%80%91%E3%80%90const-cheng-yuan-han-shu-%E3%80%91%20%E3%80%90-yun-suan-fu-zhong-zai-%E3%80%91%E3%80%90-shi-xian-yi-ge-ri-qi-lei-%E3%80%91.html</link><description>## 一、【C++】赋值运算符重载&#13;
&#13;
&#13;
### 1.1 运算符重载【引入】&#13;
&#13;
- C++为了增强代码的可读性引入了**运算符重载**，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/6.%20C%2B%2B-zhong-mo-ren-cheng-yuan-han-shu-%E3%80%90-qu-di-zhi-zhong-zai-%E3%80%91%E3%80%90const-cheng-yuan-han-shu-%E3%80%91%20%E3%80%90-yun-suan-fu-zhong-zai-%E3%80%91%E3%80%90-shi-xian-yi-ge-ri-qi-lei-%E3%80%91.html</guid><pubDate>Mon, 08 Jul 2024 04:47:57 +0000</pubDate></item><item><title>5. C++中类的6个默认成员函数【构造函数】【析构函数】【拷贝构造】</title><link>https://xiaolinzi.eu.org/post/5.%20C%2B%2B-zhong-lei-de-6-ge-mo-ren-cheng-yuan-han-shu-%E3%80%90-gou-zao-han-shu-%E3%80%91%E3%80%90-xi-gou-han-shu-%E3%80%91%E3%80%90-kao-bei-gou-zao-%E3%80%91.html</link><description>## 前言&#13;
&#13;
&gt;在学习C++我们必须要掌握的6个默认成员函数，接下来我们挨个学习：&#13;
&#13;
## 构造函数&#13;
&#13;
&#13;
- 如果一个类中什么成员都没有，简称为空类。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/5.%20C%2B%2B-zhong-lei-de-6-ge-mo-ren-cheng-yuan-han-shu-%E3%80%90-gou-zao-han-shu-%E3%80%91%E3%80%90-xi-gou-han-shu-%E3%80%91%E3%80%90-kao-bei-gou-zao-%E3%80%91.html</guid><pubDate>Wed, 03 Jul 2024 07:50:15 +0000</pubDate></item><item><title>4. C++引用、内联函数、auto关键字介绍以及C++中无法使用NULL的原因</title><link>https://xiaolinzi.eu.org/post/4.%20C%2B%2B-yin-yong-%E3%80%81-nei-lian-han-shu-%E3%80%81auto-guan-jian-zi-jie-shao-yi-ji-C%2B%2B-zhong-wu-fa-shi-yong-NULL-de-yuan-yin.html</link><description>## 一、引用&#13;
### 1.1 引用概念&#13;
&#13;
&gt;C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/4.%20C%2B%2B-yin-yong-%E3%80%81-nei-lian-han-shu-%E3%80%81auto-guan-jian-zi-jie-shao-yi-ji-C%2B%2B-zhong-wu-fa-shi-yong-NULL-de-yuan-yin.html</guid><pubDate>Wed, 03 Jul 2024 01:57:21 +0000</pubDate></item><item><title>3. C++类和对象引入以及类的介绍使用</title><link>https://xiaolinzi.eu.org/post/3.%20C%2B%2B-lei-he-dui-xiang-yin-ru-yi-ji-lei-de-jie-shao-shi-yong.html</link><description>## 一、面向过程和面向对象的初步认识&#13;
&#13;
&gt;C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/3.%20C%2B%2B-lei-he-dui-xiang-yin-ru-yi-ji-lei-de-jie-shao-shi-yong.html</guid><pubDate>Mon, 01 Jul 2024 09:04:16 +0000</pubDate></item><item><title>2. C++中隐含的this指针讲解</title><link>https://xiaolinzi.eu.org/post/2.%20C%2B%2B-zhong-yin-han-de-this-zhi-zhen-jiang-jie.html</link><description>&#13;
## 一、this指针的引出&#13;
&#13;
&#13;
- 我们先来定义一个日期类`Date`，下面这段代码执行的结果是什么呢？&#13;
&#13;
&#13;
```cpp&#13;
class Date&#13;
{&#13;
public:&#13;
	void Init(int year, int month, int day)&#13;
	{&#13;
		_year = year;&#13;
		_month = month;&#13;
		_day = day;&#13;
	}&#13;
	void print()&#13;
	{&#13;
		cout &lt;&lt; _year &lt;&lt; '-' &lt;&lt; _month &lt;&lt; '-' &lt;&lt; _day &lt;&lt; endl;&#13;
		&#13;
	}&#13;
private:&#13;
	int _year; &#13;
	int _month; &#13;
	int _day; &#13;
};&#13;
int main()&#13;
{&#13;
	Date d1, d2;&#13;
	&#13;
	d1.Init(2022, 5, 11);&#13;
	d2.Init(2022, 5, 12);&#13;
&#13;
	d1.print();&#13;
	d2.print();&#13;
	return 0;&#13;
}&#13;
```&#13;
&#13;
- 可以看到分别打印出了**两个日期**，它是怎么知道改打印哪个的？&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6069c982dacd4e20840ca421e99ce0d1.png)&#13;
&#13;
&#13;
- 我们来分析一下，先看一下**汇编代码，看一看**&#13;
&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/dba395b3dc58423b92fa5d0b44abdfcb.png)&#13;
&#13;
&#13;
----&#13;
&#13;
- 我们看到上面的代码是调用的**同一个函数**，那么编译器是如何知道那两个日期的？&#13;
&#13;
- 其实C++里有一个**隐含**的**this指针**，在[微软的官方文档](https://learn.microsoft.com/zh-cn/cpp/cpp/this-pointer?view=msvc-170)也有说明&#13;
&#13;
- 在使用函数的时候其实里面**传了一个地址，然后有一个隐的this指针来接收**&#13;
&#13;
---&#13;
&#13;
&gt;原形是这样：&#13;
&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fcc3f5a320bb4692a65474ddce4eba88.png)&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/da0b81f7cab34af0898930cb25b289a0.png)&#13;
&#13;
&#13;
- 那为什么这里**报错**了呢？&#13;
- 因为不必要写，这个是**隐含**的~~，我们可以**直接在类里面使用**&#13;
&#13;
&#13;
&#13;
## 二、this指针的特性&#13;
&#13;
- 刚刚上面也给你看了原形，细心的烙铁已经发现了，这个this指针是有一个**const修饰**的，而且这个const是在`*`的右边&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d561f02819e2498f9f842af479520663.png)&#13;
&#13;
&#13;
- 这里的`const`修饰，在`const`的右边&#13;
&#13;
- 下面我们回忆一下~&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/221ab0d8a51540be90c5c7d5ff12f0a7.png)&#13;
&#13;
- 到这里就得出的**this本身是不被修改的，但是做指向的值是可以被修改**&#13;
&#13;
- 我们可以在类中打印一下`this`指针的地址，再打印一下`d1`和`d2`的地址，我们来看一下：&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/26696d96afce46419aeca6760ef18445.png)&#13;
&#13;
- 得到结果就是this指针指向一个指向**当前对象**的指针&#13;
&#13;
---&#13;
&#13;
- 我们还可以下面这样，是不会报错的，但是不能向上面直接在形参就写上&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f76630adebed4fdcbd84da92faaf531c.png)&#13;
&#13;
特点：&#13;
&#13;
**1、形参和实参的位置，我们不能显示写&#13;
2、函数内部可以使用**&#13;
&#13;
---&#13;
&#13;
- **最后总结一下：**&#13;
&#13;
1. this指针的类型：类型 **\*const**，即成员函数中，**不能给this指针赋值**。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/2.%20C%2B%2B-zhong-yin-han-de-this-zhi-zhen-jiang-jie.html</guid><pubDate>Sun, 30 Jun 2024 07:46:08 +0000</pubDate></item><item><title>1. C++的关键字，命名空间，缺省参数，函数重载以及原理</title><link>https://xiaolinzi.eu.org/post/1.%20C%2B%2B-de-guan-jian-zi-%EF%BC%8C-ming-ming-kong-jian-%EF%BC%8C-que-sheng-can-shu-%EF%BC%8C-han-shu-zhong-zai-yi-ji-yuan-li.html</link><description>&#13;
# 前言&#13;
&#13;
&#13;
&gt;从今天开始就序列更新C++的文章了，希望大家可以耐心的坚持下去学习，有一个很好的成长~~&#13;
&#13;
&#13;
首先来看一下C++的介绍，百度百科C++ -- &gt;[点我跳转](https://baike.baidu.com/item/C++/99272)&#13;
&#13;
&#13;
&gt;C++是在C的基础之上，容纳进去了面向对象编程思想，并增加了许多有用的库，以及编程范式等。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/1.%20C%2B%2B-de-guan-jian-zi-%EF%BC%8C-ming-ming-kong-jian-%EF%BC%8C-que-sheng-can-shu-%EF%BC%8C-han-shu-zhong-zai-yi-ji-yuan-li.html</guid><pubDate>Sat, 29 Jun 2024 09:28:19 +0000</pubDate></item><item><title>记录我的搭建的第一篇博客</title><link>https://xiaolinzi.eu.org/post/ji-lu-wo-de-da-jian-de-di-yi-pian-bo-ke.html</link><description>我的第一篇博客，发一些学习内容笔记~。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/ji-lu-wo-de-da-jian-de-di-yi-pian-bo-ke.html</guid><pubDate>Sat, 29 Jun 2024 04:33:28 +0000</pubDate></item></channel></rss>