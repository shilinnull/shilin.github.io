<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Shilin' Blog</title><link>https://xiaolinzi.eu.org</link><description>珍惜每一天~</description><copyright>Shilin' Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/108561949?v=4&amp;size=64</url><title>avatar</title><link>https://xiaolinzi.eu.org</link></image><lastBuildDate>Sat, 20 Jul 2024 14:00:49 +0000</lastBuildDate><managingEditor>Shilin' Blog</managingEditor><ttl>60</ttl><webMaster>Shilin' Blog</webMaster><item><title>8. 【数据结构】堆排序的实现</title><link>https://xiaolinzi.eu.org/post/8.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-dui-pai-xu-de-shi-xian.html</link><description>这里堆排序首先建堆，建堆是要建小堆还是大堆呢？&#13;
&#13;
&gt;- 在堆排序算法中，建立大顶堆的过程是为了确保堆的根节点是整个堆中最大的元素。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/8.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-dui-pai-xu-de-shi-xian.html</guid><pubDate>Sat, 20 Jul 2024 14:00:26 +0000</pubDate></item><item><title>6. 【数据结构】队列的实现</title><link>https://xiaolinzi.eu.org/post/6.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-dui-lie-de-shi-xian.html</link><description>&#13;
## 队列的概念及结构&#13;
&#13;
- 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出`FIFO(First In First Out)` &#13;
- 入队列：进行插入操作的一端称为队尾 出队列：进行删除操作的一端称为队头&#13;
&#13;
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b32fa608920d43c2a87f283132dc57ab.png)&#13;
&#13;
&#13;
## 队列的实现&#13;
&#13;
- 队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构， 出队列在数组头上出数据，效率会比较低。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/6.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-dui-lie-de-shi-xian.html</guid><pubDate>Sat, 20 Jul 2024 13:59:43 +0000</pubDate></item><item><title>5. 【数据结构】栈的实现</title><link>https://xiaolinzi.eu.org/post/5.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-zhan-de-shi-xian.html</link><description>&#13;
## 栈的概念及结构&#13;
&#13;
- 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/5.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-zhan-de-shi-xian.html</guid><pubDate>Sat, 20 Jul 2024 13:58:48 +0000</pubDate></item><item><title>4. 【数据结构】带头双向循环链表专题</title><link>https://xiaolinzi.eu.org/post/4.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-dai-tou-shuang-xiang-xun-huan-lian-biao-zhuan-ti.html</link><description>## 带头双向循环链表的结构&#13;
&#13;
&#13;
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2299c09095914b738e095af0cc1a6b10.png)&#13;
&#13;
&#13;
- 注意：这里的“带头”跟前面我们说的“头节点”是两个概念，实际前面的在单链表阶段称呼不严&#13;
谨，但是为了同学们更好的理解就直接称为单链表的头节点。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/4.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-dai-tou-shuang-xiang-xun-huan-lian-biao-zhuan-ti.html</guid><pubDate>Sat, 20 Jul 2024 13:52:13 +0000</pubDate></item><item><title>3. 【数据结构】单链表专题</title><link>https://xiaolinzi.eu.org/post/3.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-dan-lian-biao-zhuan-ti.html</link><description>&gt;顺序表遗留下来的问题：&#13;
&#13;
1. 中间/头部的插⼊删除，时间复杂度为O(N)&#13;
2. 增容需要申请新空间，拷贝数据，释放旧空间。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/3.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-dan-lian-biao-zhuan-ti.html</guid><pubDate>Sat, 20 Jul 2024 13:51:52 +0000</pubDate></item><item><title>2. 【数据结构】顺序表专题</title><link>https://xiaolinzi.eu.org/post/2.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-shun-xu-biao-zhuan-ti.html</link><description># 一、课前准备&#13;
## 1. 目标&#13;
&#13;
- C语言语法基础到数据结构与算法，前面已经掌握并具备了扎实的C语言基础，为什么要学习数据结构课程？⸺ **通讯录项目**&#13;
&#13;
&#13;
## 2. 需要的储备知识&#13;
- 简单了解，通讯录具备增加、删除、修改、查找联系⼈等操作。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/2.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-shun-xu-biao-zhuan-ti.html</guid><pubDate>Sat, 20 Jul 2024 07:22:17 +0000</pubDate></item><item><title>1. 【数据结构】算法的时间复杂度和空间复杂度</title><link>https://xiaolinzi.eu.org/post/1.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-suan-fa-de-shi-jian-fu-za-du-he-kong-jian-fu-za-du.html</link><description>## 1. 什么是数据结构？&#13;
&gt;数据结构(Data Structure)是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/1.%20%E3%80%90-shu-ju-jie-gou-%E3%80%91-suan-fa-de-shi-jian-fu-za-du-he-kong-jian-fu-za-du.html</guid><pubDate>Sat, 20 Jul 2024 07:19:55 +0000</pubDate></item><item><title>15. C生万物之详解程序环境和预处理</title><link>https://xiaolinzi.eu.org/post/15.%20C-sheng-wan-wu-zhi-xiang-jie-cheng-xu-huan-jing-he-yu-chu-li.html</link><description>## 一、程序的翻译环境和执行环境&#13;
&#13;
在**ANSI C**的任何一种实现中，存在两个不同的环境&#13;
&#13;
&gt; 第1种是`翻译环境`，在这个环境中源代码被转换为**可执行的机器指令**。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/15.%20C-sheng-wan-wu-zhi-xiang-jie-cheng-xu-huan-jing-he-yu-chu-li.html</guid><pubDate>Mon, 15 Jul 2024 10:21:47 +0000</pubDate></item><item><title>14. C生万物之文件操作</title><link>https://xiaolinzi.eu.org/post/14.%20C-sheng-wan-wu-zhi-wen-jian-cao-zuo.html</link><description>## 一、为什么使用文件？&#13;
&#13;
- 我们前面学习结构体时，写了**通讯录的程序**，当通讯录运行起来的时候，可以给通讯录中增加、删除数据，此时数据是存放在内存中，当程序退出的时候，通讯录中的数据自然就不存在了，等下次运行通讯录程序的时候，**数据又得重新录入**，如果使用这样的通讯录就很难受&#13;
&#13;
- 所以就想到了通讯录就应该把**信息记录下来**，只有我们自己选择删除数据的时候，数据才不复存在。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/14.%20C-sheng-wan-wu-zhi-wen-jian-cao-zuo.html</guid><pubDate>Mon, 15 Jul 2024 10:21:31 +0000</pubDate></item><item><title>13. C生万物之动态内存管理</title><link>https://xiaolinzi.eu.org/post/13.%20C-sheng-wan-wu-zhi-dong-tai-nei-cun-guan-li.html</link><description>## 一、为什么存在动态内存分配&#13;
&#13;
我们已经掌握的内存开辟方式有：&#13;
&#13;
```c&#13;
int val = 20;	//在栈空间上开辟四个字节&#13;
char arr[10] = {0};	//在栈空间上开辟10个字节的连续空间&#13;
```&#13;
&#13;
但是上述的开辟空间的方式有两个特点：&#13;
&#13;
1. **空间开辟大小是固定的**&#13;
2. **数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配**&#13;
&#13;
-  那此时呢我们就希望有一种方式，可以在程序运行的过程中动态地去开辟当前程序所需要的内存空间，此时就需要使用到我们的【动态内存函数】了&#13;
&#13;
## 二、动态内存函数的介绍&#13;
&#13;
&gt; 本文我总共会介绍三种动态内存函数，分别是`malloc()`、`calloc()`、`realloc()`，与之对应内存释放函数还有`free()`&#13;
&#13;
### 1、malloc和free&#13;
&#13;
【函数原型】：&#13;
&#13;
```c&#13;
void* malloc (size_t size);&#13;
```&#13;
&#13;
[malloc](https://legacy.cplusplus.com/reference/cstdlib/malloc/?kw=malloc)&#13;
&#13;
- 首先我们来看一下`malloc()`这个函数，它会向内存申请一块连续可用的空间，并返回指向这块空间的指针&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/9432b11ac4964955a8687e04ca8aae3e.png)&#13;
&#13;
【特点】：&#13;
&#13;
1. 如果开辟成功，则返回一个指向开辟好空间的指针&#13;
2. 如果开辟失败，则返回一个`NULL`指针，因此malloc的返回值一定要做检查&#13;
- 那么在什么情况下开辟失败呢？&#13;
&gt;申请的内存过大就会开辟失败，所以就要判断是不是空指针，然后再进行使用&#13;
3. 返回值的类型是`void*` ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定&#13;
----&#13;
&gt;在内存中的布局是这样的：&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/199355bb723547b7866d3d0c7f54f403.png)&#13;
&#13;
----&#13;
&gt; 这里我们来举一个例子说明一下&#13;
&#13;
- 可以看到，我在使用一个动态开辟出来的内存时分配四步走（不止四步），首先使用到`malloc()`函数去向内存申请大小为40的空间，由于其返回值是一个`void*`的指针，可以接收任何类型的指针，所以这里我去做了一个强转，将这块空间强制类型转换为`int*`&#13;
- 上面说到在开辟空间的时候会有失败的可能性，所以我们要去做一个异常判断，若是这个指针为空的话，表明我们完全没有申请到相应的空间，那这个时候再去对这块地址进行操作的话就会造成空指针异常的问题&#13;
- 在明确这块空间被开辟出来后，我们要先去做一个初始化操作，在初始化后就是将其去进行一个打印的操作&#13;
&#13;
```c&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
int main()&#13;
{&#13;
	// 1.开辟空间&#13;
	int* p = (int *)malloc(40);&#13;
	&#13;
	// 2.异常判断&#13;
	if (NULL == p)&#13;
	{&#13;
		perror('malloc fail');&#13;
		exit(-1);&#13;
	}&#13;
&#13;
	// 3.初始化空间&#13;
	for (int i = 0; i &lt; 10; ++i)&#13;
	{&#13;
		*(p + i) = i + 1;&#13;
	}&#13;
&#13;
	// 4.打印观察&#13;
	for (int i = 0; i &lt; 10; ++i)&#13;
	{&#13;
		printf('%d ', *(p + i));&#13;
	}&#13;
	return 0;&#13;
}&#13;
```&#13;
&#13;
- 我们通过调试来进行观察，便可以发现我们刚好将所开辟的40个空间存放了10个整型数据&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/9f7768a25d854dbf86ce9f70782b1249.png)&#13;
&#13;
&#13;
1. 如果参数`size`为0，malloc的行为是标准是未定义的，取决于编译器。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/13.%20C-sheng-wan-wu-zhi-dong-tai-nei-cun-guan-li.html</guid><pubDate>Mon, 15 Jul 2024 10:18:43 +0000</pubDate></item><item><title>12. C生万物之详解结构体、枚举与联合体</title><link>https://xiaolinzi.eu.org/post/12.%20C-sheng-wan-wu-zhi-xiang-jie-jie-gou-ti-%E3%80%81-mei-ju-yu-lian-he-ti.html</link><description>## 一、结构体的声明&#13;
&#13;
### 1、结构的基础知识&#13;
&#13;
&gt; 结构是一些值的集合，这些值称为**成员变量**。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/12.%20C-sheng-wan-wu-zhi-xiang-jie-jie-gou-ti-%E3%80%81-mei-ju-yu-lian-he-ti.html</guid><pubDate>Mon, 15 Jul 2024 10:18:27 +0000</pubDate></item><item><title>11. C语言之字符函数、字符串函数与内存函数</title><link>https://xiaolinzi.eu.org/post/11.%20C-yu-yan-zhi-zi-fu-han-shu-%E3%80%81-zi-fu-chuan-han-shu-yu-nei-cun-han-shu.html</link><description>&#13;
## 一、字符分类函数&#13;
&#13;
- C语言中有一系列的函数是专门做字符分类的，也就是一个字符是属于什么类型的字符的。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/11.%20C-yu-yan-zhi-zi-fu-han-shu-%E3%80%81-zi-fu-chuan-han-shu-yu-nei-cun-han-shu.html</guid><pubDate>Mon, 15 Jul 2024 10:16:32 +0000</pubDate></item><item><title>10. C语言之从浅入深一步一步全方位理解指针【附笔试题】（2）</title><link>https://xiaolinzi.eu.org/post/10.%20C-yu-yan-zhi-cong-qian-ru-shen-yi-bu-yi-bu-quan-fang-wei-li-jie-zhi-zhen-%E3%80%90-fu-bi-shi-ti-%E3%80%91%EF%BC%882%EF%BC%89.html</link><description>&#13;
&#13;
&#13;
## 一、回调函数是什么？&#13;
- 回调函数就是一个`通过函数指针调用的函数`。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/10.%20C-yu-yan-zhi-cong-qian-ru-shen-yi-bu-yi-bu-quan-fang-wei-li-jie-zhi-zhen-%E3%80%90-fu-bi-shi-ti-%E3%80%91%EF%BC%882%EF%BC%89.html</guid><pubDate>Mon, 15 Jul 2024 10:15:31 +0000</pubDate></item><item><title>10. C语言之从浅入深一步一步全方位理解指针【附笔试题】（1）</title><link>https://xiaolinzi.eu.org/post/10.%20C-yu-yan-zhi-cong-qian-ru-shen-yi-bu-yi-bu-quan-fang-wei-li-jie-zhi-zhen-%E3%80%90-fu-bi-shi-ti-%E3%80%91%EF%BC%881%EF%BC%89.html</link><description>&#13;
  - 二楼：201，202，203....&#13;
&#13;
&#13;
有了房间号，如果你的朋友得到房间号，就可以快速的找房间，找到你。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/10.%20C-yu-yan-zhi-cong-qian-ru-shen-yi-bu-yi-bu-quan-fang-wei-li-jie-zhi-zhen-%E3%80%90-fu-bi-shi-ti-%E3%80%91%EF%BC%881%EF%BC%89.html</guid><pubDate>Mon, 15 Jul 2024 10:15:00 +0000</pubDate></item><item><title>9. C语言之数据在计算机内部的存储</title><link>https://xiaolinzi.eu.org/post/9.%20C-yu-yan-zhi-shu-ju-zai-ji-suan-ji-nei-bu-de-cun-chu.html</link><description>## 一、前言&#13;
&#13;
前面我们已经学习了基本的内置类型，以及他们所占存储空间的大小~~&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/d6f2c59a258a4628852444bb835ed062.png)&#13;
&#13;
&#13;
**类型的意义：**&#13;
&#13;
1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）&#13;
2. 如何看待内存空间的视角&#13;
&#13;
## 二、类型的基本归类&#13;
&#13;
### 1、整型家族&#13;
&#13;
- 下面是整形家族&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/2a778c9fa5c3420ba736227437b76642.png)&#13;
&#13;
&#13;
-  char在字符存储的时候存的是一个ASCLL码值，而ASCLL码值是一个整数&#13;
&#13;
-  数值有正数和负数之分&#13;
 	 - 有些数值只有正数，没有负数（身高）—— unsigned&#13;
 	 - 有些数值，有正数也有负数（温度）—— signed&#13;
&#13;
&#13;
### 2、浮点数家族&#13;
&#13;
- 浮点数只分为两类，一个是【float】，一个是【double】&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/ec63c617e00d4c7f8a3232de357c21d3.png)&#13;
&#13;
&#13;
### 3、构造类型&#13;
&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/3085f6af579b4e128a89e1e892b96492.png)&#13;
&#13;
&#13;
&#13;
### 4、指针类型&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/009011ba72ba49bba05fc1cf2cd1a08a.png)&#13;
&#13;
&#13;
 -下面我们来介绍一下这个空指针&#13;
- `void*`叫做【空指针】&#13;
  - 对于int类型的指针可以用来接收int类型的数据的地址&#13;
  - 对于char类型的指针可以用来接收char类型的数据的地址&#13;
  - 对于float类型的指针可以用来接收float类型的数据的地址&#13;
-  对于`void`类型的指针可以用来接收任何类型数据的地址【它就像一个垃圾桶一样，起到临时存放的作用】&#13;
&#13;
&#13;
&gt; void 表示空类型（无类型）&#13;
&gt; 通常应用于函数的返回类型、函数的参数、指针类型&#13;
&#13;
## 三、整型在内存中的存储&#13;
&#13;
### 1、原码、反码、补码&#13;
&#13;
#### 1.1 概念&#13;
&#13;
计算机中的整数有三种2进制表示方法，即原码、反码和补码。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/9.%20C-yu-yan-zhi-shu-ju-zai-ji-suan-ji-nei-bu-de-cun-chu.html</guid><pubDate>Mon, 15 Jul 2024 10:10:57 +0000</pubDate></item><item><title>8. C语言之操作符详解</title><link>https://xiaolinzi.eu.org/post/8.%20C-yu-yan-zhi-cao-zuo-fu-xiang-jie.html</link><description>## 一、算术操作符&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/b665f25d5d764c4697b5a003dd2fb930.png)&#13;
&#13;
&#13;
&#13;
&#13;
- 除了 【%】 操作符之外，其他的几个操作符可以作用于整数和浮点数。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/8.%20C-yu-yan-zhi-cao-zuo-fu-xiang-jie.html</guid><pubDate>Mon, 15 Jul 2024 10:08:49 +0000</pubDate></item><item><title>7. C语言之反汇编查看函数栈帧的创建与销毁</title><link>https://xiaolinzi.eu.org/post/7.%20C-yu-yan-zhi-fan-hui-bian-cha-kan-han-shu-zhan-zheng-de-chuang-jian-yu-xiao-hui.html</link><description># 一、 什么是函数栈帧？&#13;
&#13;
&#13;
**函数栈帧是用于在计算机程序中实现函数调用的一种数据结构。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/7.%20C-yu-yan-zhi-fan-hui-bian-cha-kan-han-shu-zhan-zheng-de-chuang-jian-yu-xiao-hui.html</guid><pubDate>Mon, 15 Jul 2024 10:07:54 +0000</pubDate></item><item><title>6. C语言之函数以及例题分析</title><link>https://xiaolinzi.eu.org/post/6.%20C-yu-yan-zhi-han-shu-yi-ji-li-ti-fen-xi.html</link><description># 前言&#13;
&gt;在C语言中，这个函数时必不可少的，没有函数没有灵魂，要不然代码就会乱成一团，所以我们要学函数，接下来就开始函数之旅~~&#13;
&#13;
## 一、函数是什么？&#13;
&#13;
- 数学中我们其实就见过函数的概念，比如：一次函数y=kx+b ，k和b都是常数，给一个任意的x，就得到一个y值。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/6.%20C-yu-yan-zhi-han-shu-yi-ji-li-ti-fen-xi.html</guid><pubDate>Mon, 15 Jul 2024 10:06:22 +0000</pubDate></item><item><title>5. C语言之数组应用——扫雷小游戏的实现【含递归展开】</title><link>https://xiaolinzi.eu.org/post/5.%20C-yu-yan-zhi-shu-zu-ying-yong-%E2%80%94%E2%80%94-sao-lei-xiao-you-xi-de-shi-xian-%E3%80%90-han-di-gui-zhan-kai-%E3%80%91.html</link><description>## 前言&#13;
&gt;扫雷游戏是1992年发行的一款大众类益智游戏，对于许多80后、90后来说都是童年的回忆。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/5.%20C-yu-yan-zhi-shu-zu-ying-yong-%E2%80%94%E2%80%94-sao-lei-xiao-you-xi-de-shi-xian-%E3%80%90-han-di-gui-zhan-kai-%E3%80%91.html</guid><pubDate>Mon, 15 Jul 2024 10:05:12 +0000</pubDate></item><item><title>4. C语言之数组应用——三子棋小游戏</title><link>https://xiaolinzi.eu.org/post/4.%20C-yu-yan-zhi-shu-zu-ying-yong-%E2%80%94%E2%80%94-san-zi-qi-xiao-you-xi.html</link><description># 前言&#13;
&gt;三子棋是一种民间传统游戏，又叫九宫棋、圈圈叉叉棋、一条龙、井字棋等。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/4.%20C-yu-yan-zhi-shu-zu-ying-yong-%E2%80%94%E2%80%94-san-zi-qi-xiao-you-xi.html</guid><pubDate>Mon, 15 Jul 2024 10:03:51 +0000</pubDate></item><item><title>3. C语言之详解数组</title><link>https://xiaolinzi.eu.org/post/3.%20C-yu-yan-zhi-xiang-jie-shu-zu.html</link><description>## 一、一维数组的创建和初始化&#13;
&#13;
### 1、数组的创建&#13;
&#13;
数组是一组相同类型元素的集合。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/3.%20C-yu-yan-zhi-xiang-jie-shu-zu.html</guid><pubDate>Mon, 15 Jul 2024 10:03:00 +0000</pubDate></item><item><title>2. C语言之分支与循环【附6个练习】</title><link>https://xiaolinzi.eu.org/post/2.%20C-yu-yan-zhi-fen-zhi-yu-xun-huan-%E3%80%90-fu-6-ge-lian-xi-%E3%80%91.html</link><description>## 前言&#13;
&gt;C语言是结构化的程序设计语言，这里的结构指的是顺序结构、选择结构、循环结构，C语⾔是能够实现这三种结构的，其实我们如果仔细分析，我们⽇常所⻅的事情都可以拆分为这三种结构或者这三种结构的组合。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/2.%20C-yu-yan-zhi-fen-zhi-yu-xun-huan-%E3%80%90-fu-6-ge-lian-xi-%E3%80%91.html</guid><pubDate>Mon, 15 Jul 2024 10:01:58 +0000</pubDate></item><item><title>1. C语言之初识C语言</title><link>https://xiaolinzi.eu.org/post/1.%20C-yu-yan-zhi-chu-shi-C-yu-yan.html</link><description># 前言&#13;
&gt;想必刚接触C语言的同学们不知道C语言是什么？，有什么用，那么你来对了，本系列就会带你入门C语言，从入门到“入土”,开玩笑的，正如标题所说，本教程首先对C语言有一个初步的认识，能够看懂别人写的是什么，有一个大概的框架，那么，我要开始讲解了。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/1.%20C-yu-yan-zhi-chu-shi-C-yu-yan.html</guid><pubDate>Mon, 15 Jul 2024 07:48:59 +0000</pubDate></item><item><title>22. C++的IO流操作</title><link>https://xiaolinzi.eu.org/post/22.%20C%2B%2B-de-IO-liu-cao-zuo.html</link><description>## C语言的输入与输出&#13;
&#13;
- C语言的输入与输出 C语言中我们用到的最频繁的输入输出方式就是`scanf()`与`printf()`。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/22.%20C%2B%2B-de-IO-liu-cao-zuo.html</guid><pubDate>Tue, 09 Jul 2024 06:53:21 +0000</pubDate></item><item><title>21. C++的类型转换</title><link>https://xiaolinzi.eu.org/post/21.%20C%2B%2B-de-lei-xing-zhuan-huan.html</link><description>## C语言中的类型转换&#13;
&#13;
&#13;
- 在C语言中，如果赋值运算符左右两侧类型不同，或者形参与实参类型不匹配，或者返回值类型与接收返回值类型不一致时，就需要发生类型转化，C语言中总共有两种形式的类型转换：隐式类型转换和显式类型转换。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/21.%20C%2B%2B-de-lei-xing-zhuan-huan.html</guid><pubDate>Tue, 09 Jul 2024 06:53:04 +0000</pubDate></item><item><title>20. C++特殊类设计</title><link>https://xiaolinzi.eu.org/post/20.%20C%2B%2B-te-shu-lei-she-ji.html</link><description>## 请设计一个类，不能被拷贝&#13;
&#13;
&#13;
- 拷贝只会放生在两个场景中：**拷贝构造函数以及赋值运算符重载**，因此想要让一个类禁止拷贝， 只需让该类不能调用拷贝构造函数以及赋值运算符重载即可。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/20.%20C%2B%2B-te-shu-lei-she-ji.html</guid><pubDate>Tue, 09 Jul 2024 06:52:28 +0000</pubDate></item><item><title>19. C++11线程库操作</title><link>https://xiaolinzi.eu.org/post/19.%20C%2B%2B11-xian-cheng-ku-cao-zuo.html</link><description>&#13;
## 线程库&#13;
&#13;
&#13;
###  thread类的简单介绍&#13;
&#13;
&#13;
- 在C++11之前，涉及到多线程问题，都是和平台相关的，比如windows和linux下各有自己的接 口，这使得代码的可移植性比较差。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/19.%20C%2B%2B11-xian-cheng-ku-cao-zuo.html</guid><pubDate>Tue, 09 Jul 2024 06:51:59 +0000</pubDate></item><item><title>18. C++智能指针</title><link>https://xiaolinzi.eu.org/post/18.%20C%2B%2B-zhi-neng-zhi-zhen.html</link><description>## 内存泄漏&#13;
&#13;
### 什么是内存泄漏，内存泄漏的危害&#13;
什么是内存泄漏：内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/18.%20C%2B%2B-zhi-neng-zhi-zhen.html</guid><pubDate>Tue, 09 Jul 2024 06:51:18 +0000</pubDate></item><item><title>17. C++异常</title><link>https://xiaolinzi.eu.org/post/17.%20C%2B%2B-yi-chang.html</link><description>## C语言传统的处理错误的方式&#13;
&#13;
传统的错误处理机制：&#13;
&#13;
1.  终止程序，如assert，缺陷：用户难以接受。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/17.%20C%2B%2B-yi-chang.html</guid><pubDate>Tue, 09 Jul 2024 06:50:42 +0000</pubDate></item><item><title>16. C++11 右值引用和移动语义，完美转发和万能引用，移动构造和移动赋值，可变参数模板，lambda表达式，包装器</title><link>https://xiaolinzi.eu.org/post/16.%20C%2B%2B11%20-you-zhi-yin-yong-he-yi-dong-yu-yi-%EF%BC%8C-wan-mei-zhuan-fa-he-wan-neng-yin-yong-%EF%BC%8C-yi-dong-gou-zao-he-yi-dong-fu-zhi-%EF%BC%8C-ke-bian-can-shu-mo-ban-%EF%BC%8Clambda-biao-da-shi-%EF%BC%8C-bao-zhuang-qi.html</link><description>## C++11简介&#13;
&#13;
&gt;C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/16.%20C%2B%2B11%20-you-zhi-yin-yong-he-yi-dong-yu-yi-%EF%BC%8C-wan-mei-zhuan-fa-he-wan-neng-yin-yong-%EF%BC%8C-yi-dong-gou-zao-he-yi-dong-fu-zhi-%EF%BC%8C-ke-bian-can-shu-mo-ban-%EF%BC%8Clambda-biao-da-shi-%EF%BC%8C-bao-zhuang-qi.html</guid><pubDate>Tue, 09 Jul 2024 04:36:06 +0000</pubDate></item><item><title>15. C++哈希表、哈希桶的实现以及模拟实现封装unordered_map 和 unordered_set &amp;&amp; 位图 &amp;&amp; 布隆过滤器 &amp;&amp; 哈希切割相关</title><link>https://xiaolinzi.eu.org/post/15.%20C%2B%2B-ha-xi-biao-%E3%80%81-ha-xi-tong-de-shi-xian-yi-ji-mo-ni-shi-xian-feng-zhuang-unordered_map%20-he-%20unordered_set%20%26%26%20-wei-tu-%20%26%26%20-bu-long-guo-lv-qi-%20%26%26%20-ha-xi-qie-ge-xiang-guan.html</link><description>## unordered系列关联式容器&#13;
&#13;
- 在C++98中，STL提供了底层为红黑树结构的一系列关联式容器，在查询时效率可达到$log_2N$，即最差情况下需要比较红黑树的高度次，当树中的节点非常多时，查询效率也不理想。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/15.%20C%2B%2B-ha-xi-biao-%E3%80%81-ha-xi-tong-de-shi-xian-yi-ji-mo-ni-shi-xian-feng-zhuang-unordered_map%20-he-%20unordered_set%20%26%26%20-wei-tu-%20%26%26%20-bu-long-guo-lv-qi-%20%26%26%20-ha-xi-qie-ge-xiang-guan.html</guid><pubDate>Tue, 09 Jul 2024 04:33:51 +0000</pubDate></item><item><title>14. 红黑树【C++实现】</title><link>https://xiaolinzi.eu.org/post/14.%20-hong-hei-shu-%E3%80%90C%2B%2B-shi-xian-%E3%80%91.html</link><description>## 红黑树的概念&#13;
&#13;
**红黑树**（英语：Red–black tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型用途是实现关联数组。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/14.%20-hong-hei-shu-%E3%80%90C%2B%2B-shi-xian-%E3%80%91.html</guid><pubDate>Tue, 09 Jul 2024 04:33:28 +0000</pubDate></item><item><title>13. AVL树【C++实现】</title><link>https://xiaolinzi.eu.org/post/13.%20AVL-shu-%E3%80%90C%2B%2B-shi-xian-%E3%80%91.html</link><description>## AVL树的概念&#13;
&#13;
&#13;
- AVL树（英语：AVL tree）是计算机科学中最早被发明的自平衡二叉查找树。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/13.%20AVL-shu-%E3%80%90C%2B%2B-shi-xian-%E3%80%91.html</guid><pubDate>Tue, 09 Jul 2024 04:33:07 +0000</pubDate></item><item><title>12. C++二叉搜索树介绍以及实现</title><link>https://xiaolinzi.eu.org/post/12.%20C%2B%2B-er-cha-sou-suo-shu-jie-shao-yi-ji-shi-xian.html</link><description>## 二叉搜索树&#13;
&#13;
### 二叉搜索树概念&#13;
&#13;
&#13;
- 二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:&#13;
&#13;
	- 若它的左子树不为空，则左子树上所有节点的值都小于根节点的值&#13;
	- 若它的右子树不为空，则右子树上所有节点的值都大于根节点的值&#13;
	- 它的左右子树也分别为二叉搜索树&#13;
&#13;
&#13;
&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/a9d67fd3c3914e179128d2004c1f734d.png)&#13;
&#13;
&#13;
### 二叉搜索树操作&#13;
&#13;
&#13;
&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3fc378ecb75e4ee5a940c98d1c1ee369.png)&#13;
&#13;
&#13;
```c&#13;
int a[] = {8, 3, 1, 10, 6, 4, 7, 14, 13};&#13;
```&#13;
&#13;
&#13;
&#13;
1. 二叉搜索树的**查找**&#13;
a、从根开始比较，查找，比**根大则往右边走查找，比根小则往左边走查找**。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/12.%20C%2B%2B-er-cha-sou-suo-shu-jie-shao-yi-ji-shi-xian.html</guid><pubDate>Tue, 09 Jul 2024 04:32:46 +0000</pubDate></item><item><title>11. C++多态总结与原理、菱形继承问题</title><link>https://xiaolinzi.eu.org/post/11.%20C%2B%2B-duo-tai-zong-jie-yu-yuan-li-%E3%80%81-ling-xing-ji-cheng-wen-ti.html</link><description>## 多态&#13;
&#13;
&#13;
### 什么是多态&#13;
&#13;
- 生活中的多态，是指的客观的事物在人脑中的主观体现。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/11.%20C%2B%2B-duo-tai-zong-jie-yu-yuan-li-%E3%80%81-ling-xing-ji-cheng-wen-ti.html</guid><pubDate>Tue, 09 Jul 2024 04:32:22 +0000</pubDate></item><item><title>10. C++继承总结</title><link>https://xiaolinzi.eu.org/post/10.%20C%2B%2B-ji-cheng-zong-jie.html</link><description>## 封装&#13;
&#13;
&#13;
&gt;我们之前学了封装，那么封装到底是什么呢？&#13;
&#13;
- 封装&#13;
	-	数据和方法放到一起，把想给外面访问的定义成公有，不想给你访问的定义成私有和保护&#13;
	-	一个类型放到另一个类型里面，通过typedef成员函数调整，封装另一个全新的类型&#13;
&#13;
## 继承的概念及定义&#13;
&#13;
### 继承的概念&#13;
&#13;
- 继承(inheritance)机制是面向对象程序**设计使代码可以复用**的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/10.%20C%2B%2B-ji-cheng-zong-jie.html</guid><pubDate>Tue, 09 Jul 2024 04:30:58 +0000</pubDate></item><item><title>9. C++模板【函数模板与类模板】【非类型模板参数、模板特化和模板分离编译】</title><link>https://xiaolinzi.eu.org/post/9.%20C%2B%2B-mo-ban-%E3%80%90-han-shu-mo-ban-yu-lei-mo-ban-%E3%80%91%E3%80%90-fei-lei-xing-mo-ban-can-shu-%E3%80%81-mo-ban-te-hua-he-mo-ban-fen-li-bian-yi-%E3%80%91.html</link><description>## 前言&#13;
&#13;
- 如何实现一个通用的交换函数呢？&#13;
&#13;
&#13;
```cpp&#13;
void Swap(int&amp; left, int&amp; right)&#13;
{&#13;
	int temp = left;&#13;
	left = right;&#13;
	right = temp;&#13;
}&#13;
void Swap(double&amp; left, double&amp; right)&#13;
{&#13;
	double temp = left;&#13;
	left = right;&#13;
	right = temp;&#13;
}&#13;
void Swap(char&amp; left, char&amp; right)&#13;
{&#13;
	char temp = left;&#13;
	left = right;&#13;
	right = temp;&#13;
}&#13;
// ......&#13;
```&#13;
&#13;
&#13;
使用函数重载虽然可以实现，但是有一下几个不好的地方：&#13;
1. 重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函数&#13;
2. 代码的可维护性比较低，一个出错可能所有的重载均出错&#13;
&#13;
&#13;
那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？&#13;
&#13;
&#13;
- 如果在C++中，也能够存在这样一个模具，通过给这个模具中填充不同材料(类型)，来获得不同材料的铸件(即生成具体类型的代码），那将会节省许多头发。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/9.%20C%2B%2B-mo-ban-%E3%80%90-han-shu-mo-ban-yu-lei-mo-ban-%E3%80%91%E3%80%90-fei-lei-xing-mo-ban-can-shu-%E3%80%81-mo-ban-te-hua-he-mo-ban-fen-li-bian-yi-%E3%80%91.html</guid><pubDate>Mon, 08 Jul 2024 12:16:43 +0000</pubDate></item><item><title>8. C++内存管理学习【new】</title><link>https://xiaolinzi.eu.org/post/8.%20C%2B%2B-nei-cun-guan-li-xue-xi-%E3%80%90new%E3%80%91.html</link><description>&#13;
## 一、C/C++内存分布&#13;
&#13;
- 在学习之前我们先看一下下面这些代码都分布在哪里？&#13;
&#13;
```cpp&#13;
int globalVar = 1;&#13;
static int staticGlobalVar = 1;&#13;
void Test()&#13;
{&#13;
	static int staticVar = 1;&#13;
	int localVar = 1;&#13;
	int num1[10] = { 1, 2, 3, 4 };&#13;
	char char2[] = 'abcd';&#13;
	const char* pChar3 = 'abcd';&#13;
	int* ptr1 = (int*)malloc(sizeof(int) * 4);&#13;
	int* ptr2 = (int*)calloc(4, sizeof(int));&#13;
	int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);&#13;
	free(ptr1);&#13;
	free(ptr3);&#13;
}&#13;
```&#13;
1. 选择题：&#13;
&gt;选项: A.栈 B.堆 C.数据段(静态区) D.代码段(常量区)&#13;
&#13;
- globalVar在哪里？__C__ &#13;
- staticGlobalVar在哪里？__C__&#13;
- staticVar在哪里？__C__ &#13;
- localVar在哪里？__A__&#13;
- num1 在哪里？__A__ &#13;
&#13;
---&#13;
&#13;
- char2在哪里？__A__ &#13;
	- 字符串在常量区，char2会栈上开辟一个数组，然后将常量区的字符串拷贝过到栈上，所以结果是A，上题的num1是直接在栈上开辟的，所以相似&#13;
- *char2在哪里？__A__&#13;
	- 这个上题说过了不讲了&#13;
- pChar3在哪里？__A__ &#13;
	- const修饰的是代表常变量，不代表就在常量区，pChar3是栈上的一个变量，指向了常量区的字符串&#13;
- *pChar3在哪里？__D__&#13;
	- 常量区的字符串，解引用就是找的常量区	&#13;
- ptr1在哪里？__A__&#13;
	- 也是栈上的一块变量 &#13;
- *ptr1在哪里？__B__&#13;
	- 开辟的空间在堆上&#13;
&#13;
---&#13;
&#13;
2. 填空题：&#13;
&#13;
   - sizeof(num1) = __40__;&#13;
&#13;
&#13;
   - sizeof(char2) = __5__; &#13;
   - strlen(char2) = __4__;&#13;
   - sizeof(pChar3) = __4/8__;&#13;
   - strlen(pChar3) = __4__;&#13;
   - sizeof(ptr1) = __4/8__;&#13;
&#13;
3. sizeof 和 strlen 区别？&#13;
   - 这里已经在学习C语言章节里说了就不再细说了&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/222e5053152349748dfbb7221935ef4e.png)&#13;
&#13;
&#13;
&#13;
&#13;
【说明】&#13;
1. 栈又叫堆栈--非静态局部变量/函数参数/返回值等等，栈是向下增长的。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/8.%20C%2B%2B-nei-cun-guan-li-xue-xi-%E3%80%90new%E3%80%91.html</guid><pubDate>Mon, 08 Jul 2024 12:16:26 +0000</pubDate></item><item><title>7. C++初始化列表、static成员、友元、匿名对象、附练习题</title><link>https://xiaolinzi.eu.org/post/7.%20C%2B%2B-chu-shi-hua-lie-biao-%E3%80%81static-cheng-yuan-%E3%80%81-you-yuan-%E3%80%81-ni-ming-dui-xiang-%E3%80%81-fu-lian-xi-ti.html</link><description>&#13;
## 前言&#13;
&gt;我们前面学习了关于类和对象的6个默认成员函数，知道了一个空类中有构造函数和析构函数，通过对对象初始化和对象中进行资源清理，达到初始化和销毁的作用。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/7.%20C%2B%2B-chu-shi-hua-lie-biao-%E3%80%81static-cheng-yuan-%E3%80%81-you-yuan-%E3%80%81-ni-ming-dui-xiang-%E3%80%81-fu-lian-xi-ti.html</guid><pubDate>Mon, 08 Jul 2024 12:02:43 +0000</pubDate></item><item><title>6. C++中默认成员函数【取地址重载】【const成员函数】 【运算符重载】【实现一个日期类】</title><link>https://xiaolinzi.eu.org/post/6.%20C%2B%2B-zhong-mo-ren-cheng-yuan-han-shu-%E3%80%90-qu-di-zhi-zhong-zai-%E3%80%91%E3%80%90const-cheng-yuan-han-shu-%E3%80%91%20%E3%80%90-yun-suan-fu-zhong-zai-%E3%80%91%E3%80%90-shi-xian-yi-ge-ri-qi-lei-%E3%80%91.html</link><description>## 一、【C++】赋值运算符重载&#13;
&#13;
&#13;
### 1.1 运算符重载【引入】&#13;
&#13;
- C++为了增强代码的可读性引入了**运算符重载**，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/6.%20C%2B%2B-zhong-mo-ren-cheng-yuan-han-shu-%E3%80%90-qu-di-zhi-zhong-zai-%E3%80%91%E3%80%90const-cheng-yuan-han-shu-%E3%80%91%20%E3%80%90-yun-suan-fu-zhong-zai-%E3%80%91%E3%80%90-shi-xian-yi-ge-ri-qi-lei-%E3%80%91.html</guid><pubDate>Mon, 08 Jul 2024 04:47:57 +0000</pubDate></item><item><title>5. C++中类的6个默认成员函数【构造函数】【析构函数】【拷贝构造】</title><link>https://xiaolinzi.eu.org/post/5.%20C%2B%2B-zhong-lei-de-6-ge-mo-ren-cheng-yuan-han-shu-%E3%80%90-gou-zao-han-shu-%E3%80%91%E3%80%90-xi-gou-han-shu-%E3%80%91%E3%80%90-kao-bei-gou-zao-%E3%80%91.html</link><description>## 前言&#13;
&#13;
&gt;在学习C++我们必须要掌握的6个默认成员函数，接下来我们挨个学习：&#13;
&#13;
## 构造函数&#13;
&#13;
&#13;
- 如果一个类中什么成员都没有，简称为空类。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/5.%20C%2B%2B-zhong-lei-de-6-ge-mo-ren-cheng-yuan-han-shu-%E3%80%90-gou-zao-han-shu-%E3%80%91%E3%80%90-xi-gou-han-shu-%E3%80%91%E3%80%90-kao-bei-gou-zao-%E3%80%91.html</guid><pubDate>Wed, 03 Jul 2024 07:50:15 +0000</pubDate></item><item><title>4. C++引用、内联函数、auto关键字介绍以及C++中无法使用NULL的原因</title><link>https://xiaolinzi.eu.org/post/4.%20C%2B%2B-yin-yong-%E3%80%81-nei-lian-han-shu-%E3%80%81auto-guan-jian-zi-jie-shao-yi-ji-C%2B%2B-zhong-wu-fa-shi-yong-NULL-de-yuan-yin.html</link><description>## 一、引用&#13;
### 1.1 引用概念&#13;
&#13;
&gt;C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/4.%20C%2B%2B-yin-yong-%E3%80%81-nei-lian-han-shu-%E3%80%81auto-guan-jian-zi-jie-shao-yi-ji-C%2B%2B-zhong-wu-fa-shi-yong-NULL-de-yuan-yin.html</guid><pubDate>Wed, 03 Jul 2024 01:57:21 +0000</pubDate></item><item><title>3. C++类和对象引入以及类的介绍使用</title><link>https://xiaolinzi.eu.org/post/3.%20C%2B%2B-lei-he-dui-xiang-yin-ru-yi-ji-lei-de-jie-shao-shi-yong.html</link><description>## 一、面向过程和面向对象的初步认识&#13;
&#13;
&gt;C语言是面向过程的，关注的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/3.%20C%2B%2B-lei-he-dui-xiang-yin-ru-yi-ji-lei-de-jie-shao-shi-yong.html</guid><pubDate>Mon, 01 Jul 2024 09:04:16 +0000</pubDate></item><item><title>2. C++中隐含的this指针讲解</title><link>https://xiaolinzi.eu.org/post/2.%20C%2B%2B-zhong-yin-han-de-this-zhi-zhen-jiang-jie.html</link><description>&#13;
## 一、this指针的引出&#13;
&#13;
&#13;
- 我们先来定义一个日期类`Date`，下面这段代码执行的结果是什么呢？&#13;
&#13;
&#13;
```cpp&#13;
class Date&#13;
{&#13;
public:&#13;
	void Init(int year, int month, int day)&#13;
	{&#13;
		_year = year;&#13;
		_month = month;&#13;
		_day = day;&#13;
	}&#13;
	void print()&#13;
	{&#13;
		cout &lt;&lt; _year &lt;&lt; '-' &lt;&lt; _month &lt;&lt; '-' &lt;&lt; _day &lt;&lt; endl;&#13;
		&#13;
	}&#13;
private:&#13;
	int _year; &#13;
	int _month; &#13;
	int _day; &#13;
};&#13;
int main()&#13;
{&#13;
	Date d1, d2;&#13;
	&#13;
	d1.Init(2022, 5, 11);&#13;
	d2.Init(2022, 5, 12);&#13;
&#13;
	d1.print();&#13;
	d2.print();&#13;
	return 0;&#13;
}&#13;
```&#13;
&#13;
- 可以看到分别打印出了**两个日期**，它是怎么知道改打印哪个的？&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/6069c982dacd4e20840ca421e99ce0d1.png)&#13;
&#13;
&#13;
- 我们来分析一下，先看一下**汇编代码，看一看**&#13;
&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/dba395b3dc58423b92fa5d0b44abdfcb.png)&#13;
&#13;
&#13;
----&#13;
&#13;
- 我们看到上面的代码是调用的**同一个函数**，那么编译器是如何知道那两个日期的？&#13;
&#13;
- 其实C++里有一个**隐含**的**this指针**，在[微软的官方文档](https://learn.microsoft.com/zh-cn/cpp/cpp/this-pointer?view=msvc-170)也有说明&#13;
&#13;
- 在使用函数的时候其实里面**传了一个地址，然后有一个隐的this指针来接收**&#13;
&#13;
---&#13;
&#13;
&gt;原形是这样：&#13;
&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/fcc3f5a320bb4692a65474ddce4eba88.png)&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/da0b81f7cab34af0898930cb25b289a0.png)&#13;
&#13;
&#13;
- 那为什么这里**报错**了呢？&#13;
- 因为不必要写，这个是**隐含**的~~，我们可以**直接在类里面使用**&#13;
&#13;
&#13;
&#13;
## 二、this指针的特性&#13;
&#13;
- 刚刚上面也给你看了原形，细心的烙铁已经发现了，这个this指针是有一个**const修饰**的，而且这个const是在`*`的右边&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/d561f02819e2498f9f842af479520663.png)&#13;
&#13;
&#13;
- 这里的`const`修饰，在`const`的右边&#13;
&#13;
- 下面我们回忆一下~&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/221ab0d8a51540be90c5c7d5ff12f0a7.png)&#13;
&#13;
- 到这里就得出的**this本身是不被修改的，但是做指向的值是可以被修改**&#13;
&#13;
- 我们可以在类中打印一下`this`指针的地址，再打印一下`d1`和`d2`的地址，我们来看一下：&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/26696d96afce46419aeca6760ef18445.png)&#13;
&#13;
- 得到结果就是this指针指向一个指向**当前对象**的指针&#13;
&#13;
---&#13;
&#13;
- 我们还可以下面这样，是不会报错的，但是不能向上面直接在形参就写上&#13;
&#13;
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/f76630adebed4fdcbd84da92faaf531c.png)&#13;
&#13;
特点：&#13;
&#13;
**1、形参和实参的位置，我们不能显示写&#13;
2、函数内部可以使用**&#13;
&#13;
---&#13;
&#13;
- **最后总结一下：**&#13;
&#13;
1. this指针的类型：类型 **\*const**，即成员函数中，**不能给this指针赋值**。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/2.%20C%2B%2B-zhong-yin-han-de-this-zhi-zhen-jiang-jie.html</guid><pubDate>Sun, 30 Jun 2024 07:46:08 +0000</pubDate></item><item><title>1. C++的关键字，命名空间，缺省参数，函数重载以及原理</title><link>https://xiaolinzi.eu.org/post/1.%20C%2B%2B-de-guan-jian-zi-%EF%BC%8C-ming-ming-kong-jian-%EF%BC%8C-que-sheng-can-shu-%EF%BC%8C-han-shu-zhong-zai-yi-ji-yuan-li.html</link><description>&#13;
# 前言&#13;
&#13;
&#13;
&gt;从今天开始就序列更新C++的文章了，希望大家可以耐心的坚持下去学习，有一个很好的成长~~&#13;
&#13;
&#13;
首先来看一下C++的介绍，百度百科C++ -- &gt;[点我跳转](https://baike.baidu.com/item/C++/99272)&#13;
&#13;
&#13;
&gt;C++是在C的基础之上，容纳进去了面向对象编程思想，并增加了许多有用的库，以及编程范式等。</description><guid isPermaLink="true">https://xiaolinzi.eu.org/post/1.%20C%2B%2B-de-guan-jian-zi-%EF%BC%8C-ming-ming-kong-jian-%EF%BC%8C-que-sheng-can-shu-%EF%BC%8C-han-shu-zhong-zai-yi-ji-yuan-li.html</guid><pubDate>Sat, 29 Jun 2024 09:28:19 +0000</pubDate></item></channel></rss>